<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ–¼ï¸</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1800px;
        }
        .controls {
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            width: 360px;
            align-self: flex-start;
            position: sticky;
            top: 20px;
            overflow: hidden;
        }
        .tab-container {
            display: flex;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
        }
        .tab {
            padding: 12px 16px;
            flex: 1;
            text-align: center;
            cursor: pointer;
            color: #666;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .tab.active {
            color: #007aff;
            border-bottom-color: #007aff;
            background: #fff;
        }
        .tab:hover:not(.active) {
            background: #f0f0f0;
        }
        .tab-content {
            display: none;
            padding: 16px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .tab-content.active {
            display: block;
        }
        .control-group {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        #canvasContainer {
            border: 1px solid #e0e0e0;
            background-color: #f8f9fa;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            position: relative;
            overflow: auto;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            border-radius: 12px;
        }
        canvas {
            display: block;
            cursor: default;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin: 12px;
            border-radius: 8px;
        }

        .controls h3 { margin-top: 0; margin-bottom: 8px; color: #333; }
        .controls .input-row, .controls .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .controls label {
            display: inline-block;
            width: auto;
            margin-bottom: 0;
            margin-right: 8px;
            padding: 0;
            border: none;
            background: none;
            font-weight: 500;
            vertical-align: middle;
            min-width: 60px;
        }
        .controls input,
        .controls select {
            display: inline-block;
            width: auto;
            min-width: 80px;
            margin-bottom: 0;
            margin-right: 0;
            vertical-align: middle;
        }
        .controls button, .button-like-label {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 18px;
            padding: 5px 10px;
            border-radius: 10px;
        }
        .controls button:hover, .button-like-label:hover { background-color: #0056b3; }
        .controls .tool-button.active { background-color: #28a745; }
        .controls .tool-button {
            font-size: 18px;
            padding: 5px 10px;
            border-radius: 10px;
        }
        .keyboard-shortcut {
            font-size: 16px;
        }

        .hidden-input { display: none; }
        /* çµ±ä¸€é¡è‰²é¸æ“‡å™¨æ¨£å¼ */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-picker-wrapper input[type="color"] {
            width: 32px;
            height: 32px;
            padding: 0;
            border: none;
            border-radius: 4px;
            background: none;
            box-shadow: 0 1px 4px rgba(0,0,0,0.08);
            cursor: pointer;
            display: inline-block;
        }
        /* è®“labelå’Œé¡è‰²é¸æ“‡å™¨åŒä¸€è¡Œ */
        .controls .input-row, .controls .color-picker-wrapper {
            flex-wrap: nowrap;
        }

        .guideline { position: absolute; background-color: rgba(255, 0, 0, 0.5); z-index: 9999; }
        .guideline.horizontal { width: 100%; height: 1px; left: 0; }
        .guideline.vertical { height: 100%; width: 1px; top: 0; }

        .button-like-label {
            display: inline-block;
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            margin-bottom: 8px;
            width: calc(100% - 16px);
            box-sizing: border-box;
        }
        hr { border: 0; height: 1px; background: #ddd; margin: 15px 0; }

        input[type="file"] {
            display: none !important;
        }

        /* æµ®å‹•æç¤ºæ¨£å¼ */
        .copied-toast {
            position: fixed;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            color: #fff;
            padding: 12px 32px;
            border-radius: 24px;
            font-size: 18px;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.3s;
        }
        .copied-toast.show {
            opacity: 1;
        }

        /* ç¾åŒ–ä¸‹æ‹‰é¸å–®ã€æ•¸å­—è¼¸å…¥æ¡†ã€æ–‡å­—è¼¸å…¥æ¡† */
        .controls select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background: #f5f7fa url('data:image/svg+xml;utf8,<svg fill="%23666" height="20" viewBox="0 0 20 20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M7.293 7.293a1 1 0 011.414 0L10 8.586l1.293-1.293a1 1 0 111.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z"/></svg>') no-repeat right 0.75em center/1.2em 1.2em;
            border: 1.5px solid #d1d5db;
            border-radius: 6px;
            padding: 7px 2.2em 7px 12px;
            font-size: 16px;
            color: #333;
            transition: border 0.2s;
        }
        .controls select:focus {
            outline: none;
            border-color: #007aff;
            background-color: #fff;
        }
        .controls input[type="number"],
        .controls input[type="text"] {
            border: 1.5px solid #d1d5db;
            border-radius: 6px;
            padding: 7px 12px;
            font-size: 16px;
            color: #333;
            background: #f5f7fa;
            transition: border 0.2s, box-shadow 0.2s;
        }
        .controls input[type="number"]:focus,
        .controls input[type="text"]:focus {
            outline: none;
            border-color: #007aff;
            background: #fff;
            box-shadow: 0 0 0 2px #007aff22;
        }
        /* éš±è—æ•¸å­—è¼¸å…¥æ¡†çš„ä¸Šä¸‹ç®­é ­ï¼ˆå¯é¸ï¼‰ */
        .controls input[type="number"]::-webkit-inner-spin-button, 
        .controls input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .controls input[type="number"] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body>
    <!-- <h1>åœ–ç‰‡ç·¨è¼¯èˆ‡PDFè¼¸å‡ºå·¥å…· (é›¢ç·šç‰ˆ)</h1> --> <!-- ç§»é™¤æ¨™é¡Œæ¬„ -->

    <div class="container">
        <div class="controls">
            <div class="tab-container">
                <div class="tab active" data-tab="tools">å·¥å…·</div>
                <div class="tab" data-tab="canvas">ç•«å¸ƒ</div>
                <div class="tab" data-tab="export">åŒ¯å‡º</div>
            </div>
            <div class="tab-content active" id="tools-content">
                <div class="control-group">
                    <h3>åŸºæœ¬æ“ä½œ</h3>
                    <button class="btn" id="imageUploadBtn">
                        <span>ä¸Šå‚³åœ–ç‰‡</span>
                    </button>
                    <input type="file" id="imageUpload" accept="image/*" multiple class="hidden-input">
                </div>
                <div class="control-group">
                    <h3>å·¥å…·é¸æ“‡</h3>
                    <button id="selectTool" class="tool-button active">ç§»å‹• <span class="keyboard-shortcut">V</span></button>
                    <button id="drawTool" class="tool-button">ç•«ç­† <span class="keyboard-shortcut">B</span></button>
                    <button id="textTool" class="tool-button">æ–‡å­— <span class="keyboard-shortcut">T</span></button>
                </div>

                <div id="drawingOptions" style="display:none;">
                    <h4>ç•«ç­†é¸é …</h4>
                    <div class="input-row">
                        <label for="strokeColor">é¡è‰²:</label>
                        <div class="color-picker-wrapper">
                            <input type="color" id="strokeColor" value="#FF0000">
                        </div>
                    </div>
                    <label for="lineWidth">ç·šå¯¬:</label>
                    <input type="range" id="lineWidth" min="1" max="10" value="1">
                </div>

                <div id="textOptions" style="display:none;">
                    <h4>æ–‡å­—é¸é …</h4>
                    <div class="input-row">
                        <label for="textColor">é¡è‰²:</label>
                        <div class="color-picker-wrapper">
                            <input type="color" id="textColor" value="#000000">
                        </div>
                    </div>
                    <label for="fontSize">å¤§å°:</label>
                    <input type="number" id="fontSize" value="16" min="8">
                    <label for="fontFamily">å­—å‹:</label>
                    <select id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Microsoft JhengHei, sans-serif">å¾®è»Ÿæ­£é»‘é«” (Sans-Serif)</option>
                        <option value="MingLiU, serif">ç´°æ˜é«” (Serif)</option>
                        <option value="sans-serif">Sans-Serif (é è¨­)</option>
                    </select>
                </div>

                <hr>
                <div id="selectedObjectControls" style="display:none;">
                    <h3>é¸ä¸­ç‰©ä»¶</h3>
                    <div class="input-row" id="objectNameRow">
                        <label for="objectName">é¡¯ç¤ºåç¨±:</label>
                        <input type="text" id="objectName" placeholder="è¼¸å…¥ç‰©ä»¶åç¨±">
                    </div>
                    <div id="textEditFields" style="display:none;">
                        <div class="input-row">
                            <label for="editTextContent">å…§å®¹:</label>
                            <input type="text" id="editTextContent" placeholder="è¼¸å…¥æ–‡å­—å…§å®¹">
                        </div>
                        <div class="input-row">
                            <label for="editTextColor">é¡è‰²:</label>
                            <input type="color" id="editTextColor">
                        </div>
                        <div class="input-row">
                            <label for="editFontSize">å¤§å°:</label>
                            <input type="number" id="editFontSize" min="8">
                        </div>
                        <div class="input-row">
                            <label for="editFontFamily">å­—å‹:</label>
                            <select id="editFontFamily">
                                <option value="Arial">Arial</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Microsoft JhengHei, sans-serif">å¾®è»Ÿæ­£é»‘é«” (Sans-Serif)</option>
                                <option value="MingLiU, serif">ç´°æ˜é«” (Serif)</option>
                                <option value="sans-serif">Sans-Serif (é è¨­)</option>
                            </select>
                        </div>
                    </div>
                    <div class="input-row">
                        <button id="deleteSelected">åˆªé™¤ç‰©ä»¶(Del)</button>
                        <button id="bringToFront">æœ€ä¸Š</button>
                        <button id="sendToBack">æœ€ä¸‹</button>
                    </div>
                </div>
            </div>
            <div class="tab-content" id="canvas-content">
                <div class="control-group">
                    <h3>ç•«å¸ƒè¨­å®š</h3>
                    <div class="input-row">
                        <label for="pageSize">ç´™å¼µå¤§å°:</label>
                        <select id="pageSize">
                            <option value="A4">A4 (210 x 297 mm)</option>
                            <option value="A3">A3 (297 x 420 mm)</option>
                            <option value="Letter">Letter (8.5 x 11 in)</option>
                            <option value="Custom">è‡ªè¨‚ (ä½¿ç”¨ä¸‹æ–¹å¯¬é«˜)</option>
                        </select>
                    </div>
                    <div class="input-row">
                        <label for="pageOrientation">é é¢æ–¹å‘:</label>
                        <select id="pageOrientation">
                            <option value="portrait">ç¸±å‘</option>
                            <option value="landscape">æ©«å‘</option>
                        </select>
                    </div>
                    <div id="customSizeInputs" style="display:none;" class="input-row">
                        <label for="customCanvasWidth">è‡ªè¨‚å¯¬åº¦ (px):</label>
                        <input type="number" id="customCanvasWidth" value="800">
                        <label for="customCanvasHeight">è‡ªè¨‚é«˜åº¦ (px):</label>
                        <input type="number" id="customCanvasHeight" value="1000">
                    </div>
                    <div class="input-row">
                        <label for="numPages">é è¨ˆé æ•¸:</label>
                        <input type="number" id="numPages" value="1" min="1">
                    </div>
                    <div class="input-row">
                        <button class="btn" id="updateCanvasLayout">æ›´æ–°ç•«å¸ƒ</button>
                        <button class="btn btn-secondary" id="clearAnnotations">æ¸…ç©ºç­†ç•«ã€æ–‡å­—</button>
                    </div>
                </div>
            </div>
            <div class="tab-content" id="export-content">
                <div class="control-group">
                    <h3>å°ˆæ¡ˆ</h3>
                    <button class="btn" id="exportProject">åŒ¯å‡ºå°ˆæ¡ˆ (.json)</button>
                    <button class="btn btn-secondary" id="importProjectBtn">åŒ¯å…¥å°ˆæ¡ˆ</button>
                    <input type="file" id="importProjectInput" accept=".json" class="hidden-input">
                </div>
                <div class="control-group">
                    <h3>è¼¸å‡º</h3>
                    <button class="btn" id="exportPdf">è¼¸å‡ºPDF</button>
                    <button class="btn" id="copyHiRes">è¤‡è£½åœ–ç‰‡</button>
                    <p class="hint">PDFè¼¸å‡ºé è¨­ç„¡é‚Šæ¡†ã€‚è«‹åƒè€ƒç•«å¸ƒä¸Šçš„åˆ†é æŒ‡ç¤ºç·šèª¿æ•´åœ–ç‰‡ä½ç½®</p>
                </div>
            </div>
        </div>

        <div id="canvasContainer">
            <canvas id="editorCanvas"></canvas>
        </div>
    </div>

    <div id="copiedToast" class="copied-toast">å·²è¤‡è£½</div>

    <script>
        const { jsPDF } = window.jspdf;

        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');
        const imageUpload = document.getElementById('imageUpload');

        const selectToolBtn = document.getElementById('selectTool');
        const drawToolBtn = document.getElementById('drawTool');
        const textToolBtn = document.getElementById('textTool');

        const drawingOptionsDiv = document.getElementById('drawingOptions');
        const strokeColorInput = document.getElementById('strokeColor');
        const lineWidthInput = document.getElementById('lineWidth');

        const textOptionsDiv = document.getElementById('textOptions');
        const textColorInput = document.getElementById('textColor');
        const fontSizeInput = document.getElementById('fontSize');
        const fontFamilySelect = document.getElementById('fontFamily');

        const selectedObjectControlsDiv = document.getElementById('selectedObjectControls');
        const objectNameInput = document.getElementById('objectName');
        const deleteSelectedBtn = document.getElementById('deleteSelected');
        const bringToFrontBtn = document.getElementById('bringToFront');
        const sendToBackBtn = document.getElementById('sendToBack');
        // æ–°å¢
        const textEditFields = document.getElementById('textEditFields');
        const editTextContent = document.getElementById('editTextContent');
        const editTextColor = document.getElementById('editTextColor');
        const editFontSize = document.getElementById('editFontSize');
        const editFontFamily = document.getElementById('editFontFamily');

        const pageSizeSelect = document.getElementById('pageSize');
        const pageOrientationSelect = document.getElementById('pageOrientation');
        const customSizeInputsDiv = document.getElementById('customSizeInputs');
        const customCanvasWidthInput = document.getElementById('customCanvasWidth');
        const customCanvasHeightInput = document.getElementById('customCanvasHeight');
        const numPagesInput = document.getElementById('numPages');
        const updateCanvasLayoutBtn = document.getElementById('updateCanvasLayout');
        const clearAnnotationsBtn = document.getElementById('clearAnnotations');

        const exportProjectBtn = document.getElementById('exportProject');
        const importProjectInput = document.getElementById('importProjectInput');
        const exportPdfBtn = document.getElementById('exportPdf');
        const copyHiResBtn = document.getElementById('copyHiRes');

        let canvasObjects = [];
        let selectedObject = null;
        let currentTool = 'select';

        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragOffsetX, dragOffsetY;

        let isDrawing = false;
        let currentPath = [];

        const RESIZE_HANDLE_SIZE = 8;
        const ALIGNMENT_THRESHOLD = 8;
        const DPI = 96;
        const MM_TO_INCH = 1 / 25.4;
        let singlePagePixelHeight = 0;

        const PAGE_DIMENSIONS = {
            'A4': { width: 210, height: 297 },
            'A3': { width: 297, height: 420 },
            'Letter': { width: 215.9, height: 279.4 }
        };

        let lastCanvasMouseX = null;
        let lastCanvasMouseY = null;

        const ROTATE_BUTTON_SIZE = 20;
        const ROTATE_BUTTON_OFFSET = 5;


        // --- Initialization ---
        function getPixelDimensions(size, orientation, pages) {
            let W_mm, H_mm;
            if (size === 'Custom') {
                return {
                    width: parseInt(customCanvasWidthInput.value) || 800,
                    height: parseInt(customCanvasHeightInput.value) || 1000,
                    isCustom: true
                };
            }

            const dims = PAGE_DIMENSIONS[size];
            if (!dims) return { width: 800, height: 1000, isCustom: true };

            if (orientation === 'portrait') {
                W_mm = dims.width; H_mm = dims.height;
            } else {
                W_mm = dims.height; H_mm = dims.width;
            }
            const W_px = Math.round(W_mm * MM_TO_INCH * DPI);
            const H_px_single = Math.round(H_mm * MM_TO_INCH * DPI);

            return { width: W_px, height: H_px_single * pages, singlePageH: H_px_single, isCustom: false };
        }

        function updateCanvasLayout() {
            const selectedSize = pageSizeSelect.value;
            const selectedOrientation = pageOrientationSelect.value;
            const pages = (selectedSize === 'Custom') ? 1 : (parseInt(numPagesInput.value) || 1);

            const dims = getPixelDimensions(selectedSize, selectedOrientation, pages);
            canvas.width = dims.width;
            canvas.height = dims.height;
            singlePagePixelHeight = dims.isCustom ? 0 : dims.singlePageH;

            lastCanvasMouseX = canvas.width / 2;
            lastCanvasMouseY = canvas.height / 2;

            redrawCanvas();
        }

        pageSizeSelect.addEventListener('change', () => {
            const isCustom = pageSizeSelect.value === 'Custom';
            customSizeInputsDiv.style.display = isCustom ? 'block' : 'none';
            numPagesInput.disabled = isCustom;
            if(!isCustom) updateCanvasLayout();
        });
        pageOrientationSelect.addEventListener('change', updateCanvasLayout);
        numPagesInput.addEventListener('change', () => {
            if (pageSizeSelect.value !== 'Custom') updateCanvasLayout();
        });
        customCanvasWidthInput.addEventListener('input', () => { if(pageSizeSelect.value === 'Custom') updateCanvasLayout(); });
        customCanvasHeightInput.addEventListener('input', () => { if(pageSizeSelect.value === 'Custom') updateCanvasLayout(); });


        updateCanvasLayoutBtn.addEventListener('click', updateCanvasLayout);

        function initCanvas() {
            updateCanvasLayout();
            setTool('select');
        }
        initCanvas();

        // --- Tool Selection ---
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            drawingOptionsDiv.style.display = 'none';
            textOptionsDiv.style.display = 'none';

            if (tool === 'select') {
                selectToolBtn.classList.add('active');
                canvas.style.cursor = 'default';
            } else if (tool === 'draw') {
                drawToolBtn.classList.add('active');
                drawingOptionsDiv.style.display = 'block';
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'text') {
                textToolBtn.classList.add('active');
                textOptionsDiv.style.display = 'block';
                canvas.style.cursor = 'text';
            }
            deselectObject();
        }

        selectToolBtn.addEventListener('click', () => setTool('select'));
        drawToolBtn.addEventListener('click', () => setTool('draw'));
        textToolBtn.addEventListener('click', () => setTool('text'));

        // --- Image Upload ---
        imageUpload.addEventListener('change', (e) => {
            handleImageFiles(e.target.files); // æ¢å¾©åŸæœ¬è¡Œç‚º
            imageUpload.value = '';
        });

        function handleImageFiles(files, pastePos = null) {
             for (const file of files) {
                if (!file.type.startsWith('image/')) continue;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = img.naturalWidth / img.naturalHeight;
                        let defaultWidth = Math.min(img.naturalWidth, canvas.width * 0.25);
                        defaultWidth = Math.max(50, defaultWidth);
                        const defaultHeight = defaultWidth / aspectRatio;

                        let x, y;
                        if (pastePos && pastePos.x !== null && pastePos.y !== null) {
                            x = pastePos.x - defaultWidth / 2;
                            y = pastePos.y - defaultHeight / 2;
                        } else {
                            x = (canvas.width - defaultWidth) / 2 + (canvasObjects.filter(obj => obj.type === 'image').length * 10);
                            y = (canvas.height - defaultHeight) / 2 + (canvasObjects.filter(obj => obj.type === 'image').length * 10);
                        }
                        x = Math.max(0, Math.min(x, canvas.width - defaultWidth));
                        y = Math.max(0, Math.min(y, canvas.height - defaultHeight));

                        canvasObjects.push({
                            type: 'image',
                            id: Date.now() + Math.random(),
                            image: img,
                            src: img.src,
                            x: x, y: y,
                            width: defaultWidth, height: defaultHeight,
                            name: file.name ? file.name.split('.')[0] : ('PastedImage-' + Date.now()),
                            rotation: 0, // Initial rotation
                        });
                        redrawCanvas();
                    }
                    img.onerror = () => {
                        console.error("Error loading image for paste/upload");
                        alert("åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æˆ–ä¾†æºã€‚");
                    }
                    img.src = event.target.result;
                }
                reader.onerror = () => {
                    console.error("FileReader error for image.");
                    alert("è®€å–åœ–ç‰‡æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚");
                }
                reader.readAsDataURL(file);
            }
        }

        // --- Drawing Logic ---
        function drawPath(targetCtx, points, color, width) {
            targetCtx.save();
            targetCtx.beginPath();
            targetCtx.strokeStyle = color;
            targetCtx.lineWidth = width;
            targetCtx.lineCap = 'round';
            targetCtx.lineJoin = 'round';
            points.forEach((p, index) => {
                if (index === 0) targetCtx.moveTo(p.x, p.y);
                else targetCtx.lineTo(p.x, p.y);
            });
            targetCtx.stroke();
            targetCtx.restore();
        }

        function redrawCanvas(targetCtx = ctx, targetCanvas = canvas) {
            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            targetCtx.fillStyle = '#FFFFFF';
            targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);

            if (pageSizeSelect.value !== 'Custom' && singlePagePixelHeight > 0) {
                const numActualPages = Math.ceil(targetCanvas.height / singlePagePixelHeight);
                if (numActualPages > 1) {
                    targetCtx.save();
                    targetCtx.strokeStyle = '#CCCCCC';
                    targetCtx.lineWidth = 1;
                    targetCtx.setLineDash([5, 3]);
                    for (let i = 1; i < numActualPages; i++) {
                        const y = i * singlePagePixelHeight;
                        if (y < targetCanvas.height) {
                            targetCtx.beginPath(); targetCtx.moveTo(0, y); targetCtx.lineTo(targetCanvas.width, y); targetCtx.stroke();
                        }
                    }
                    targetCtx.restore();
                }
            }

            // PDF é è¦½ç·šæ¢ï¼ˆå¯é¸ï¼Œè‹¥ä¸æƒ³è¦å¯ç§»é™¤ï¼‰
            if (exportPdfBtn && pageSizeSelect.value !== 'Custom' && targetCanvas.height > 0) {
                try {
                    const pdfOrientationPrev = pageOrientationSelect.value;
                    const pdfPageTypePrev = pageSizeSelect.value.toLowerCase();
                    const tempPdf = new jsPDF({ orientation: pdfOrientationPrev, unit: 'pt', format: pdfPageTypePrev });
                    const MARGIN_PT_PREV = 0;
                    const contentWidthPtPrev = tempPdf.internal.pageSize.getWidth() - 2 * MARGIN_PT_PREV;
                    const contentHeightPtPrev = tempPdf.internal.pageSize.getHeight() - 2 * MARGIN_PT_PREV;
                    if (targetCanvas.width > 0) {
                        let scaleToFitPdfWidthPrev = contentWidthPtPrev / targetCanvas.width;
                        const pdfPageHeightInCanvasPixels = contentHeightPtPrev / scaleToFitPdfWidthPrev;
                        if (pdfPageHeightInCanvasPixels > 0 && pdfPageHeightInCanvasPixels < targetCanvas.height) {
                            targetCtx.save();
                            targetCtx.strokeStyle = 'rgba(0, 0, 255, 0.6)';
                            targetCtx.lineWidth = 1.5;
                            targetCtx.setLineDash([8, 4]);
                            let numPdfLinesToDraw = Math.floor(targetCanvas.height / pdfPageHeightInCanvasPixels);
                            for (let i = 1; i <= numPdfLinesToDraw; i++) {
                                const y = i * pdfPageHeightInCanvasPixels;
                                if (y < targetCanvas.height) {
                                    targetCtx.beginPath(); targetCtx.moveTo(0, y); targetCtx.lineTo(targetCanvas.width, y); targetCtx.stroke();
                                }
                            }
                            targetCtx.restore();
                        }
                    }
                } catch (e) {
                    console.warn("Could not draw PDF preview lines:", e);
                }
            }

            canvasObjects.forEach(obj => {
                targetCtx.save();
                if (obj.type === 'image') {
                    if (obj.image && obj.image.complete && obj.image.naturalHeight !== 0) {
                        targetCtx.save();
                        targetCtx.translate(obj.x + obj.width / 2, obj.y + obj.height / 2);
                        targetCtx.rotate(obj.rotation || 0);
                        targetCtx.drawImage(obj.image, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
                        targetCtx.restore();
                    } else if (!obj.image) {
                        targetCtx.fillStyle = '#ccc'; targetCtx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        targetCtx.fillStyle = 'black'; targetCtx.textAlign='center'; targetCtx.fillText("Image error", obj.x + obj.width/2, obj.y + obj.height/2);
                    }
                    if (obj.name) {
                        // Ensure text is placed correctly based on explicit rotation angles
                        targetCtx.save();
                        targetCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        targetCtx.font = `12px Arial`;
                        targetCtx.textAlign = 'center';

                        // Calculate the position based on the image's rotation angle
                        const textX = obj.x + obj.width / 2;
                        let textY;
                        if (obj.rotation === 0 || obj.rotation === Math.PI) {
                            // For 0 and 180 degrees
                            textY = obj.y + obj.height + 10;
                            // console.log("OBJX="+obj.x+" OBJY="+obj.y+" OBJW="+obj.width+" OBJH="+obj.height);
                        } else if (obj.rotation === Math.PI / 2 || obj.rotation === 3 * Math.PI / 2) {
                            // For 90 and 270 degrees
                            textY = obj.y + (obj.width+obj.height)/2 + 10;
                            // console.log("OBJX="+obj.x+" OBJY="+obj.y+" OBJW="+obj.width+" OBJH="+obj.height);
                        }

                        targetCtx.fillText(obj.name, textX, textY);
                        targetCtx.restore();
                    }
                } else if (obj.type === 'drawing') {
                    drawPath(targetCtx, obj.points, obj.color, obj.lineWidth);
                } else if (obj.type === 'text') {
                    targetCtx.fillStyle = obj.color; targetCtx.font = `${obj.fontSize}px ${obj.fontFamily}`;
                    targetCtx.textAlign = 'left'; targetCtx.textBaseline = 'top';
                    targetCtx.fillText(obj.text, obj.x, obj.y);
                }
                targetCtx.restore();
            });

            if (selectedObject && currentTool === 'select' && targetCtx === ctx) {
                drawSelectionHandles(selectedObject);
            }
            if (isDrawing && currentPath.length > 0 && targetCtx === ctx) {
                drawPath(targetCtx, currentPath, strokeColorInput.value, lineWidthInput.value);
            }
        }

        function drawSelectionHandles(obj) {
            let x = obj.x, y = obj.y, w = obj.width, h = obj.height;
            ctx.save(); // â˜… å„²å­˜ç•«å¸ƒåˆå§‹ç‹€æ…‹

            if (obj.type === 'image') {
                // === ç¬¬ä¸€éƒ¨åˆ†ï¼šç¹ªè£½éœ€è¦æ—‹è½‰çš„å…§å®¹ ===
                ctx.translate(x + w / 2, y + h / 2);
                ctx.rotate(obj.rotation || 0);
                ctx.translate(-(x + w / 2), -(y + h / 2));
                
                // ç¹ªè£½æ—‹è½‰å¾Œçš„è™›ç·šæ¡†
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 2]);
                ctx.strokeRect(x, y, w, h);
                ctx.setLineDash([]);
                
                // ç¹ªè£½æ—‹è½‰å¾Œçš„ç¸®æ”¾æ§é» (é€™éƒ¨åˆ†ä¹Ÿè·Ÿè‘—è½‰)
                ctx.fillStyle = '#007bff';
                const handles = [{ x: x, y: y }, { x: x + w, y: y }, { x: x, y: y + h }, { x: x + w, y: y + h }];
                handles.forEach(pos => {
                    ctx.fillRect(pos.x - RESIZE_HANDLE_SIZE / 2, pos.y - RESIZE_HANDLE_SIZE / 2, RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE);
                });
                
                // â˜… é—œéµæ”¹è®Šï¼šåœ¨é€™è£¡å°±æ¢å¾©ç•«å¸ƒç‹€æ…‹ï¼Œä¸å†æ—‹è½‰ï¼
                ctx.restore(); 

                // === ç¬¬äºŒéƒ¨åˆ†ï¼šè¨ˆç®—è¦–è¦ºé‚Šç•Œï¼Œä¸¦ç¹ªè£½ä¸æ—‹è½‰çš„æŒ‰éˆ• ===
                
                // è¨ˆç®—åœ–ç‰‡æ—‹è½‰å¾Œçš„å››å€‹é ‚é»çš„å¯¦éš›è¢å¹•åº§æ¨™
                const cx = x + w / 2;
                const cy = y + h / 2;
                const angle = obj.rotation || 0;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                const corners = [
                    {x: x, y: y}, {x: x + w, y: y},
                    {x: x + w, y: y + h}, {x: x, y: y + h}
                ].map(p => ({
                    x: cx + (p.x - cx) * cos - (p.y - cy) * sin,
                    y: cy + (p.x - cx) * sin + (p.y - cy) * cos
                }));

                // æ‰¾åˆ°è¦–è¦ºä¸Šçš„æœ€å¤§å’Œæœ€å° x, y å€¼
                const minX = Math.min(...corners.map(p => p.x));
                const maxX = Math.max(...corners.map(p => p.x));
                const minY = Math.min(...corners.map(p => p.y));
                const maxY = Math.max(...corners.map(p => p.y));

                // â˜… ä½¿ç”¨è¦–è¦ºé‚Šç•Œçš„å³ä¸‹è§’ä¾†å®šä½æŒ‰éˆ•
                const buttonAttachX = maxX + ROTATE_BUTTON_OFFSET;
                const buttonAttachY = maxY + ROTATE_BUTTON_OFFSET;

                // åœ¨ä¸€å€‹ã€Œæ²’æœ‰è¢«æ—‹è½‰ã€çš„ç•«å¸ƒä¸Šç¹ªè£½æŒ‰éˆ•
                // ctx.fillStyle = '#28a745';
                ctx.beginPath();
                // ctx.arc(buttonAttachX + ROTATE_BUTTON_SIZE / 2, buttonAttachY + ROTATE_BUTTON_SIZE / 2, ROTATE_BUTTON_SIZE / 2, 0, Math.PI * 2);
                // ctx.fill();
                ctx.font = `${ROTATE_BUTTON_SIZE - 2}px system-ui,Segoe UI Emoji,Apple Color Emoji,sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText('ğŸ”„ï¸', buttonAttachX + ROTATE_BUTTON_SIZE / 2, buttonAttachY + ROTATE_BUTTON_SIZE / 2 + 1);
                
            } else if (obj.type === 'text' || obj.type === 'drawing') {
                // å…¶ä»–ç‰©ä»¶çš„è™•ç†é‚è¼¯ä¸è®Š...
                // ... (çœç•¥åŸæœ¬çš„ text å’Œ drawing é‚è¼¯)
                if (obj.type === 'text') {
                    ctx.font = `${obj.fontSize}px ${obj.fontFamily}`;
                    const metrics = ctx.measureText(obj.text);
                    w = metrics.width; h = obj.fontSize * 1.2;
                    const padding = 5; x -= padding; y -= padding; w += padding * 2; h += padding * 2;
                    ctx.strokeStyle = '#007bff'; ctx.lineWidth = 1; ctx.setLineDash([4, 2]);
                    ctx.strokeRect(x, y, w, h);
                    ctx.setLineDash([]);
                } else if (obj.type === 'drawing') {
                    if (obj.points && obj.points.length > 0) {
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                        x = minX - obj.lineWidth / 2; y = minY - obj.lineWidth / 2;
                        w = maxX - minX + obj.lineWidth; h = maxY - minY + obj.lineWidth;
                        ctx.strokeStyle = '#007bff'; ctx.lineWidth = 1; ctx.setLineDash([4, 2]);
                        ctx.strokeRect(x, y, w, h);
                        ctx.setLineDash([]);
                    }
                }
                ctx.restore(); // ç¢ºä¿å…¶ä»–ç‰©ä»¶çš„ save() æœ‰å°æ‡‰çš„ restore()
            }
        }

        // å°‡æ–‡å­—ç‰©ä»¶è²¼é½Šé¸å–åœ–ç‰‡çš„å¯¦éš›åº•éƒ¨ä¸­å¿ƒï¼Œoffset æ²¿è‘—åœ–ç‰‡æ³•ç·šæ–¹å‘
        function placeTextAtImageBottom(textObj, imageObj, offset = 10) {
            const cx = imageObj.x + imageObj.width / 2;
            const cy = imageObj.y + imageObj.height / 2;
            const theta = imageObj.rotation || 0;
            // offset æ²¿è‘—åœ–ç‰‡æ—‹è½‰å¾Œçš„æ³•ç·šæ–¹å‘
            textObj.x = cx + (imageObj.height / 2) * Math.sin(theta) + offset * Math.sin(theta);
            textObj.y = cy + (imageObj.height / 2) * Math.cos(theta) + offset * Math.cos(theta);
        }

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            return { x: event.clientX - rect.left, y: event.clientY - rect.top };
        }
        function isPointInRect(px, py, rx, ry, rw, rh) {
            return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
        }

        function getObjectAtPosition(x, y) { // This will select based on un-rotated bounding box
            for (let i = canvasObjects.length - 1; i >= 0; i--) {
                const obj = canvasObjects[i];
                let ox, oy, ow, oh;
                if (obj.type === 'image') {
                    // For selection, use the axis-aligned bounding box of the unrotated image for simplicity
                    ox = obj.x; oy = obj.y; ow = obj.width; oh = obj.height;
                } else if (obj.type === 'text') {
                    ctx.font = `${obj.fontSize}px ${obj.fontFamily}`;
                    const metrics = ctx.measureText(obj.text);
                    const padding = 5; ox = obj.x - padding; oy = obj.y - padding;
                    ow = metrics.width + padding * 2; oh = obj.fontSize * 1.2 + padding * 2;
                } else if (obj.type === 'drawing' && obj.points && obj.points.length > 0) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                    const pathBuffer = obj.lineWidth / 2 + 5;
                    ox = minX - pathBuffer; oy = minY - pathBuffer;
                    ow = (maxX - minX) + pathBuffer * 2; oh = (maxY - minY) + pathBuffer * 2;
                } else { continue; }

                // If image is rotated, point-in-rect test needs to account for rotation
                if (obj.type === 'image' && obj.rotation) {
                    const cx = ox + ow / 2;
                    const cy = oy + oh / 2;
                    const angle = -(obj.rotation || 0); // Inverse rotation for mouse point

                    const localMouseX = cx + (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle);
                    const localMouseY = cy + (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle);
                    if (isPointInRect(localMouseX, localMouseY, ox, oy, ow, oh)) return obj;

                } else {
                     if (isPointInRect(x, y, ox, oy, ow, oh)) { return obj; }
                }
            }
            return null;
        }

        function getResizeHandles(obj) { // Returns handles for the un-rotated bounding box
             if (obj.type !== 'image') return {};
            return {
                topLeft: { x: obj.x, y: obj.y }, topRight: { x: obj.x + obj.width, y: obj.y },
                bottomLeft: { x: obj.x, y: obj.y + obj.height }, bottomRight: { x: obj.x + obj.width, y: obj.y + obj.height },
            };
        }

        function getResizeHandleAtPosition(obj, mouseX, mouseY) { // Mouse coords are canvas coords
            if (obj.type !== 'image') return null;
            // Resize handles are on the un-rotated bounding box.
            // Transform mouse point to be relative to un-rotated box if image is rotated.
            let mX = mouseX;
            let mY = mouseY;

            if (obj.rotation) {
                const cx = obj.x + obj.width / 2;
                const cy = obj.y + obj.height / 2;
                const angle = -(obj.rotation); // inverse rotation

                mX = cx + (mouseX - cx) * Math.cos(angle) - (mouseY - cy) * Math.sin(angle);
                mY = cy + (mouseX - cx) * Math.sin(angle) + (mouseY - cy) * Math.cos(angle);
            }

            const handles = getResizeHandles(obj);
            for (const name in handles) {
                const pos = handles[name];
                // Check against transformed mouse point mX, mY
                if (isPointInRect(mX, mY, pos.x - RESIZE_HANDLE_SIZE, pos.y - RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE * 2, RESIZE_HANDLE_SIZE * 2)) {
                    return name;
                }
            }
            return null;
        }

        function getRotateButtonAtPosition(obj, mouseX, mouseY) {
            if (!obj || obj.type !== 'image') return null;

            // â˜… å†æ¬¡è¨ˆç®—å‡ºè¦–è¦ºé‚Šç•Œï¼Œå’Œç¹ªè£½æ™‚çš„é‚è¼¯å®Œå…¨ä¸€æ¨£
            const cx = obj.x + obj.width / 2;
            const cy = obj.y + obj.height / 2;
            const angle = obj.rotation || 0;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const corners = [
                {x: obj.x, y: obj.y}, {x: obj.x + obj.width, y: obj.y},
                {x: obj.x + obj.width, y: obj.y + obj.height}, {x: obj.x, y: obj.y + obj.height}
            ].map(p => ({
                x: cx + (p.x - cx) * cos - (p.y - cy) * sin,
                y: cy + (p.x - cx) * sin + (p.y - cy) * cos
            }));

            const maxX = Math.max(...corners.map(p => p.x));
            const maxY = Math.max(...corners.map(p => p.y));

            // â˜… è¨ˆç®—æŒ‰éˆ•åœ¨è¢å¹•ä¸Šçš„å¯¦éš›çŸ©å½¢å€åŸŸ
            const buttonRectX = maxX + ROTATE_BUTTON_OFFSET;
            const buttonRectY = maxY + ROTATE_BUTTON_OFFSET;

            // â˜… ç›´æ¥ç”¨æ»‘é¼ åº§æ¨™é€²è¡Œç°¡å–®çš„çŸ©å½¢ç¢°æ’åµæ¸¬ï¼Œä¸å†éœ€è¦æ—‹è½‰
            if (isPointInRect(mouseX, mouseY, buttonRectX, buttonRectY, ROTATE_BUTTON_SIZE, ROTATE_BUTTON_SIZE)) {
                return 'rotate';
            }
            return null;
        }

        function deselectObject() { selectedObject = null; selectedObjectControlsDiv.style.display = 'none'; redrawCanvas(); }
        function selectObject(obj) {
            selectedObject = obj;
            selectedObjectControlsDiv.style.display = 'block';
            objectNameInput.value = obj.name || '';
            // æ ¹æ“šç‰©ä»¶å‹æ…‹é¡¯ç¤º/éš±è—æ–‡å­—ç·¨è¼¯æ¬„ä½
            if (obj.type === 'text') {
                textEditFields.style.display = '';
                document.getElementById('objectNameRow').style.display = 'none';
                editTextContent.value = obj.text || '';
                editTextColor.value = obj.color || '#000000';
                editFontSize.value = obj.fontSize || 20;
                editFontFamily.value = obj.fontFamily || 'Arial';
            } else {
                textEditFields.style.display = 'none';
                document.getElementById('objectNameRow').style.display = '';
            }
            redrawCanvas(); 
        }

        // ç¶å®šæ–‡å­—å±¬æ€§ç·¨è¼¯äº‹ä»¶
        editTextContent.addEventListener('input', function() {
            if (selectedObject && selectedObject.type === 'text') {
                selectedObject.text = this.value;
                redrawCanvas();
            }
        });
        editTextColor.addEventListener('input', function() {
            if (selectedObject && selectedObject.type === 'text') {
                selectedObject.color = this.value;
                redrawCanvas();
            }
        });
        editFontSize.addEventListener('input', function() {
            if (selectedObject && selectedObject.type === 'text') {
                selectedObject.fontSize = parseInt(this.value) || 20;
                redrawCanvas();
            }
        });
        editFontFamily.addEventListener('change', function() {
            if (selectedObject && selectedObject.type === 'text') {
                selectedObject.fontFamily = this.value;
                redrawCanvas();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(e);
            if (currentTool === 'select') {
                isResizing = false; resizeHandle = null;

                if (selectedObject && selectedObject.type === 'image') {
                    const clickedRotateButton = getRotateButtonAtPosition(selectedObject, mousePos.x, mousePos.y);
                    if (clickedRotateButton === 'rotate') {
                        selectedObject.rotation = (selectedObject.rotation || 0) + Math.PI / 2;
                        if (selectedObject.rotation >= Math.PI * 2) {
                            selectedObject.rotation -= Math.PI * 2;
                        }
                        redrawCanvas();
                        return;
                    }
                }

                if (selectedObject && selectedObject.type === 'image') {
                    resizeHandle = getResizeHandleAtPosition(selectedObject, mousePos.x, mousePos.y);
                    if (resizeHandle) { isResizing = true; canvas.style.cursor = getResizeCursor(resizeHandle); return; }
                }

                const clickedObject = getObjectAtPosition(mousePos.x, mousePos.y);
                if (clickedObject) {
                    if (selectedObject !== clickedObject) { // Only re-select if different object
                        selectObject(clickedObject);
                    }
                    isDragging = true; // Always allow dragging if an object is clicked
                    dragOffsetX = mousePos.x - clickedObject.x; // Use clickedObject here
                    dragOffsetY = mousePos.y - clickedObject.y;
                    canvas.style.cursor = 'grabbing';
                } else {
                    deselectObject();
                }
            } else if (currentTool === 'draw') { isDrawing = true; currentPath = [{ x: mousePos.x, y: mousePos.y }]; }
            else if (currentTool === 'text') {
                const text = prompt("è«‹è¼¸å…¥æ–‡å­—:", "åœ¨æ­¤è¼¸å…¥");
                if (text) {
                    let textObj = { type: 'text', id: Date.now() + Math.random(), text: text, x: mousePos.x, y: mousePos.y, color: textColorInput.value, fontSize: parseInt(fontSizeInput.value), fontFamily: fontFamilySelect.value, name: 'Text-' + (canvasObjects.filter(o=>o.type==='text').length + 1) };
                    // å¦‚æœæœ‰é¸å–åœ–ç‰‡ï¼Œé è¨­è²¼é½Šåº•éƒ¨
                    if (selectedObject && selectedObject.type === 'image') {
                        placeTextAtImageBottom(textObj, selectedObject, 10);
                    }
                    canvasObjects.push(textObj);
                    redrawCanvas(); setTool('select');
                }
            }
        });

        let lastMouseMoveTime = 0; const mouseMoveThrottle = 16;

        canvas.addEventListener('mousemove', (e) => {
            const currentTime = performance.now();
            if (currentTime - lastMouseMoveTime < mouseMoveThrottle && (isDragging || isResizing || isDrawing)) { /* Throttling */ }
            lastMouseMoveTime = currentTime;
            const mousePos = getMousePos(e);
            lastCanvasMouseX = mousePos.x;
            lastCanvasMouseY = mousePos.y;

            if (currentTool === 'select') {
                if (isResizing && selectedObject && selectedObject.type === 'image') {
                    const obj = selectedObject;
                    // Store original center
                    const origCenterX = obj.x + obj.width / 2;
                    const origCenterY = obj.y + obj.height / 2;

                    let newX = obj.x, newY = obj.y, newWidth = obj.width, newHeight = obj.height;
                    const prevWidth = obj.width; const prevHeight = obj.height;

                    // Transform mouse to unrotated image space for consistent resize logic
                    let mX = mousePos.x;
                    let mY = mousePos.y;
                    if (obj.rotation) {
                        const angle = -(obj.rotation);
                        mX = origCenterX + (mousePos.x - origCenterX) * Math.cos(angle) - (mousePos.y - origCenterY) * Math.sin(angle);
                        mY = origCenterY + (mousePos.x - origCenterX) * Math.sin(angle) + (mousePos.y - origCenterY) * Math.cos(angle);
                    }


                    const aspectRatio = (obj.image && obj.image.naturalWidth > 0 && obj.image.naturalHeight > 0)
                                        ? (obj.image.naturalWidth / obj.image.naturalHeight)
                                        : (prevWidth / prevHeight);

                    // Resize logic based on mX, mY in unrotated space
                    switch (resizeHandle) { // resizeHandle refers to corners of the unrotated box
                        case 'topLeft':
                            newWidth = (obj.x + prevWidth) - mX;
                            newHeight = newWidth / aspectRatio;
                            newX = (obj.x + prevWidth) - newWidth;
                            newY = (obj.y + prevHeight) - newHeight;
                            break;
                        case 'topRight':
                            newWidth = mX - obj.x;
                            newHeight = newWidth / aspectRatio;
                            // newX remains obj.x
                            newY = (obj.y + prevHeight) - newHeight;
                            break;
                        case 'bottomLeft':
                            newWidth = (obj.x + prevWidth) - mX;
                            newHeight = newWidth / aspectRatio;
                            newX = (obj.x + prevWidth) - newWidth;
                            // newY remains obj.y
                            break;
                        case 'bottomRight':
                            newWidth = mX - obj.x;
                            newHeight = newWidth / aspectRatio;
                            // newX, newY remain obj.x, obj.y
                            break;
                    }

                    const minSize = 20;
                    if (newWidth >= minSize && newHeight >= minSize) {
                        // Calculate new center based on unrotated newX, newY, newWidth, newHeight
                        const newUnrotatedCenterX = newX + newWidth / 2;
                        const newUnrotatedCenterY = newY + newHeight / 2;

                        // Apply rotation to the difference from original center to find new top-left for drawing
                        if (obj.rotation) {
                            const dx = newUnrotatedCenterX - origCenterX;
                            const dy = newUnrotatedCenterY - origCenterY;
                            const angle = obj.rotation;

                            const rotatedDx = dx * Math.cos(angle) - dy * Math.sin(angle);
                            const rotatedDy = dx * Math.sin(angle) + dy * Math.cos(angle);

                            obj.x = origCenterX + rotatedDx - newWidth / 2;
                            obj.y = origCenterY + rotatedDy - newHeight / 2;
                        } else {
                             obj.x = newX;
                             obj.y = newY;
                        }
                        obj.width = newWidth;
                        obj.height = newHeight;
                    }
                    redrawCanvas();
                } else if (isDragging && selectedObject) {
                    selectedObject.x = mousePos.x - dragOffsetX;
                    selectedObject.y = mousePos.y - dragOffsetY;
                    clearAlignmentGuides();
                    // Alignment guides for rotated objects are complex, disable for now or simplify
                    // if (selectedObject.type === 'image' || selectedObject.type === 'text') {
                    //     if (performance.now() % 3 === 0) { showAlignmentGuides(selectedObject); }
                    // }
                    redrawCanvas();
                } else {
                    let onHandle = false;
                    let onRotateButton = false;
                    if (selectedObject && selectedObject.type === 'image') {
                        const rotateButton = getRotateButtonAtPosition(selectedObject, mousePos.x, mousePos.y);
                        if (rotateButton) {
                            canvas.style.cursor = 'pointer';
                            onRotateButton = true;
                        } else {
                            const handle = getResizeHandleAtPosition(selectedObject, mousePos.x, mousePos.y);
                            if (handle) { canvas.style.cursor = getResizeCursor(handle); onHandle = true; }
                        }
                    }
                    if (!onHandle && !onRotateButton) {
                        const hoverObject = getObjectAtPosition(mousePos.x, mousePos.y);
                        canvas.style.cursor = hoverObject ? 'grab' : (currentTool === 'draw' ? 'crosshair' : (currentTool === 'text' ? 'text' : 'default'));
                    }
                }
            } else if (currentTool === 'draw' && isDrawing) { currentPath.push({ x: mousePos.x, y: mousePos.y }); redrawCanvas(); }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (currentTool === 'select') {
                if (isDragging && selectedObject) {
                    // snapToAlignmentGuides(selectedObject); // Complex for rotated objects
                    clearAlignmentGuides();
                 }
                isDragging = false; isResizing = false; resizeHandle = null;
                // Set cursor based on whether an object (and potentially a handle/button) is under mouse
                const mousePos = getMousePos(e);
                if (selectedObject && selectedObject.type === 'image') {
                    if (getRotateButtonAtPosition(selectedObject, mousePos.x, mousePos.y)) {
                        canvas.style.cursor = 'pointer';
                    } else if (getResizeHandleAtPosition(selectedObject, mousePos.x, mousePos.y)) {
                        // Cursor already set by mousemove
                    } else if (getObjectAtPosition(mousePos.x, mousePos.y) === selectedObject) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                } else if (selectedObject && getObjectAtPosition(mousePos.x, mousePos.y) === selectedObject) {
                    canvas.style.cursor = 'grab';
                }
                 else {
                    canvas.style.cursor = 'default';
                }

            } else if (currentTool === 'draw' && isDrawing) {
                isDrawing = false;
                if (currentPath.length > 1) { canvasObjects.push({ type: 'drawing', id: Date.now()+Math.random(), points: [...currentPath], color: strokeColorInput.value, lineWidth: parseInt(lineWidthInput.value), name: 'Drawing-' + Date.now() }); }
                currentPath = [];
            }
            redrawCanvas();
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDragging || isResizing) { isDragging = false; isResizing = false; clearAlignmentGuides(); redrawCanvas(); }
            if (isDrawing) { isDrawing = false; if(currentPath.length > 1) canvasObjects.push({ type: 'drawing', id: Date.now()+Math.random(), points: [...currentPath], color: strokeColorInput.value, lineWidth: parseInt(lineWidthInput.value), name: 'Drawing-' + Date.now() }); currentPath = []; redrawCanvas(); }
        });

        canvas.addEventListener('mouseenter', (e) => {
             const mousePos = getMousePos(e);
             lastCanvasMouseX = mousePos.x;
             lastCanvasMouseY = mousePos.y;
        });


        function getResizeCursor(handleName) {
            switch (handleName) {
                case 'topLeft': case 'bottomRight': return 'nwse-resize';
                case 'topRight': case 'bottomLeft': return 'nesw-resize';
                default: return 'default';
            }
        }

        objectNameInput.addEventListener('input', (e) => { if (selectedObject) { selectedObject.name = e.target.value; redrawCanvas(); } });
        deleteSelectedBtn.addEventListener('click', () => { if (selectedObject) { canvasObjects = canvasObjects.filter(obj => obj.id !== selectedObject.id); deselectObject(); } });
        bringToFrontBtn.addEventListener('click', () => { if (selectedObject) { const index = canvasObjects.findIndex(obj => obj.id === selectedObject.id); if (index > -1 && index < canvasObjects.length - 1) { const item = canvasObjects.splice(index, 1)[0]; canvasObjects.push(item); redrawCanvas(); } } });
        sendToBackBtn.addEventListener('click', () => { if (selectedObject) { const index = canvasObjects.findIndex(obj => obj.id === selectedObject.id); if (index > 0) { const item = canvasObjects.splice(index, 1)[0]; canvasObjects.unshift(item); redrawCanvas(); } } });
        clearAnnotationsBtn.addEventListener('click', () => { if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¨™è¨» (ç¹ªç•«å’Œæ–‡å­—) å—ï¼Ÿåœ–ç‰‡å°‡ä¿ç•™ã€‚')) { canvasObjects = canvasObjects.filter(obj => obj.type === 'image'); deselectObject(); redrawCanvas(); } });

        const canvasContainerElement = document.getElementById('canvasContainer');
        function clearAlignmentGuides() { const existingGuides = canvasContainerElement.querySelectorAll('.guideline'); existingGuides.forEach(guide => guide.remove()); }
        function getObjectBounds(obj) { // This returns un-rotated bounds
            let x = obj.x, y = obj.y, width = obj.width, height = obj.height;
            if (obj.type === 'text') { ctx.font = `${obj.fontSize}px ${obj.fontFamily}`; const metrics = ctx.measureText(obj.text); width = metrics.width; height = obj.fontSize * 1.2; }
            else if (obj.type === 'drawing') { if (!obj.points || obj.points.length === 0) return { left:0, right:0, top:0, bottom:0, centerX:0, centerY:0, width:0, height:0}; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; obj.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); x = minX; y = minY; width = maxX - minX; height = maxY - minY; }
            return { left: x, right: x + width, top: y, bottom: y + height, centerX: x + width / 2, centerY: y + height / 2, width: width, height: height };
        }
        function checkAndDrawGuide(pos1, pos2, orientation, container) {
            if (Math.abs(pos1 - pos2) < ALIGNMENT_THRESHOLD) { const guide = document.createElement('div'); guide.classList.add('guideline', orientation); if (orientation === 'horizontal') { guide.style.top = `${pos2}px`; } else { guide.style.left = `${pos2}px`; } container.appendChild(guide); return true; } return false;
        }
        function showAlignmentGuides(movingObj) { // Note: Guides are for un-rotated bounding boxes
            clearAlignmentGuides(); if (!movingObj || movingObj.rotation) return; // Disable for rotated for now
            const objBounds = getObjectBounds(movingObj);
            canvasObjects.forEach(staticObj => { if (staticObj.id === movingObj.id || staticObj.rotation) return; // Don't align with other rotated objects
                const staticBounds = getObjectBounds(staticObj);
                checkAndDrawGuide(objBounds.centerY, staticBounds.centerY, 'horizontal', canvasContainerElement); checkAndDrawGuide(objBounds.top, staticBounds.top, 'horizontal', canvasContainerElement); checkAndDrawGuide(objBounds.bottom, staticBounds.bottom, 'horizontal', canvasContainerElement);
                checkAndDrawGuide(objBounds.centerX, staticBounds.centerX, 'vertical', canvasContainerElement); checkAndDrawGuide(objBounds.left, staticBounds.left, 'vertical', canvasContainerElement); checkAndDrawGuide(objBounds.right, staticBounds.right, 'vertical', canvasContainerElement);
            });
        }
        function snapToAlignmentGuides(movingObj) { // Note: Snapping is for un-rotated bounding boxes
            if (!movingObj || movingObj.rotation) return; // Disable for rotated
            let snappedX = false, snappedY = false; const objBounds = getObjectBounds(movingObj);
            canvasObjects.forEach(staticObj => { if (staticObj.id === movingObj.id || staticObj.rotation) return; const staticBounds = getObjectBounds(staticObj);
                if (Math.abs(objBounds.left - staticBounds.left) < ALIGNMENT_THRESHOLD) { movingObj.x = staticBounds.left; snappedX = true; } else if (Math.abs(objBounds.right - staticBounds.right) < ALIGNMENT_THRESHOLD) { movingObj.x = staticBounds.right - objBounds.width; snappedX = true; } else if (Math.abs(objBounds.centerX - staticBounds.centerX) < ALIGNMENT_THRESHOLD) { movingObj.x = staticBounds.centerX - objBounds.width / 2; snappedX = true; }
                if (Math.abs(objBounds.top - staticBounds.top) < ALIGNMENT_THRESHOLD) { movingObj.y = staticBounds.top; snappedY = true; } else if (Math.abs(objBounds.bottom - staticBounds.bottom) < ALIGNMENT_THRESHOLD) { movingObj.y = staticBounds.bottom - objBounds.height; snappedY = true; } else if (Math.abs(objBounds.centerY - staticBounds.centerY) < ALIGNMENT_THRESHOLD) { movingObj.y = staticBounds.centerY - objBounds.height / 2; snappedY = true; }
            });
            if (snappedX || snappedY) redrawCanvas();
        }

        function getPastePosition(){
            return {
                x: lastCanvasMouseX !== null ? lastCanvasMouseX : canvas.width / 2,
                y: lastCanvasMouseY !== null ? lastCanvasMouseY : canvas.height / 2
            };
        }

        // æ”¯æ´ Ctrl+V/å³éµè²¼ä¸Šåœ–ç‰‡ï¼ˆClipboard APIï¼‰
        document.addEventListener('paste', async (event) => {
            const activeElement = document.activeElement;
            if (
                activeElement &&
                (activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable)
            ) {
                return;
            }
            let inControlPanelInput = false;
            if (activeElement && activeElement.closest && activeElement.closest('.controls')) {
                if (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeElement.tagName)) {
                    inControlPanelInput = true;
                }
            }
            if (inControlPanelInput) return;

            // å…ˆè™•ç† clipboardDataï¼ˆèˆŠç€è¦½å™¨æˆ–ç€è¦½å™¨è‡ªå¸¶çš„è²¼åœ–ï¼‰
            const items = (event.clipboardData || event.originalEvent?.clipboardData)?.items;
            if (items) {
                let filesToHandle = [];
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file' && item.type.startsWith('image/')) {
                        filesToHandle.push(item.getAsFile());
                    }
                }
                if (filesToHandle.length > 0) {
                    event.preventDefault();
                    handleImageFiles(filesToHandle, getPastePosition());
                    return;
                }
            }

            // è‹¥æ”¯æ´ Clipboard APIï¼Œå˜—è©¦è®€å–åœ–ç‰‡
            if (navigator.clipboard && navigator.clipboard.read) {
                try {
                    const clipboardItems = await navigator.clipboard.read();
                    for (const clipboardItem of clipboardItems) {
                        for (const type of clipboardItem.types) {
                            if (type.startsWith('image/')) {
                                const blob = await clipboardItem.getType(type);
                                const file = new File([blob], 'ClipboardImage.png', { type: blob.type });
                                handleImageFiles([file], getPastePosition());
                                event.preventDefault();
                                return;
                            }
                        }
                    }
                } catch (err) {
                    // Clipboard API å¯èƒ½è¢«æ‹’çµ•æ¬Šé™ï¼Œå¿½ç•¥å³å¯
                }
            }
        });

        // --- Toast å…±ç”¨å‡½å¼ ---
        function showToast(message) {
            const toast = document.getElementById('copiedToast');
            if (toast) {
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 1200);
            }
        }

        exportProjectBtn.addEventListener('click', () => {
            const projectData = {
                canvasSettings: {
                    pageSize: pageSizeSelect.value,
                    orientation: pageOrientationSelect.value,
                    numPages: parseInt(numPagesInput.value),
                    customWidth: customCanvasWidthInput.value,
                    customHeight: customCanvasHeightInput.value,
                },
                objects: canvasObjects.map(obj => {
                    if (obj.type === 'image') {
                        // Make sure to include rotation
                        return { ...obj, imageSrc: obj.src, rotation: obj.rotation || 0 };
                    }
                    return obj;
                })
            };
            projectData.objects.forEach(obj => { if(obj.type === 'image') delete obj.image; }); // Remove actual image object for JSON
            const jsonString = JSON.stringify(projectData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'canvas_project.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showToast('å°ˆæ¡ˆå·²åŒ¯å‡º!');
        });

        importProjectInput.addEventListener('change', (event) => {
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = (e_reader) => {
                try {
                    const projectData = JSON.parse(e_reader.target.result);
                    pageSizeSelect.value = projectData.canvasSettings.pageSize || 'A4'; pageOrientationSelect.value = projectData.canvasSettings.orientation || 'portrait'; numPagesInput.value = projectData.canvasSettings.numPages || 1; customCanvasWidthInput.value = projectData.canvasSettings.customWidth || 800; customCanvasHeightInput.value = projectData.canvasSettings.customHeight || 1000;
                    customSizeInputsDiv.style.display = pageSizeSelect.value === 'Custom' ? 'block' : 'none'; numPagesInput.disabled = pageSizeSelect.value === 'Custom';
                    updateCanvasLayout();

                    const loadedObjects = []; const imageLoadPromises = [];
                    (projectData.objects || []).forEach(objData => {
                        if (objData.type === 'image' && objData.imageSrc) {
                            const img = new Image();
                            const promise = new Promise((resolve, reject) => {
                                img.onload = () => {
                                    loadedObjects.push({
                                        ...objData,
                                        image: img,
                                        src: img.src,
                                        rotation: objData.rotation || 0 // Ensure rotation is loaded
                                    });
                                    resolve();
                                };
                                img.onerror = () => { console.warn(`Failed to load image: ${objData.name || 'Unknown'}. Skipping.`); resolve(); };
                                img.src = objData.imageSrc;
                            });
                            imageLoadPromises.push(promise);
                        } else { loadedObjects.push(objData); }
                    });

                    Promise.all(imageLoadPromises).then(() => { canvasObjects = loadedObjects; deselectObject(); redrawCanvas(); alert('å°ˆæ¡ˆå·²æˆåŠŸåŒ¯å…¥!'); }).catch(err => { console.error("Error loading images:", err); alert('åŒ¯å…¥å°ˆæ¡ˆæ™‚éƒ¨åˆ†åœ–ç‰‡è¼‰å…¥å¤±æ•—ã€‚'); canvasObjects = loadedObjects.filter(obj => (obj.type === 'image' && obj.image && obj.image.complete && obj.image.naturalHeight !== 0) || obj.type !== 'image'); deselectObject(); redrawCanvas(); });
                } catch (error) { console.error("Import error:", error); alert('åŒ¯å…¥å°ˆæ¡ˆå¤±æ•—: æª”æ¡ˆæ ¼å¼éŒ¯èª¤æˆ–å…§å®¹ææ¯€ã€‚');}
                finally { importProjectInput.value = ''; }
            };
            reader.readAsText(file);
        });

        exportPdfBtn.addEventListener('click', () => {
            const currentCanvasWidth = canvas.width; const currentCanvasHeight = canvas.height; const tempSelected = selectedObject; deselectObject();
            redrawCanvas();
            const resolutionScaleFactor = 2;
            const pdfOrientation = pageOrientationSelect.value;
            const pdfPageType = (pageSizeSelect.value === 'Custom' ? 'a4' : pageSizeSelect.value.toLowerCase());
            const pdf = new jsPDF({ orientation: pdfOrientation, unit: 'pt', format: pdfPageType });
            const MARGIN_PT = 0;
            const contentWidthPt = pdf.internal.pageSize.getWidth() - 2 * MARGIN_PT;
            const contentHeightPt = pdf.internal.pageSize.getHeight() - 2 * MARGIN_PT;
            let scaleToFitPdfWidth = contentWidthPt / currentCanvasWidth;
            const tempRenderCanvas = document.createElement('canvas');
            tempRenderCanvas.width = currentCanvasWidth * resolutionScaleFactor;
            tempRenderCanvas.height = currentCanvasHeight * resolutionScaleFactor;
            const tempRenderCtx = tempRenderCanvas.getContext('2d');
            tempRenderCtx.scale(resolutionScaleFactor, resolutionScaleFactor);
            tempRenderCtx.fillStyle = '#FFFFFF';
            tempRenderCtx.fillRect(0, 0, currentCanvasWidth, currentCanvasHeight);

            canvasObjects.forEach(obj => {
                tempRenderCtx.save();
                if (obj.type === 'image') {
                    if (obj.image && obj.image.complete && obj.image.naturalHeight !==0) {
                        tempRenderCtx.save();
                        tempRenderCtx.translate(obj.x + obj.width / 2, obj.y + obj.height / 2);
                        tempRenderCtx.rotate(obj.rotation || 0);
                        tempRenderCtx.drawImage(obj.image, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
                        tempRenderCtx.restore();
                    }
                    if (obj.name) {
                        // åªè¨ˆç®—æ—‹è½‰å¾Œåœ–ç‰‡çš„ä¸‹æ–¹ä¸­å¿ƒé»ï¼Œæ–‡å­—ä¸æ—‹è½‰
                        tempRenderCtx.save();
                        tempRenderCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        tempRenderCtx.font = `12px Arial`;
                        tempRenderCtx.textAlign = 'center';
                        // Calculate the position based on the image's rotation angle
                        const textX = obj.x + obj.width / 2;
                        let textY;
                        if (obj.rotation === 0 || obj.rotation === Math.PI) {
                            // For 0 and 180 degrees
                            textY = obj.y + obj.height + 10;
                            // console.log("OBJX="+obj.x+" OBJY="+obj.y+" OBJW="+obj.width+" OBJH="+obj.height);
                        } else if (obj.rotation === Math.PI / 2 || obj.rotation === 3 * Math.PI / 2) {
                            // For 90 and 270 degrees
                            textY = obj.y + (obj.width+obj.height)/2 + 10;
                            // console.log("OBJX="+obj.x+" OBJY="+obj.y+" OBJW="+obj.width+" OBJH="+obj.height);
                        }
                        tempRenderCtx.fillText(obj.name, textX, textY);
                        tempRenderCtx.restore();
                    }
                } else if (obj.type === 'drawing') {
                    drawPath(tempRenderCtx, obj.points, obj.color, obj.lineWidth);
                } else if (obj.type === 'text') {
                    tempRenderCtx.fillStyle = obj.color;
                    tempRenderCtx.font = `${obj.fontSize}px ${obj.fontFamily}`;
                    tempRenderCtx.textAlign = 'center';
                    tempRenderCtx.textBaseline = 'top';
                    tempRenderCtx.fillText(obj.text, obj.x, obj.y);
                }
                tempRenderCtx.restore();
            });

            const imgData = tempRenderCanvas.toDataURL('image/png');
            const scaledCanvasWidthOnPdf = currentCanvasWidth * scaleToFitPdfWidth;
            const scaledCanvasHeightOnPdf = currentCanvasHeight * scaleToFitPdfWidth;
            const numPagesInputValue = parseInt(numPagesInput.value) || 1; // é è¨ˆé æ•¸
            const numPdfPages = Math.min(Math.ceil(scaledCanvasHeightOnPdf / contentHeightPt), numPagesInputValue); // é™åˆ¶é æ•¸

            for (let i = 0; i < numPdfPages; i++) {
                if (i > 0) { pdf.addPage(pdfPageType, pdfOrientation); }
                pdf.addImage(imgData, 'PNG', MARGIN_PT, MARGIN_PT - (i * contentHeightPt), scaledCanvasWidthOnPdf, scaledCanvasHeightOnPdf);
            }
            pdf.save('canvas_export_hires_no_margin.pdf');
            if (tempSelected) selectObject(tempSelected);
            redrawCanvas();
            showToast('å·²ä¸‹è¼‰ï¼');
        });

        if (copyHiResBtn) {
            copyHiResBtn.addEventListener('click', async () => {
                const scale = 2;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width * scale;
                tempCanvas.height = canvas.height * scale;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.scale(scale, scale);
                // å–æ¶ˆé¸å–ç‰©ä»¶å†é‡ç¹ªï¼Œé¿å…é¸æ¡†å‡ºç¾
                const tempSelected = selectedObject;
                deselectObject();
                if (typeof redrawCanvas === 'function') {
                    redrawCanvas(tempCtx, tempCanvas);
                }
                if (tempSelected) selectedObject = tempSelected;
                tempCanvas.toBlob(async (blob) => {
                    if (!blob) { alert('æˆªåœ–å¤±æ•—'); return; }
                    try {
                        await navigator.clipboard.write([
                            new window.ClipboardItem({ 'image/png': blob })
                        ]);
                        // é¡¯ç¤ºæµ®å‹•æç¤º
                        const toast = document.getElementById('copiedToast');
                        if (toast) {
                            toast.classList.add('show');
                            setTimeout(() => toast.classList.remove('show'), 1200);
                        }
                    } catch (e) {
                        alert('ç„¡æ³•å¯«å…¥å‰ªè²¼ç°¿ï¼Œè«‹ç¢ºèªç€è¦½å™¨æ”¯æ´ä¸”æœ‰æ¬Šé™ã€‚');
                    }
                }, 'image/png');
            });
        }

        document.addEventListener('keydown', (e) => {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'SELECT' || activeEl.isContentEditable)) { if (e.key === 'Escape') activeEl.blur(); return; }
            let consumed = false;
            switch(e.key.toUpperCase()) {
                case 'V': setTool('select'); consumed=true; break;
                case 'B': setTool('draw'); consumed=true; break;
                case 'T': setTool('text'); consumed=true; break;
                case 'DELETE': case 'BACKSPACE': if (selectedObject) { deleteSelectedBtn.click(); consumed=true; } break;
            }
            if (consumed) e.preventDefault();
        });

        // åˆ†é åˆ‡æ›é‚è¼¯ï¼ˆåªè¨»å†Šä¸€æ¬¡ï¼Œä¸¦ç¢ºä¿åˆå§‹ç‹€æ…‹æ­£ç¢ºï¼‰
(function() {
    function showTab(tabName) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
        document.getElementById(`${tabName}-content`).classList.add('active');
    }
    // é è¨­é¡¯ç¤º tools åˆ†é 
    showTab('tools');
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', function() {
            showTab(tab.dataset.tab);
        });
    });
})();

        const importProjectBtn = document.getElementById('importProjectBtn');
        importProjectBtn.addEventListener('click', function() {
            importProjectInput.click();
        });

        const imageUploadBtn = document.getElementById('imageUploadBtn');
        imageUploadBtn.addEventListener('click', function() {
            imageUpload.click();
        });
    </script>
</body>
</html>
