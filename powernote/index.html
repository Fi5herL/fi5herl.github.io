<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PowerNote Pro - 筆記、任務與時間追蹤</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>✒️</text></svg>">

    <!-- Libraries -->
    <link rel="stylesheet" href="lib/codemirror/codemirror.min.css">
    <link rel="stylesheet" href="lib/codemirror/theme/monokai.min.css">
    <link rel="stylesheet" href="lib/codemirror/theme/solarized.min.css">
    <link rel="stylesheet" href="lib/codemirror/theme/material.min.css">
    <link rel="stylesheet" href="lib/codemirror/theme/dracula.min.css">
    <link rel="stylesheet" href="lib/codemirror/theme/github.min.css">
    <link rel="stylesheet" href="lib/codemirror/addon/fold/foldgutter.min.css">
    <link rel="stylesheet" href="lib/highlight.js/styles/default.min.css">
    <link rel="stylesheet" href="lib/highlight.js/styles/github.min.css">
    <link rel="stylesheet" href="lib/highlight.js/styles/vs2015.min.css">
    <link rel="stylesheet" href="lib/highlight.js/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="lib/font-awesome/all.min.css">
    
    <!-- KaTeX for math formulas -->
    <link rel="stylesheet" href="lib/katex/katex.min.css">

    <style>
        :root {
            --primary-bg: #f8f9fa;
            --secondary-bg: #ffffff;
            --border-color: #dee2e6;
            --text-color: #212529;
            --header-bg: #e9ecef;
            --accent-color: #007bff;
            --button-bg: #6c757d;
            --button-hover-bg: #5a6268;
            --sidebar-width: 280px;
            --task-panel-width: 380px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
        

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }
        
        .sidebar-toggle {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100%;
            transition: margin-left 0.3s;
        }

        /* File Panel Styles */
        .file-panel {
            width: 300px;
            flex-shrink: 0;
            background: var(--secondary-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: width 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
            order: -1; /* 確保在左側 */
        }
        .file-panel.collapsed {
            width: 0;
            opacity: 0;
            border: none;
        }
        .file-panel-header {
            background: var(--header-bg);
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        .sidebar-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .sidebar-controls button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s ease;
        }
        .sidebar-controls button:hover {
            background: var(--button-hover-bg);
        }

        /* Dropdown Styles for Sidebar */
        .dropdown-container {
            position: relative;
            display: inline-block;
        }

        .dropdown-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: background-color 0.2s ease;
        }

        .dropdown-btn:hover {
            background: var(--button-hover-bg);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--primary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 180px;
            display: none;
            z-index: 1002;
            margin-top: 2px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
            font-size: 12px;
            color: var(--text-color);
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: var(--button-hover-bg);
        }

        .dropdown-item i {
            width: 16px;
            text-align: center;
        }
        #view-mode-toggle {
            background: var(--button-bg);
        }
        #view-mode-toggle:hover {
            background: var(--button-hover-bg);
        }
        #view-mode-toggle.files-mode {
            background: var(--accent-color);
        }
        #view-mode-toggle.toc-mode {
            background: #28a745;
        }
        #view-mode-toggle.dual-mode {
            background: #17a2b8;
        }
        .sidebar-content-panel {
            flex: 1;
            overflow-y: auto;
        }
        
        /* Dual mode styles */
        .file-panel.dual-mode .file-list {
            max-height: 50%;
            border-bottom: 1px solid var(--border-color);
        }
        .file-panel.dual-mode .toc-container {
            max-height: 50%;
        }
        
        /* Compact line numbers */
        .CodeMirror-linenumber {
            padding: 0 2px 0 2px !important;
            min-width: 16px !important;
            width: 16px !important;
            font-size: 11px !important;
        }
        .CodeMirror-gutters {
            width: 20px !important;
        }
        
        /* Force word wrap for all content - Editor */
        .CodeMirror {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
        }
        .CodeMirror-line {
            word-wrap: break-word !important;
            white-space: pre-wrap !important;
            word-break: break-word !important;
            overflow-wrap: break-word !important;
        }
        .CodeMirror-code {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
        }
        .CodeMirror pre {
            word-wrap: break-word !important;
            white-space: pre-wrap !important;
            overflow-wrap: break-word !important;
        }
        .CodeMirror-wrap {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
        }
        
        /* Force word wrap for preview/render area */
        .preview-container {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            white-space: normal !important;
            /* Add bottom padding to match editor's bottom space */
            padding-bottom: 75vh !important;
        }
        .preview-container * {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            word-break: break-word !important;
            max-width: 100% !important;
        }
        .preview-container pre {
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            overflow-x: auto !important;
        }
        .preview-container code {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            white-space: pre-wrap !important;
        }
        .preview-container table {
            table-layout: fixed !important;
            width: 100% !important;
            word-wrap: break-word !important;
        }
        .preview-container td, .preview-container th {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            word-break: break-word !important;
        }
        
        /* Handle images and media */
        .preview-container img {
            max-width: 100% !important;
            height: auto !important;
        }
        
        /* Handle long URLs and links */
        .preview-container a {
            word-break: break-all !important;
            overflow-wrap: break-word !important;
        }
        
        /* Handle code blocks with long lines */
        .preview-container pre code {
            white-space: pre-wrap !important;
            word-break: break-all !important;
        }
        
        /* Handle blockquotes */
        .preview-container blockquote {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
        }
        
        /* Ensure all containers don't overflow */
        .editor-panel, .preview-container {
            overflow-x: hidden !important;
        }
        
        /* Hide mobile view toggle on desktop */
        #mobile-view-toggle {
            display: none;
        }
        
        /* Mobile responsive design */
        @media (max-width: 768px) {
            /* Enhanced mobile word wrap */
            .CodeMirror {
                line-height: 1.3 !important;
                /* 移除固定字體大小，讓用戶設定生效 */
            }
            
            /* Enhanced mobile preview word wrap */
            .preview-container {
                /* 移除固定字體大小，讓預覽也能隨設定變化 */
                line-height: 1.4 !important;
            }
            
            /* Hide unnecessary buttons on mobile, but show timer, font, search and mobile jump */
            .toolbar button:not(#sidebar-toggle):not(#mobile-view-toggle):not(#timer-btn):not(#font-settings-btn):not(#search-toggle-btn):not(#mobile-jump-btn) {
                display: none !important;
            }
            
            /* Show mobile view toggle only on mobile */
            #mobile-view-toggle {
                display: block !important;
            }
            
            /* Mobile toolbar buttons */
            .toolbar button {
                padding: 10px 12px !important;
                font-size: 14px !important;
                min-width: 44px; /* Touch friendly size */
                margin: 0 2px;
            }
            
            /* Mobile specific styling for new buttons */
            #timer-btn, #font-settings-btn, #search-toggle-btn, #mobile-jump-btn {
                display: block !important;
                height: 44px;
            }
            
            /* Mobile jump button specific styling */
            #mobile-jump-btn {
                background: var(--accent-color) !important;
                color: white !important;
                border: 2px solid rgba(255, 255, 255, 0.3) !important;
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7); }
                70% { box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
                100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
            }
            
            /* Adjust timer button on mobile */
            #timer-btn #timer-display {
                font-size: 12px !important;
            }
            
            /* Hide button text on mobile for cleaner look */
            .toolbar .btn-text {
                display: none !important;
            }
            
            /* Full screen sidebar on mobile */
            .file-panel:not(.collapsed) {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                max-width: 100vw !important;
                height: 100vh !important;
                z-index: 9999 !important;
                background: var(--bg-color) !important;
            }
            
            /* Hide main content when sidebar is open on mobile */
            .file-panel:not(.collapsed) ~ .main-panel {
                display: none !important;
            }
            
            /* Mobile sidebar controls */
            .sidebar-controls {
                flex-wrap: wrap !important;
                justify-content: center;
                gap: 8px !important;
            }
            
            .sidebar-controls button {
                padding: 10px 12px !important;
                font-size: 12px !important;
                min-width: 40px !important;
                margin: 2px;
            }
            
            /* Single view modes on mobile - pure edit or pure preview */
            .mobile-edit-only .editor-panel {
                width: 100% !important;
                display: flex !important;
            }
            .mobile-edit-only .preview-panel {
                display: none !important;
            }
            .mobile-edit-only .preview-container {
                display: none !important;
            }
            
            .mobile-preview-only .editor-panel {
                display: none !important;
            }
            .mobile-preview-only .preview-panel {
                width: 100% !important;
                display: flex !important;
            }
            .mobile-preview-only .preview-container {
                width: 100% !important;
                display: block !important;
            }
            
            /* Ensure mobile views take full space */
            .mobile-edit-only .main-editor-content {
                display: flex !important;
                flex-direction: row !important;
            }
            .mobile-preview-only .main-editor-content {
                display: flex !important;
                flex-direction: row !important;
            }
            
            /* Force single view on mobile */
            .mobile-edit-only .editor-panel {
                flex: 1 !important;
                height: 100% !important;
            }
            
            .mobile-preview-only .preview-panel {
                flex: 1 !important;
                height: 100% !important;
            }
            
            /* Override any existing responsive rules for mobile single views */
            @media (max-width: 768px) {
                .mobile-edit-only .main-editor-content {
                    flex-direction: row !important;
                }
                .mobile-edit-only .editor-panel,
                .mobile-edit-only .preview-panel {
                    height: auto !important;
                }
                .mobile-edit-only .editor-panel {
                    height: 100% !important;
                }
                
                .mobile-preview-only .main-editor-content {
                    flex-direction: row !important;
                }
                .mobile-preview-only .editor-panel,
                .mobile-preview-only .preview-panel {
                    height: auto !important;
                }
                .mobile-preview-only .preview-panel {
                    height: 100% !important;
                }
            }
            
            /* Timer modal mobile optimization */
            .timer-modal-content {
                width: 95% !important;
                margin: 2% auto !important;
            }
        }
        .file-panel-actions {
            display: flex;
            gap: 5px;
        }
        .file-panel-actions button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 12px;
        }
        .file-panel-actions button:hover {
            background: #0056b3;
        }
        .file-list, .toc-container {
            flex: 1 1 50%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .file-list.hidden, .toc-container.hidden {
            display: none;
        }
        .file-panel.split-view .toc-container {
            border-top: 1px solid var(--border-color);
        }
        .toc-header {
            background: var(--header-bg);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .toc-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-color);
        }
        .toc-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 5px;
        }
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 6px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            background: white;
            border: 1px solid #e0e0e0;
            transition: all 0.2s;
        }
        .file-item:hover {
            background: #f5f5f5;
            border-color: var(--accent-color);
        }
        .file-item.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        .file-item.system-file {
            background: #f8f9fa;
            border-color: #007bff;
            border-left: 3px solid #007bff;
        }
        .file-item.system-file:hover {
            background: #e3f2fd;
        }
        .file-item.system-file.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .file-item.pinned {
            /* No special styling for pinned files - only green pin button indicator */
        }
        .file-item.pinned:hover {
            /* No special hover styling for pinned files */
        }
        .file-item.pinned.active {
            /* No special active styling for pinned files */
        }
        
        /* UNSYNC files styling - only orange border */
        .file-item.unsync-file {
            background: white; /* 保持白色背景 */
            border-color: #fd7e14;
            border-left: 3px solid #fd7e14;
        }
        .file-item.unsync-file:hover {
            background: #f5f5f5; /* hover時使用一般的淺灰色 */
        }
        .file-item.unsync-file.active {
            background: var(--accent-color); /* active時使用主要顏色 */
            color: white;
            border-color: var(--accent-color);
        }
        .pin-button {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #28a745;
            border: none;
            border-radius: 2px;
            color: white;
            cursor: pointer;
            font-size: 8px;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .file-item:hover .pin-button {
            opacity: 0.7;
        }
        .pin-button:hover {
            opacity: 1 !important;
        }
        .pin-button.pinned {
            opacity: 1;
            background: #28a745;
        }
        .file-item {
            position: relative;
        }
        .file-item-name {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            margin-left: 20px;
        }
        .file-item-actions {
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .file-item:hover .file-item-actions {
            opacity: 1;
        }
        .file-item.active .file-item-actions {
            opacity: 1;
        }
        .file-action-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s;
        }
        .file-action-btn:hover {
            background: rgba(0,0,0,0.1);
            color: #333;
        }
        .file-item.active .file-action-btn {
            color: rgba(255,255,255,0.8);
        }
        .file-item.active .file-action-btn:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        /* File rename input */
        .file-rename-input {
            background: white;
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 14px;
            font-weight: 500;
            width: 100%;
        }
        .file-rename-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

		/* Search Bar Styles */
        .search-bar {
            display: none; /* Initially hidden */
            position: absolute; /* Changed from fixed to absolute within main-panel */
            top: 70px; /* Adjust as needed, below toolbar */
            right: 20px;
            background: rgba(45, 45, 45, 0.95);
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 14px;
        }

        /* Desktop search bar layout */
        .search-bar-row-1,
        .search-bar-row-2 {
            display: contents; /* Make child elements behave as if they're direct children of search-bar */
        }

        /* Show search bar as flex on desktop */
        .search-bar.active {
            display: flex !important;
        }

        /* Mobile search bar layout */
        @media (max-width: 768px) {
            .search-bar {
                right: 10px;
                left: 10px;
                width: calc(100% - 20px);
                max-width: none;
                padding: 12px;
            }
            
            .search-bar.active {
                display: grid !important;
                grid-template-columns: 1fr;
                grid-gap: 8px;
            }
            
            .search-bar-row-1,
            .search-bar-row-2 {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .search-bar-row-2 {
                justify-content: space-between;
            }
            
            .search-bar-row-1 input[type="text"] {
                flex: 1;
                min-width: 0;
            }

            .search-bar-row-2 button {
                min-width: 44px;
                height: 32px;
                padding: 4px 8px;
                font-size: 12px;
            }
        }

        .search-bar input[type="text"] {
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: white;
            font-size: 14px;
            width: 180px;
            outline: none;
        }

        .search-bar input[type="text"]::placeholder {
            color: #bbb;
        }

        .search-bar input[type="text"]:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.3);
        }

        .search-bar button {
            background: var(--button-bg); /* Use existing button style */
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            white-space: nowrap;
        }

        .search-bar button:hover {
            background: var(--button-hover-bg);
        }

        .search-bar button i {
            margin: 0;
        }
        
        .search-match-count {
            font-size: 13px;
            color: #ccc;
            min-width: 45px;
            text-align: right;
        }

        /* Highlighting styles for CodeMirror */
        .CodeMirror .highlighted-search {
            background-color: rgba(255, 255, 0, 0.5); /* Semi-transparent yellow */
            border-radius: 2px;
        }

        .CodeMirror .current-highlighted-search {
            background-color: rgba(255, 165, 0, 0.8); /* Opaque orange for current match */
            outline: 1px solid #ff4500; /* Reddish orange border */
            box-shadow: 0 0 5px rgba(255, 165, 0, 0.5);
        }
		/* Search Bar Styles End */

        /* Main Panel */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--primary-bg);
        }

        

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
        }
        .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        #toc-list { list-style: none; padding: 0; }
        #toc-list li { padding: 5px 0; cursor: pointer; border-bottom: 1px solid #eee; }
        #toc-list li:hover { background: #f0f0f0; }
        #toc-list .toc-h1 { padding-left: 10px; font-weight: bold; }
        #toc-list .toc-h2 { padding-left: 25px; }
        #toc-list .toc-h3 { padding-left: 40px; }
        /* PDF Slide styles */
        .pdf-slide {
            padding: 40px;
            background: white;
            width: 1920px; /* Fixed width for consistent export */
            height: 1080px; /* Fixed height for consistent export */
            box-sizing: border-box;
        }


        /* 改善工具列 */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: var(--header-bg);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .toolbar button {
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            white-space: nowrap;
        }
        .toolbar button:hover {
            background: var(--button-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .toolbar button i {
            margin-right: 5px;
        }

        /* Timer Button Styles */
        .timer-btn {
            background: var(--accent-color) !important;
            position: relative;
            font-weight: 600;
        }
        .timer-btn:hover {
            background: #0056b3 !important;
        }
        .timer-btn.timing {
            background: #28a745 !important;
            animation: pulse 2s infinite;
        }
        .timer-btn.timing:hover {
            background: #218838 !important;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        #timer-display {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            margin-left: 5px;
        }

        /* Timer Modal Styles */
        .timer-modal-content {
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            margin: 5% auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .timer-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
            gap: 20px;
            flex-wrap: wrap;
        }
        .date-picker-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .date-picker-container input[type="date"] {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
        }
        .date-picker-container button {
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
        }
        .timer-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .timer-controls input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            width: 200px;
        }
        .timer-controls button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            width: 40px;
        }
        .timer-controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .timer-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .timer-actions button {
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .export-btn {
            background: #28a745 !important;
        }
        .export-btn:hover {
            background: #218838 !important;
        }
        .auto-timer-btn {
            background: #17a2b8 !important;
        }
        .auto-timer-btn:hover {
            background: #138496 !important;
        }
        .auto-timer-btn.active {
            background: #28a745 !important;
        }
        .auto-timer-btn.active:hover {
            background: #218838 !important;
        }

        /* Tab Styles */
        .timer-view-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-btn.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }
        .tab-btn:hover {
            color: var(--accent-color);
            background: rgba(0, 123, 255, 0.05);
        }

        /* Timeline Styles */
        .timeline-container {
            flex: 1;
            overflow-y: auto;
            min-height: 300px;
        }
        
        /* Chart Styles */
        .chart-container {
            flex: 1;
            overflow-y: auto;
            min-height: 300px;
        }
        .chart-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .chart-controls label {
            font-weight: 600;
            color: var(--text-color);
        }
        .chart-controls select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        .pie-chart-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            padding: 20px;
        }
        .pie-chart {
            width: 300px;
            height: 300px;
            position: relative;
        }
        .pie-chart svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        .pie-legend {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .legend-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
            flex: 1;
        }
        .legend-duration {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: var(--accent-color);
            font-weight: 600;
        }
        .legend-percentage {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }
        
        /* Shortcuts Help Modal Styles */
        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
            margin-top: 20px;
        }
        .shortcuts-section h3 {
            color: var(--accent-color);
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--accent-color);
            font-size: 16px;
        }
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid var(--accent-color);
        }
        .shortcut-item kbd {
            background: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            color: #495057;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }
        .shortcut-item span {
            font-weight: 500;
            color: var(--text-color);
        }
        .timeline-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .timeline-item:hover {
            background-color: #f8f9fa;
        }
        .timeline-time {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: #666;
            width: 120px;
            flex-shrink: 0;
        }
        .timeline-duration {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: var(--accent-color);
            width: 80px;
            flex-shrink: 0;
            font-weight: 600;
        }
        .timeline-task {
            flex: 1;
            padding: 0 15px;
            font-size: 14px;
        }
        .timeline-task.auto-generated {
            color: #28a745;
            font-weight: 500;
        }
        .timeline-bar {
            width: 4px;
            height: 20px;
            background: var(--accent-color);
            margin-right: 15px;
            border-radius: 2px;
        }
        .timeline-bar.auto-generated {
            background: #28a745;
        }

        /* Timer Stats */
        .timer-stats {
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            border-top: 1px solid var(--border-color);
            background: #f8f9fa;
            border-radius: 0 0 8px 8px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            display: block;
        }
        .stat-item span:last-child {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-color);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        /* 改善編輯器和預覽區域 */
        .main-editor-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .editor-panel, .preview-panel, .drawing-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        .editor-header, .preview-header, .drawing-header {
            background: var(--header-bg);
            padding: 4px 10px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 14px;
            max-height: 5vh;
            text-align: left;
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .editor-header i, .preview-header i, .drawing-header i {
            margin-right: 8px;
            color: var(--accent-color);
        }
        
        /* Drawing Panel Specific Styles */
        .drawing-panel {
            border-left: 1px solid var(--border-color);
        }
        
        .drawing-controls {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: nowrap;
        }
        
        .tool-group {
            display: flex;
            gap: 3px;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 2px;
            border-radius: 4px;
        }
        
        .tool-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 4px;
        }
        
        .drawing-tool-btn {
            background: transparent;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 4px;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
        }
        
        .drawing-tool-btn:hover {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        .drawing-tool-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.3);
        }
        
        .color-picker-container {
            display: flex;
            gap: 4px;
        }
        
        .color-picker-container input[type="color"] {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }
        
        .color-picker-container input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        .color-picker-container input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
        }
        
        #stroke-width {
            width: 80px;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        #stroke-width::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .excalidraw-container {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }
        
        .excalidraw-container .excalidraw {
            height: 100% !important;
            width: 100% !important;
        }
        
        /* Panel Divider Styles */
        .panel-divider {
            width: 8px;
            background: var(--border-color);
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .panel-divider:hover {
            background: var(--accent-color);
        }
        
        .panel-divider.dragging {
            background: var(--accent-color);
            cursor: col-resize;
        }
        
        .divider-handle {
            color: var(--text-color);
            opacity: 0.5;
            transition: opacity 0.2s;
            font-size: 12px;
            writing-mode: vertical-lr;
            text-orientation: mixed;
        }
        
        .panel-divider:hover .divider-handle {
            opacity: 1;
            color: white;
        }
        
        .panel-divider.dragging .divider-handle {
            opacity: 1;
            color: white;
        }
        
        /* Ensure panels are properly sized for resizing */
        .main-editor-content.drawing-mode {
            display: flex;
        }
        
        .main-editor-content.drawing-mode .editor-panel {
            flex: 0 0 50%;
            min-width: 200px;
        }
        
        .main-editor-content.drawing-mode .drawing-panel {
            flex: 1;
            min-width: 200px;
        }
        
        /* Fold toggle button */
        .fold-toggle-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            color: var(--text-color);
            font-size: 12px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .fold-toggle-btn:hover {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        .fold-toggle-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        .fold-toggle-btn i {
            margin: 0;
        }
        
        /* Line numbers styling for fold functionality */
        .CodeMirror-linenumbers {
            border-right: 1px solid var(--border-color);
            background-color: #f8f9fa;
        }
        
        .CodeMirror-linenumber {
            color: #666;
            padding: 0 8px 0 5px;
            text-align: right;
            transition: color 0.2s ease;
        }
        
        .CodeMirror-linenumber:hover {
            background-color: #e9ecef;
        }
        
        .CodeMirror-foldmarker {
            color: var(--accent-color);
            text-shadow: none;
            font-family: monospace;
            cursor: pointer;
        }
        .editor-container, .preview-container {
            flex: 1;
            overflow: auto;
            padding: 0;
            position: relative;
        }
        .CodeMirror {
            height: 100%;
            font-size: 22px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .CodeMirror-line {
            text-align: left; /* 確保每行文字左對齊 */
        }
        
        .CodeMirror pre {
            text-align: left; /* 確保程式碼文字左對齊 */
        }
        #preview {
            padding: 20px;
            max-width: none;
            line-height: 1.6;
            font-size: 22px;
            text-align: left;
        }
        
        /* Markdown Content Styling */
        
        #preview h1 {
            font-size: 1.5em;
            font-weight: 600;
            color: var(--text-color);
            margin: 0 0 14px 0;
            padding-bottom: 4px;
            text-align: left;
            border-bottom: 3px solid var(--accent-color);
            line-height: 1;
        }
        
        #preview h2 {
            font-size: 1.4em;
            font-weight: 600;
            color: var(--text-color);
            margin: 20px 0 12px 0;
            padding-bottom: 4px;
            border-bottom: 2px solid rgba(0, 123, 255, 0.3);
            line-height: 1.3;
            text-align: left;
        }
        
        #preview h3 {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--text-color);
            margin: 20px 0 12px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(0, 123, 255, 0.2);
            line-height: 1.4;
            text-align: left;
        }
        
        #preview h4 {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-color);
            margin: 20px 0 12px 0;
            line-height: 1.4;
            text-align: left;
        }
        
        #preview h5 {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-color);
            margin: 18px 0 10px 0;
            line-height: 1.4;
            text-align: left;
        }
        
        #preview h6 {
            font-size: 1em;
            font-weight: 600;
            color: var(--accent-color);
            margin: 16px 0 8px 0;
            line-height: 1.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: left;
        }
        
        #preview p {
            margin: 0 0 16px 0;
            line-height: 1.7;
        }
        
        #preview ul, #preview ol {
            margin: 0 0 16px 0;
            padding-left: 24px;
        }
        
        #preview li {
            margin: 6px 0;
            line-height: 1.6;
        }
        
        #preview ul ul, #preview ol ol, #preview ul ol, #preview ol ul {
            margin: 8px 0;
        }
        
        #preview blockquote {
            margin: 20px 0;
            padding: 16px 20px;
            background: rgba(0, 123, 255, 0.05);
            border-left: 4px solid var(--accent-color);
            border-radius: 0 6px 6px 0;
        }
        
        #preview blockquote p {
            margin: 0;
            font-style: italic;
            color: rgba(33, 37, 41, 0.8);
        }
        
        #preview code {
            background: rgba(0, 123, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            color: #d63384;
        }
        
        #preview pre {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 6px;
            margin: 16px 0;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            max-width: 100%;
            white-space: pre;
            position: relative;
        }
        
        #preview pre code {
            background: none;
            padding: 0;
            color: var(--text-color);
            display: block;
            overflow-x: auto;
            white-space: pre;
            word-wrap: normal;
            max-width: 100%;
            line-height: 1.5;
            tab-size: 4;
        }
        
        /* 處理長行的水平滾動 */
        #preview pre {
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        /* 限制縮排深度避免版面破壞 */
        #preview pre code {
            text-indent: 0;
            padding-left: 0;
        }
        
        /* 為不同語言添加語法高亮樣式 */
        #preview pre[class*="language-"] {
            position: relative;
        }
        
        #preview pre[class*="language-"]:before {
            content: attr(class);
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* 改善程式碼區塊的顯示 */
        #preview pre {
            font-size: 14px;
            line-height: 1.4;
            border-left: 4px solid var(--accent-color);
            position: relative;
            min-height: 20px;
        }
        
        /* 添加行號支援 */
        #preview pre.line-numbers {
            padding-left: 50px;
        }
        
        #preview pre.line-numbers:before {
            content: counter(line);
            counter-increment: line;
            position: absolute;
            left: 16px;
            color: #999;
            font-size: 12px;
            width: 20px;
            text-align: right;
        }
        
        /* 處理超長程式碼行的樣式 */
        @media (max-width: 768px) {
            #preview pre {
                font-size: 12px;
                padding: 12px;
                margin: 12px 0;
            }
            
            #preview pre code {
                font-size: 12px;
            }
        }
        
        /* 程式碼區塊的複製按鈕 */
        #preview pre {
            position: relative;
        }
        
        #preview pre:hover .copy-button {
            opacity: 1;
        }
        
        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        
        .copy-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        /* 處理不同縮排等級的視覺效果 */
        #preview pre code .indent-1 { padding-left: 1em; }
        #preview pre code .indent-2 { padding-left: 2em; }
        #preview pre code .indent-3 { padding-left: 3em; }
        #preview pre code .indent-4 { padding-left: 4em; }
        
        /* 限制最大縮排以避免版面破壞 */
        #preview pre code {
            max-width: calc(100% - 32px);
            overflow-x: auto;
        }
        
        /* 確保highlight.js樣式正確應用 */
        #preview pre code.hljs {
            background: inherit;
            padding: 0;
        }
        
        /* highlight.js的基本語法高亮樣式 */
        #preview .hljs-keyword { color: #0077aa; font-weight: bold; }
        #preview .hljs-string { color: #669900; }
        #preview .hljs-comment { color: #999988; font-style: italic; }
        #preview .hljs-number { color: #009999; }
        #preview .hljs-function { color: #900; font-weight: bold; }
        #preview .hljs-title { color: #900; font-weight: bold; }
        #preview .hljs-variable { color: #333; }
        #preview .hljs-literal { color: #78a960; }
        #preview .hljs-built_in { color: #0086b3; }
        #preview .hljs-attr { color: #008080; }
        #preview .hljs-type { color: #458; font-weight: bold; }
        #preview .hljs-meta { color: #999; }
        #preview .hljs-doctag { color: #d73a49; }
        #preview .hljs-tag { color: #000080; }
        #preview .hljs-name { color: #000080; }
        #preview .hljs-selector-id { color: #795da3; }
        #preview .hljs-selector-class { color: #795da3; }
        #preview .hljs-property { color: #0086b3; }
        
        #preview table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        
        #preview th, #preview td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        #preview th {
            background: var(--header-bg);
            font-weight: 600;
        }
        
        #preview hr {
            margin: 32px 0;
            border: none;
            height: 2px;
            background: linear-gradient(to right, var(--accent-color), transparent);
        }
        
        /* Wiki Link Styles */
        .wiki-link {
            color: var(--accent-color);
            text-decoration: none;
            background: rgba(0, 123, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            border: 1px solid rgba(0, 123, 255, 0.2);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .wiki-link:hover {
            background: rgba(0, 123, 255, 0.2);
            border-color: var(--accent-color);
            transform: translateY(-1px);
        }
        .wiki-link-missing {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            border: 1px solid rgba(220, 53, 69, 0.2);
            font-weight: 500;
            cursor: help;
        }
        .preview-panel {
            border-left: 1px solid var(--border-color);
        }
        
        /* View Mode Toggle Buttons in Toolbar */
        .view-mode-toolbar-btn {
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            margin: 0 2px;
            min-width: 36px;
        }
        .view-mode-toolbar-btn:hover {
            background: var(--button-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .view-mode-toolbar-btn.active {
            background: var(--accent-color);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        }
        .view-mode-toolbar-btn.active:hover {
            background: #0056b3;
        }
        
        /* Autocomplete Suggestions */
        .autocomplete-dropdown {
            position: absolute;
            z-index: 1000;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 200px;
            overflow-y: auto;
            min-width: 200px;
        }
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        .autocomplete-item:hover, .autocomplete-item.selected {
            background: var(--accent-color);
            color: white;
        }
        
        /* Hashtag dropdown specific styles */
        .hashtag-dropdown .autocomplete-item {
            background: white;
            color: #333;
            font-weight: 500;
        }
        
        .hashtag-dropdown .autocomplete-item:hover, 
        .hashtag-dropdown .autocomplete-item.selected {
            background: #007bff;
            color: white;
        }
        
        .hashtag-dropdown .autocomplete-item.new-hashtag {
            background: #e8f5e8;
            color: #2e7d32;
            border-left: 3px solid #4caf50;
            font-weight: 600;
        }
        
        .hashtag-dropdown .autocomplete-item.new-hashtag:hover,
        .hashtag-dropdown .autocomplete-item.new-hashtag.selected {
            background: #4caf50;
            color: white;
        }
        
        .hashtag-dropdown .autocomplete-item.new-hashtag::before {
            content: "+ ";
            font-weight: bold;
        }
        .autocomplete-note-name {
            font-weight: 600;
        }
        .autocomplete-section {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .autocomplete-item:hover .autocomplete-section, 
        .autocomplete-item.selected .autocomplete-section {
            color: rgba(255,255,255,0.8);
        }

        /* Font Settings Modal Styles */
        .settings-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--secondary-bg);
        }
        
        .settings-section h3 {
            margin: 0 0 15px 0;
            color: var(--accent-color);
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .font-size-controls label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-color);
        }
        
        .size-control {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .size-control button {
            width: 40px;
            height: 40px;
            border: 2px solid var(--accent-color);
            background: var(--secondary-bg);
            color: var(--accent-color);
            border-radius: 6px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .size-control button:hover {
            background: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }
        
        #font-size-display {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            color: var(--text-color);
        }
        
        #font-size-slider {
            flex: 1;
            min-width: 200px;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        #font-size-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #font-size-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
        }
        
        .theme-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }
        
        .theme-btn {
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            background: var(--secondary-bg);
            color: var(--text-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .theme-btn:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.2);
        }
        
        .theme-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }
        
        .settings-actions {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            padding: 20px 0 0 0;
            border-top: 1px solid var(--border-color);
            margin-top: 30px;
        }
        
        .settings-actions button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        #reset-settings-btn {
            background: #6c757d;
            color: white;
        }
        
        #reset-settings-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }
        
        #apply-settings-btn {
            background: var(--accent-color);
            color: white;
        }
        
        #apply-settings-btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        /* Theme-specific styles for preview and presentation */
        .theme-default {
            background: var(--secondary-bg);
            color: var(--text-color);
        }
        
        .theme-monokai {
            background: #272822;
            color: #f8f8f2;
        }
        
        .theme-monokai #preview h1, .theme-monokai #preview h2, .theme-monokai #preview h3,
        .theme-monokai #preview h4, .theme-monokai #preview h5, .theme-monokai #preview h6 {
            color: #a6e22e;
        }
        
        .theme-monokai #preview code {
            background: rgba(166, 226, 46, 0.2);
            color: #f92672;
        }
        
        .theme-monokai #preview pre {
            background: #1e1f1c;
            border-color: #49483e;
            border-left-color: #a6e22e;
        }
        
        /* Monokai 主題的語法高亮 */
        .theme-monokai #preview .hljs-keyword { color: #f92672; font-weight: bold; }
        .theme-monokai #preview .hljs-string { color: #e6db74; }
        .theme-monokai #preview .hljs-comment { color: #75715e; font-style: italic; }
        .theme-monokai #preview .hljs-number { color: #ae81ff; }
        .theme-monokai #preview .hljs-function { color: #a6e22e; font-weight: bold; }
        .theme-monokai #preview .hljs-title { color: #a6e22e; font-weight: bold; }
        .theme-monokai #preview .hljs-variable { color: #f8f8f2; }
        .theme-monokai #preview .hljs-literal { color: #ae81ff; }
        .theme-monokai #preview .hljs-built_in { color: #66d9ef; }
        
        .theme-solarized.dark {
            background: #002b36;
            color: #839496;
        }
        
        .theme-solarized.dark #preview h1, .theme-solarized.dark #preview h2, .theme-solarized.dark #preview h3,
        .theme-solarized.dark #preview h4, .theme-solarized.dark #preview h5, .theme-solarized.dark #preview h6 {
            color: #268bd2;
        }
        
        .theme-solarized.dark #preview code {
            background: rgba(38, 139, 210, 0.2);
            color: #dc322f;
        }
        
        .theme-solarized.dark #preview pre {
            background: #073642;
            border-color: #586e75;
            border-left-color: #268bd2;
        }
        
        .theme-material {
            background: #263238;
            color: #eeffff;
        }
        
        .theme-material #preview h1, .theme-material #preview h2, .theme-material #preview h3,
        .theme-material #preview h4, .theme-material #preview h5, .theme-material #preview h6 {
            color: #82b1ff;
        }
        
        .theme-material #preview code {
            background: rgba(130, 177, 255, 0.2);
            color: #f78c6c;
        }
        
        .theme-material #preview pre {
            background: #1e272c;
            border-color: #37474f;
            border-left-color: #82b1ff;
        }
        
        .theme-dracula {
            background: #282a36;
            color: #f8f8f2;
        }
        
        .theme-dracula #preview h1, .theme-dracula #preview h2, .theme-dracula #preview h3,
        .theme-dracula #preview h4, .theme-dracula #preview h5, .theme-dracula #preview h6 {
            color: #bd93f9;
        }
        
        .theme-dracula #preview code {
            background: rgba(189, 147, 249, 0.2);
            color: #ff79c6;
        }
        
        .theme-dracula #preview pre {
            background: #21222c;
            border-color: #44475a;
            border-left-color: #bd93f9;
        }
        
        /* Dracula 主題的語法高亮 */
        .theme-dracula #preview .hljs-keyword { color: #ff79c6; font-weight: bold; }
        .theme-dracula #preview .hljs-string { color: #f1fa8c; }
        .theme-dracula #preview .hljs-comment { color: #6272a4; font-style: italic; }
        .theme-dracula #preview .hljs-number { color: #bd93f9; }
        .theme-dracula #preview .hljs-function { color: #50fa7b; font-weight: bold; }
        .theme-dracula #preview .hljs-title { color: #50fa7b; font-weight: bold; }
        .theme-dracula #preview .hljs-variable { color: #f8f8f2; }
        .theme-dracula #preview .hljs-literal { color: #bd93f9; }
        .theme-dracula #preview .hljs-built_in { color: #8be9fd; }
        
        .theme-github {
            background: #ffffff;
            color: #24292e;
        }
        
        .theme-github #preview h1, .theme-github #preview h2, .theme-github #preview h3,
        .theme-github #preview h4, .theme-github #preview h5, .theme-github #preview h6 {
            color: #0366d6;
        }
        
        .theme-github #preview code {
            background: rgba(3, 102, 214, 0.1);
            color: #d73a49;
        }
        
        .theme-github #preview pre {
            background: #f6f8fa;
            border-color: #e1e4e8;
            border-left-color: #0366d6;
        }
        
        /* Presentation mode theme support */
        .presentation-mode.theme-monokai {
            background: #272822;
            color: #f8f8f2;
        }
        
        .presentation-mode.theme-solarized.dark {
            background: #002b36;
            color: #839496;
        }
        
        .presentation-mode.theme-material {
            background: #263238;
            color: #eeffff;
        }
        
        .presentation-mode.theme-dracula {
            background: #282a36;
            color: #f8f8f2;
        }
        
        .presentation-mode.theme-github {
            background: #ffffff;
            color: #24292e;
        }

        /* Presentation Mode Styles */
        .presentation-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            z-index: 2000;
            display: none;
        }
        .presentation-mode.active {
            display: block;
        }
        .presentation-toolbar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2001;
            background: rgba(0,0,0,0.7);
            border-radius: 6px;
            padding: 10px;
        }
        .presentation-toolbar button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .presentation-toolbar button:hover {
            background: #0056b3;
        }

        /* 右下角熱區觸發簡報工具列顯示 */
        .presentation-toolbar-hotspot {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            z-index: 2000;
            background: transparent;
        }
        .presentation-toolbar {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .presentation-toolbar-hotspot:hover + .presentation-toolbar,
        .presentation-toolbar:hover {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* Override reveal.js styles for better integration */
        .reveal .slides {
            text-align: left;
        }
        .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
            color: var(--accent-color);
        }
        
        /* Theme-specific reveal.js text colors */
        .theme-monokai .reveal,
        .theme-monokai .reveal p,
        .theme-monokai .reveal li,
        .theme-monokai .reveal div {
            color: #f8f8f2 !important;
        }
        
        .theme-monokai .reveal h1, .theme-monokai .reveal h2, .theme-monokai .reveal h3,
        .theme-monokai .reveal h4, .theme-monokai .reveal h5, .theme-monokai .reveal h6 {
            color: #a6e22e !important;
        }
        
        .theme-solarized.dark .reveal,
        .theme-solarized.dark .reveal p,
        .theme-solarized.dark .reveal li,
        .theme-solarized.dark .reveal div {
            color: #839496 !important;
        }
        
        .theme-solarized.dark .reveal h1, .theme-solarized.dark .reveal h2, .theme-solarized.dark .reveal h3,
        .theme-solarized.dark .reveal h4, .theme-solarized.dark .reveal h5, .theme-solarized.dark .reveal h6 {
            color: #268bd2 !important;
        }
        
        .theme-material .reveal,
        .theme-material .reveal p,
        .theme-material .reveal li,
        .theme-material .reveal div {
            color: #eeffff !important;
        }
        
        .theme-material .reveal h1, .theme-material .reveal h2, .theme-material .reveal h3,
        .theme-material .reveal h4, .theme-material .reveal h5, .theme-material .reveal h6 {
            color: #82b1ff !important;
        }
        
        .theme-dracula .reveal,
        .theme-dracula .reveal p,
        .theme-dracula .reveal li,
        .theme-dracula .reveal div {
            color: #f8f8f2 !important;
        }
        
        .theme-dracula .reveal h1, .theme-dracula .reveal h2, .theme-dracula .reveal h3,
        .theme-dracula .reveal h4, .theme-dracula .reveal h5, .theme-dracula .reveal h6 {
            color: #bd93f9 !important;
        }
        
        .theme-github .reveal,
        .theme-github .reveal p,
        .theme-github .reveal li,
        .theme-github .reveal div {
            color: #24292e !important;
        }
        
        .theme-github .reveal h1, .theme-github .reveal h2, .theme-github .reveal h3,
        .theme-github .reveal h4, .theme-github .reveal h5, .theme-github .reveal h6 {
            color: #0366d6 !important;
        }
        .reveal .slides .mermaid {
            text-align: center;
            margin: 20px auto;
            max-width: 100%;
            overflow: auto;
        }
        .reveal .slides .mermaid svg {
            max-width: 100% !important;
            height: auto !important;
        }

        /* 響應式設計改善 - 只在非單一視圖模式時應用 */
        @media (max-width: 768px) {
            .main-editor-content {
                flex-direction: column;
            }
            .editor-panel, .preview-panel {
                height: 50vh;
            }
            
            /* Override for single view modes */
            .mobile-edit-only .main-editor-content {
                flex-direction: row !important;
            }
            .mobile-edit-only .editor-panel {
                height: 100% !important;
                width: 100% !important;
            }
            .mobile-edit-only .preview-panel {
                display: none !important;
            }
            
            .mobile-preview-only .main-editor-content {
                flex-direction: row !important;
            }
            .mobile-preview-only .preview-panel {
                height: 100% !important;
                width: 100% !important;
            }
            .mobile-preview-only .editor-panel {
                display: none !important;
            }
        }

        /* 檔案、任務計時記錄視窗統一左對齊 */
        .file-panel,
        #timer-modal .modal-content {
            text-align: left;
        }

        /* 讓任務計時記錄視窗的關閉按鈕固定在右上角 */
        #timer-modal .close-btn {
            position: absolute;
            top: 18px;
            right: 28px;
            float: none;
            z-index: 10;
        }
        #timer-modal .modal-content {
            position: relative;
        }
        
        /* Wiki link preview popup */
        .wiki-preview-popup {
            position: fixed;
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            width: 80%;
            max-height: 70vh;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            font-size: 14px;
            line-height: 1.5;
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: scale(0.9) translateY(-10px);
            transition: all 0.2s ease;
            pointer-events: none;
        }
        
        .wiki-preview-popup.show {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }
        
        .wiki-preview-popup .preview-title {
            font-weight: bold;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            color: var(--accent-color);
        }
        
        .wiki-preview-popup .preview-content {
            color: var(--text-color);
            text-align: left;
        }
        
        .wiki-preview-popup .preview-content * {
            text-align: left !important;
        }
        
        .wiki-preview-popup .preview-content h1,
        .wiki-preview-popup .preview-content h2,
        .wiki-preview-popup .preview-content h3,
        .wiki-preview-popup .preview-content h4,
        .wiki-preview-popup .preview-content h5,
        .wiki-preview-popup .preview-content h6,
        .wiki-preview-popup .preview-content p,
        .wiki-preview-popup .preview-content li,
        .wiki-preview-popup .preview-content div {
            text-align: left !important;
        }
        
        /* Hashtag link styling */
        .hashtag-link {
            color: #007bff;
            text-decoration: none;
            background: rgba(0, 123, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(0, 123, 255, 0.2);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: monospace;
        }
        
        .hashtag-link:hover {
            background: rgba(0, 123, 255, 0.2);
            border-color: #007bff;
            transform: translateY(-1px);
            text-decoration: none;
        }

        /* Sync Settings Modal Styles */
        .sync-settings-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .sync-settings-tabs .tab-btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .sync-settings-tabs .tab-btn.active {
            border-bottom-color: var(--accent-color);
            color: var(--accent-color);
        }

        .sync-provider-settings {
            max-height: 300px;
            overflow-y: auto;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .setting-group input[type="text"],
        .setting-group input[type="password"],
        .setting-group input[type="url"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }

        .setting-group small {
            color: #666;
            font-size: 12px;
        }

        .sync-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .sync-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--secondary-bg);
            cursor: pointer;
            transition: all 0.3s;
        }

        .sync-btn.primary {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .sync-btn:hover {
            background: var(--button-hover-bg);
            color: white;
        }

        .sync-btn.primary:hover {
            background: #0056b3;
        }

        .sync-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        .sync-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .sync-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .sync-status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Version History Modal Styles */
        .version-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .version-item {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.3s;
        }

        .version-item:hover {
            background: var(--primary-bg);
        }

        .version-item:last-child {
            border-bottom: none;
        }

        .version-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .version-date {
            font-weight: 500;
            color: var(--accent-color);
        }

        .version-size {
            font-size: 12px;
            color: #666;
        }

        .version-description {
            font-size: 14px;
            color: #555;
            margin-bottom: 5px;
        }

        .version-actions-inline {
            display: flex;
            gap: 10px;
        }

        .version-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--secondary-bg);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .version-btn:hover {
            background: var(--button-hover-bg);
            color: white;
        }

        .version-btn.primary {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .version-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        /* Tag Filter Modal Styles */
        .tag-filter-content {
            padding: 20px 0;
        }

        .tag-filter-info {
            margin-bottom: 15px;
            padding: 10px;
            background: var(--secondary-bg);
            border-radius: 4px;
            font-size: 14px;
        }

        .tag-filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: flex-end;
        }

        .filter-control-btn {
            padding: 4px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--secondary-bg);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .filter-control-btn:hover {
            background: var(--button-hover-bg);
            color: white;
        }

        .tag-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            background: var(--secondary-bg);
        }

        .tag-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: var(--main-bg);
            border-radius: 4px;
            transition: background 0.2s;
        }

        .tag-item:hover {
            background: var(--button-hover-bg);
        }

        .tag-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .tag-item label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            margin: 0;
        }

        .tag-filter-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--secondary-bg);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .filter-btn:hover {
            background: var(--button-hover-bg);
            color: white;
        }

        .filter-btn.primary {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        /* Cloud sync button styles */
        #sync-to-cloud-btn,
        #load-from-cloud-btn,
        #publish-shared-btn,
        #sync-settings-btn {
            background: var(--accent-color);
            color: white;
        }

        #sync-to-cloud-btn:hover,
        #load-from-cloud-btn:hover,
        #publish-shared-btn:hover,
        #sync-settings-btn:hover {
            background: #0056b3;
        }
        
        #publish-shared-btn {
            background: #27ae60;
        }
        
        #publish-shared-btn:hover {
            background: #229954;
        }
        
        /* CodeMirror Markdown 簡潔樣式 - 預設主題 */
        .cm-s-default .cm-header,
        .cm-s-default .cm-header-1,
        .cm-s-default .cm-header-2,
        .cm-s-default .cm-header-3,
        .cm-s-default .cm-header-4,
        .cm-s-default .cm-header-5,
        .cm-s-default .cm-header-6 {
            color: #000000 !important; /* 標題改為黑色 */
            font-weight: normal !important;
        }
        
        /* Markdown 結構符號加粗 - 使用更廣泛的選擇器 */
        
        /* 所有可能的格式化符號類別 */
        .cm-s-default .cm-formatting,
        .cm-s-default .cm-formatting-header,
        .cm-s-default .cm-formatting-quote,
        .cm-s-default .cm-formatting-list,
        .cm-s-default .cm-formatting-list-ul,
        .cm-s-default .cm-formatting-list-ol,
        .cm-s-default .cm-header-1:first-child,
        .cm-s-default .cm-header-2:first-child,
        .cm-s-default .cm-header-3:first-child,
        .cm-s-default .cm-header-4:first-child,
        .cm-s-default .cm-header-5:first-child,
        .cm-s-default .cm-header-6:first-child {
            font-weight: bold !important;
            color: #000000 !important;
        }
        
        /* 針對引用符號 */
        .cm-s-default .cm-quote:first-child {
            font-weight: bold !important;
        }
        
        /* 針對列表符號 */
        .cm-s-default .cm-variable-2:first-child,
        .cm-s-default .cm-variable-3:first-child {
            font-weight: bold !important;
        }
        
        /* 確保內容本身保持正常字重 */
        .cm-s-default .cm-header,
        .cm-s-default .cm-quote,
        .cm-s-default .cm-variable-2,
        .cm-s-default .cm-variable-3 {
            color: #000000 !important;
            font-weight: normal !important;
        }
        
        /* 結構符號加粗樣式 */
        .bold-structural-symbol {
            font-weight: bold !important;
            color: #000000 !important;
        }
        
        .cm-s-default .cm-atom {
            color: #000000 !important; /* 一般文字改為黑色 */
        }
        
        .cm-s-default .cm-def {
            color: #000000 !important; /* 定義改為黑色 */
        }
        
        .cm-s-default .cm-meta {
            color: #000000 !important; /* meta 標籤改為黑色 */
        }
        
        .cm-s-default .cm-link {
            color: #000000 !important; /* 連結文字改為黑色 */
        }
        
        .cm-s-default .cm-url {
            color: #000000 !important; /* URL 改為黑色 */
        }
        
        /* 保留特殊樣式 */
        .cm-s-default .cm-strong {
            color: #000000 !important; /* 粗體保持黑色且粗體 */
            font-weight: bold !important;
        }
        
        .cm-s-default .cm-code {
            color: #dc3545 !important; /* 內聯程式碼改為淺紅色 */
            background-color: #f8f9fa !important;
            padding: 1px 3px !important;
            border-radius: 3px !important;
        }
        
        .cm-s-default .cm-comment {
            color: #6c757d !important; /* 程式碼區塊改為灰色 */
            font-style: normal !important;
        }
        
        /* TODO 項目樣式 */
        .cm-s-default .cm-variable:has(+ .cm-variable-2):first-child {
            color: #000000 !important; /* 未完成的 TODO 保持黑色 */
        }
        
        /* 已完成的 TODO - 透過檢查行內容 */
        .CodeMirror-line:has([class*="cm-variable"]) {
            color: inherit;
        }
        
        /* 使用 JavaScript 動態處理已完成的 TODO */
        .completed-todo {
            color: #6c757d !important; /* 已完成的 TODO 改為灰色 */
            text-decoration: line-through !important;
        }
        
        
        /* 列表符號保持黑色 */
        .cm-s-default .cm-variable-2 {
            color: #000000 !important;
        }
        
        /* 確保基本文字為黑色 */
        .cm-s-default .cm-variable {
            color: #000000 !important;
        }
        
        .cm-s-default {
            color: #000000 !important; /* 基礎文字顏色 */
        }
        
        /* 刪除線樣式 */
        .cm-s-default .cm-strikethrough {
            text-decoration: line-through !important;
            color: #6c757d !important;
        }
        
        /* 隱藏的 Markdown 語法符號 */
        .hidden-markdown-syntax {
            display: none !important;
        }
        
        /* CodeMirror 編輯器底部空白區域 - 讓最後一行可以滾動到頂端 */
        .CodeMirror-code::after {
            content: '';
            display: block;
            height: 70vh; /* 添加底部空白，約為視窗高度的70% */
            width: 100%;
        }
        
        /* 確保編輯器可以正常滾動 */
        .CodeMirror {
            height: 100% !important;
        }
        
        .CodeMirror-scroll {
            overflow-y: auto !important;
            padding-bottom: 0 !important;
        }
        
        /* Hashtag highlighting in editor */
        .cm-hashtag-existing {
            background-color: rgba(135, 206, 235, 0.3) !important; /* 淺藍色背景 */
            border-radius: 3px !important;
            padding: 1px 2px !important;
        }
    </style>
</head>
<body>
    <input type="file" id="file-input" multiple accept=".md,.markdown,.txt" style="display:none;">
    <input type="file" id="workspace-input" accept=".json" style="display:none;">

    <!-- Wiki Preview Popup -->
    <div id="wiki-preview-popup" class="wiki-preview-popup">
        <div class="preview-title" id="wiki-preview-title"></div>
        <div class="preview-content" id="wiki-preview-content"></div>
    </div>
    

    <div class="container" id="main-container">
        <!-- Sidebar Panel -->
        <div id="file-panel" class="file-panel collapsed">
            <div class="file-panel-header">
                <div class="sidebar-controls">
                    <button id="view-mode-toggle" title="切換檢視模式">F</button>
                    <button id="sort-files-btn" title="檔案排序"><i class="fas fa-sort"></i></button>
                    
                    <!-- 同步分享下拉選單 -->
                    <div class="dropdown-container">
                        <button class="dropdown-btn" id="sync-share-dropdown" title="同步與分享功能">
                            <i class="fas fa-cloud"></i> <i class="fas fa-chevron-down"></i>
                        </button>
                        <div class="dropdown-menu" id="sync-share-menu">
                            <div class="dropdown-item" id="sidebar-sync-to-cloud">
                                <i class="fas fa-cloud-upload-alt"></i> 同步到雲端
                            </div>
                            <div class="dropdown-item" id="sidebar-load-from-cloud">
                                <i class="fas fa-cloud-download-alt"></i> 從雲端載入
                            </div>
                            <div class="dropdown-item" id="sidebar-publish-share">
                                <i class="fas fa-globe"></i> 發布分享頁面
                            </div>
                            <div class="dropdown-item" id="sidebar-sync-settings">
                                <i class="fas fa-cog"></i> 同步設定
                            </div>
                        </div>
                    </div>
                    
                    <!-- 工作區管理下拉選單 -->
                    <div class="dropdown-container">
                        <button class="dropdown-btn" id="workspace-dropdown" title="工作區管理功能">
                            <i class="fas fa-folder"></i> <i class="fas fa-chevron-down"></i>
                        </button>
                        <div class="dropdown-menu" id="workspace-menu">
                            <div class="dropdown-item" id="sidebar-export-workspace">
                                <i class="fas fa-download"></i> 匯出工作區
                            </div>
                            <div class="dropdown-item" id="sidebar-import-workspace">
                                <i class="fas fa-upload"></i> 匯入工作區
                            </div>
                        </div>
                    </div>
                    
                    <button id="close-file-panel" title="關閉側邊欄"><i class="fas fa-times"></i></button>
                </div>
            </div>
            <div class="file-list sidebar-content-panel" id="file-list">
                <!-- File items will be dynamically added here -->
            </div>
            <div class="toc-container sidebar-content-panel" id="toc-container" style="display: none;">
                <div class="toc-list" id="toc-list">
                    <!-- TOC items will be dynamically added here -->
                </div>
            </div>
        </div>
        
        <div class="main-panel">
            <div class="toolbar">
                <button id="sidebar-toggle"><i class="fas fa-bars"></i> <span class="btn-text"></span></button>
                <button id="mobile-view-toggle" title="切換檢視模式"><i class="fas fa-eye"></i></button>
                <button id="timer-btn" class="timer-btn"><i class="fas fa-clock"></i> <span id="timer-display">00:00</span></button>
                <button id="font-settings-btn"><i class="fas fa-text-height"></i> <span id="current-font-size">22px</span></button>
                <button id="shortcuts-help-btn" title="快捷鍵說明"><i class="fas fa-keyboard"></i></button>
                
                <!-- View Mode Toggle Buttons -->
                <button id="split-view-btn" class="view-mode-toolbar-btn active" title="編輯/渲染模式"><i class="fas fa-columns"></i></button>
                <button id="edit-only-btn" class="view-mode-toolbar-btn" title="純編輯模式"><i class="fas fa-edit"></i></button>
                <button id="preview-only-btn" class="view-mode-toolbar-btn" title="純渲染模式"><i class="fas fa-eye"></i></button>
                <button id="drawing-mode-btn" class="view-mode-toolbar-btn" title="繪圖模式"><i class="fas fa-draw-polygon"></i></button>
                
                <div style="margin-left: auto;"></div>
                <button id="export-md-btn"><i class="fas fa-file-text"></i>MD</button>
                <button id="export-html-btn"><i class="fas fa-file-code"></i>HTML</button>
                <button id="presentation-toggle-btn"><i class="fas fa-presentation-screen"></i>PPT</button>
				<button id="search-toggle-btn"><i class="fas fa-search"></i>搜尋</button>
            </div>

            <!-- Search Bar -->
            <div id="search-bar" class="search-bar">
                <div class="search-bar-row-1">
                    <input type="text" id="search-input" placeholder="搜尋..." title="多個關鍵字請用空白分隔 (AND 邏輯)" />
                </div>
                <div class="search-bar-row-2">
                    <span id="search-match-count" class="search-match-count">0 / 0</span>
                    <button id="search-prev-btn" title="上一個">上</button>
                    <button id="search-next-btn" title="下一個">下</button>
                    <button id="search-scope-toggle" title="切換搜尋範圍 (當前檔案/所有檔案)">當前檔案</button>
                    <button id="search-tag-filter-btn" title="標籤過濾" style="display: none;">標籤</button>
                    <button id="search-close-btn" title="關閉搜尋 (Esc)">X</button>
                </div>
            </div>
            <!-- End Search Bar -->

            <div class="main-editor-content">
                <div class="editor-panel" id="editor-panel">
                    <div class="editor-header">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div><i class="fas fa-edit"></i> <span id="current-file-name">新筆記</span></div>
                            <div style="display: flex; gap: 5px;">
                                <button id="editor-new-file-btn" class="fold-toggle-btn" title="新增檔案">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <button id="editor-open-files-btn" class="fold-toggle-btn" title="開啟新檔">
                                    <i class="fas fa-folder-open"></i>
                                </button>
                                <button id="share-file-btn" class="fold-toggle-btn" title="分享此檔案">
                                    <i class="fas fa-share-alt"></i>
                                </button>
                                <button id="sync-scroll-toggle" class="fold-toggle-btn" title="同步滾動" style="display: none;">
                                    <i class="fas fa-sync"></i>
                                </button>
                                <button id="fold-all-btn" class="fold-toggle-btn" title="收摺所有標題">
                                    <i class="fas fa-compress"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="editor-container"><textarea id="editor"></textarea></div>
                </div>
                <div class="preview-panel" id="preview-panel">
                    <div class="preview-header"><i class="fas fa-eye"></i> 預覽</div>
                    <div class="preview-container"><div id="preview" class="markdown-body"></div></div>
                </div>
                
                <!-- Resizable divider for drawing mode -->
                <div class="panel-divider" id="panel-divider" style="display: none;">
                    <div class="divider-handle">
                        <i class="fas fa-grip-lines-vertical"></i>
                    </div>
                </div>
                
                <div class="drawing-panel" id="drawing-panel" style="display: none;">
                    <div class="drawing-header">
                        <i class="fas fa-draw-polygon"></i> 繪圖工具
                        <div class="drawing-controls">
                            <div class="tool-group">
                                <button id="save-drawing-btn" class="drawing-tool-btn" title="保存繪圖到編輯器">
                                    <i class="fas fa-save"></i>
                                </button>
                                <button id="export-drawing-btn" class="drawing-tool-btn" title="匯出PNG圖片">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button id="generate-mermaid-btn" class="drawing-tool-btn" title="生成Mermaid代碼">
                                    <i class="fas fa-code"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="excalidraw-container" id="excalidraw-container">
                        <!-- Excalidraw will be mounted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    

    <!-- Timer History Modal -->
    <div id="timer-modal" class="modal">
        <div class="modal-content timer-modal-content">
            <span class="close-btn" id="close-timer-btn">&times;</span>
            <h2><i class="fas fa-clock"></i> 任務計時記錄</h2>
            
            <div class="timer-modal-header">
                <div class="date-picker-container">
                    <input type="date" id="date-picker" />
                    <button id="today-btn">今天</button>
                </div>
                <div class="timer-controls">
                    <input type="text" id="modal-task-input" placeholder="輸入任務名稱..." />
                    <button id="modal-start-btn"><i class="fas fa-play"></i></button>
                    <button id="modal-stop-btn" disabled><i class="fas fa-stop"></i></button>
                </div>
                <div class="timer-actions">
                    <button id="modal-auto-timer-toggle" class="auto-timer-btn active"><i class="fas fa-magic"></i> 自動計時</button>
                    <button id="modal-export-csv-btn" class="export-btn"><i class="fas fa-file-csv"></i> 匯出CSV</button>
                    <button id="modal-insert-gantt-btn" class="export-btn"><i class="fas fa-project-diagram"></i> 匯入今日甘特圖</button>
                </div>
            </div>
            
            <div class="timer-view-tabs">
                <button id="timeline-tab-btn" class="tab-btn active">時間軸</button>
                <button id="chart-tab-btn" class="tab-btn">圓餅圖</button>
            </div>
            
            <div class="timeline-container" id="timeline-container">
                <div id="timeline-view"></div>
            </div>
            
            <div class="chart-container" id="chart-container" style="display: none;">
                <div class="chart-controls">
                    <label>視角層級：</label>
                    <select id="chart-level-select">
                        <option value="file">文件</option>
                        <option value="level1">第一層標題</option>
                        <option value="level2">第二層標題</option>
                        <option value="level3">第三層標題</option>
                        <option value="level4">第四層標題</option>
                    </select>
                </div>
                <div id="chart-view"></div>
            </div>
            
            <div class="timer-stats">
                <div class="stat-item">
                    <span class="stat-label">總計時時間：</span>
                    <span id="total-time">00:00:00</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">任務數量：</span>
                    <span id="task-count">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Sync Settings Modal -->
    <div id="sync-settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-sync-settings-btn">&times;</span>
            <h2><i class="fas fa-cloud"></i> 雲端同步設定</h2>
            
            <div class="sync-settings-tabs">
                <button id="github-tab-btn" class="tab-btn active">GitHub Gist</button>
                <button id="webdav-tab-btn" class="tab-btn">WebDAV</button>
            </div>
            
            <div class="sync-settings-content">
                <!-- GitHub Gist 設定 -->
                <div id="github-settings" class="sync-provider-settings">
                    <div class="setting-group">
                        <label for="github-token">GitHub Personal Access Token:</label>
                        <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxxxxxx" />
                        <small>需要 'gist' 權限的 Personal Access Token</small>
                    </div>
                    <div class="setting-group">
                        <label for="gist-id">Gist ID (選填，自動同步時可留空):</label>
                        <input type="text" id="gist-id" placeholder="自動創建或輸入現有 Gist ID" />
                    </div>
                    <div class="setting-group">
                        <label>
                            <input type="checkbox" id="auto-sync" />
                            自動同步 (編輯後自動上傳)
                        </label>
                    </div>
                </div>
                
                <!-- WebDAV 設定 -->
                <div id="webdav-settings" class="sync-provider-settings" style="display: none;">
                    <div class="setting-group">
                        <label for="webdav-url">WebDAV 伺服器地址:</label>
                        <input type="url" id="webdav-url" placeholder="https://your-server.com/webdav/" />
                    </div>
                    <div class="setting-group">
                        <label for="webdav-username">使用者名稱:</label>
                        <input type="text" id="webdav-username" placeholder="username" />
                    </div>
                    <div class="setting-group">
                        <label for="webdav-password">密碼:</label>
                        <input type="password" id="webdav-password" placeholder="password" />
                    </div>
                </div>
            </div>
            
            <div class="sync-actions">
                <button id="test-connection-btn" class="sync-btn">測試連接</button>
                <button id="save-sync-settings-btn" class="sync-btn primary">儲存設定</button>
            </div>
            
            <div class="sync-status" id="sync-status"></div>
        </div>
    </div>

    <!-- Cloud Version History Modal -->
    <div id="version-history-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-version-history-btn">&times;</span>
            <h2><i class="fas fa-history"></i> 版本歷史</h2>
            
            <div class="version-list" id="version-list">
                <!-- 版本列表將動態添加 -->
            </div>
            
            <div class="version-actions">
                <button id="quick-load-latest-btn" class="version-btn primary">快速載入最新版本</button>
                <button id="refresh-versions-btn" class="version-btn">重新整理</button>
                <button id="create-backup-btn" class="version-btn">建立備份點</button>
            </div>
        </div>
    </div>

    <!-- Tag Filter Modal -->
    <div id="tag-filter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-tag-filter-btn">&times;</span>
            <h2><i class="fas fa-tags"></i> 標籤過濾</h2>
            
            <div class="tag-filter-content">
                <div class="tag-filter-info">
                    <p>選擇要搜尋的標籤範圍 (取消全選則搜尋所有文件)</p>
                </div>
                
                <div class="tag-filter-controls">
                    <button id="select-all-tags-btn" class="filter-control-btn">全選</button>
                    <button id="deselect-all-tags-btn" class="filter-control-btn">全不選</button>
                </div>
                
                <div class="tag-list" id="tag-filter-list">
                    <!-- 標籤列表將動態添加 -->
                </div>
                
                <div class="tag-filter-actions">
                    <button id="apply-tag-filter-btn" class="filter-btn primary">套用過濾</button>
                    <button id="cancel-tag-filter-btn" class="filter-btn">取消</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Font Settings Modal -->
    <div id="font-settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-font-settings-btn">&times;</span>
            <h2><i class="fas fa-text-height"></i> 字體與主題設定</h2>
            
            <div class="settings-section">
                <h3><i class="fas fa-font"></i> 字體大小設定</h3>
                <div class="font-size-controls">
                    <label>編輯器與預覽字體大小:</label>
                    <div class="size-control">
                        <button id="font-size-minus">-</button>
                        <span id="font-size-display">22px</span>
                        <button id="font-size-plus">+</button>
                        <input type="range" id="font-size-slider" min="12" max="32" value="22" step="1">
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h3><i class="fas fa-palette"></i> 編輯器主題</h3>
                <div class="theme-buttons">
                    <button class="theme-btn active" data-theme="default">預設</button>
                    <button class="theme-btn" data-theme="monokai">Monokai</button>
                    <button class="theme-btn" data-theme="solarized dark">Solarized Dark</button>
                    <button class="theme-btn" data-theme="material">Material</button>
                    <button class="theme-btn" data-theme="dracula">Dracula</button>
                    <button class="theme-btn" data-theme="github">GitHub</button>
                </div>
            </div>
            
            <div class="settings-actions">
                <button id="reset-settings-btn"><i class="fas fa-undo"></i> 重置為預設</button>
                <button id="apply-settings-btn"><i class="fas fa-check"></i> 套用設定</button>
            </div>
        </div>
    </div>

    <!-- Shortcuts Help Modal -->
    <div id="shortcuts-help-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-shortcuts-help-btn">&times;</span>
            <h2><i class="fas fa-keyboard"></i> Markdown 快捷鍵說明</h2>
            
            <div class="shortcuts-grid">
                <div class="shortcuts-section">
                    <h3><i class="fas fa-font"></i> 文字格式</h3>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>B</kbd>
                        <span>粗體</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>I</kbd>
                        <span>斜體</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>U</kbd>
                        <span>下劃線</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>D</kbd>
                        <span>刪除線</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>`</kbd>
                        <span>行內程式碼</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>`</kbd>
                        <span>程式碼區塊</span>
                    </div>
                </div>
                
                <div class="shortcuts-section">
                    <h3><i class="fas fa-heading"></i> 標題</h3>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>1</kbd>
                        <span>標題 1</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>2</kbd>
                        <span>標題 2</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>3</kbd>
                        <span>標題 3</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>4</kbd>
                        <span>標題 4</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>5</kbd>
                        <span>標題 5</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>6</kbd>
                        <span>標題 6</span>
                    </div>
                </div>
                
                <div class="shortcuts-section">
                    <h3><i class="fas fa-list"></i> 列表與其他 (待開發)</h3>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>
                        <span>無序列表</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd>
                        <span>有序列表</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>
                        <span>待辦事項</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Q</kbd>
                        <span>引用</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>K</kbd>
                        <span>連結</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd>
                        <span>表格</span>
                    </div>
                </div>
                
                <div class="shortcuts-section">
                    <h3><i class="fas fa-cogs"></i> 系統功能 (待開發)</h3>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>N</kbd>
                        <span>新建檔案</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>O</kbd>
                        <span>開啟檔案面板</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>Ctrl</kbd> + <kbd>F</kbd>
                        <span>搜尋</span>
                    </div>
                    <div class="shortcut-item">
                        <kbd>F11</kbd>
                        <span>簡報模式</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Presentation Mode -->
    <div id="presentation-mode" class="presentation-mode">
        <div class="presentation-toolbar-hotspot"></div>
        <div class="presentation-toolbar">
            <button id="prev-slide-btn"><i class="fas fa-chevron-left"></i></button>
            <button id="next-slide-btn"><i class="fas fa-chevron-right"></i></button>
            <button id="export-presentation-html-btn"><i class="fas fa-download"></i> 導出HTML</button>
            <button id="exit-presentation-btn"><i class="fas fa-times"></i> 退出簡報</button>
        </div>
        <div class="reveal">
            <div class="slides" id="presentation-slides">
                <!-- Slides will be generated here -->
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="lib/codemirror/codemirror.min.js"></script>
    <script src="lib/codemirror/mode/markdown/markdown.min.js"></script>
    <script src="lib/codemirror/addon/fold/foldcode.min.js"></script>
    <script src="lib/codemirror/addon/fold/foldgutter.min.js"></script>
    <script src="lib/codemirror/addon/fold/markdown-fold.min.js"></script>
    <script src="lib/codemirror/addon/fold/xml-fold.min.js"></script>
    <script src="lib/codemirror/addon/fold/indent-fold.min.js"></script>
    <script src="lib/marked/marked.min.js"></script>
    <script src="lib/highlight.js/highlight.min.js"></script>
    <!-- 添加更多語言支援 -->
    <script src="lib/highlight.js/languages/python.min.js"></script>
    <script src="lib/highlight.js/languages/javascript.min.js"></script>
    <script src="lib/highlight.js/languages/java.min.js"></script>
    <script src="lib/highlight.js/languages/cpp.min.js"></script>
    <script src="lib/highlight.js/languages/csharp.min.js"></script>
    <script src="lib/highlight.js/languages/php.min.js"></script>
    <script src="lib/highlight.js/languages/go.min.js"></script>
    <script src="lib/highlight.js/languages/rust.min.js"></script>
    <script src="lib/highlight.js/languages/sql.min.js"></script>
    <script src="lib/highlight.js/languages/bash.min.js"></script>
    <script src="lib/highlight.js/languages/json.min.js"></script>
    <script src="lib/highlight.js/languages/xml.min.js"></script>
    <script src="lib/highlight.js/languages/css.min.js"></script>
    <script src="lib/highlight.js/languages/typescript.min.js"></script>
    <script src="lib/mermaid/mermaid.min.js"></script>
    
    <!-- KaTeX for math formulas -->
    <script src="lib/katex/katex.min.js"></script>
    <script src="lib/katex/auto-render.min.js"></script>
    
    <script src="lib/jspdf/jspdf.umd.min.js"></script>
    
    <!-- React dependencies for Excalidraw -->
    <script src="lib/excalidraw/react.production.min.js"></script>
    <script src="lib/excalidraw/react-dom.production.min.js"></script>
    <script src="lib/excalidraw/excalidraw.production.min.js"></script>

    <!-- CodeMirror Search Addons -->
    <script src="lib/codemirror/addon/search/searchcursor.min.js"></script>
    <script src="lib/codemirror/addon/search/search.min.js"></script>
    <script src="lib/codemirror/addon/dialog/dialog.min.js"></script>
    <link rel="stylesheet" href="lib/codemirror/addon/dialog/dialog.min.css">

    <!-- Reveal.js for presentations -->
    <link rel="stylesheet" href="lib/reveal.js/reveal.css">
    <link rel="stylesheet" href="lib/reveal.js/theme/white.css">
    <script src="lib/reveal.js/reveal.js"></script>
    
    <script>
        // --- Full Application Logic 2.1 (with Scroll Sync) ---
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化highlight.js
            hljs.configure({
                ignoreUnescapedHTML: true,
                languages: ['python', 'javascript', 'java', 'cpp', 'csharp', 'php', 'go', 'rust', 'sql', 'bash', 'json', 'xml', 'css', 'typescript']
            });
            
            // Global state
            let tasks = [], currentTask = null, isTimerRunning = false;
            let files = [], currentFile = null;
            let pinnedFiles = new Set(); // 儲存釘選的檔案ID
            
            // Hashtag tracking
            let fileHashtagSnapshots = new Map(); // 存儲每個檔案的 hashtag 快照
            let hashtagSyncTimer = null; // 延遲同步計時器
            let editor;
            let isSyncing = false; // Prevents scroll event loops
            let autoTimerEnabled = true; // 自動計時功能開關
            let currentViewMode = 'split'; // split, edit-only, preview-only
            let hashtagUpdateTimer = null; // Timer for hashtag auto-update
            let originalHashtags = new Map(); // Store original hashtag mappings
            let autocompleteDropdown = null;
            
            // Helper function to safely convert time to string
            function safeTimeToString(timeValue) {
                try {
                    if (!timeValue) return '00:00';
                    
                    // If it's already a Date object
                    if (timeValue instanceof Date) {
                        return timeValue.toTimeString().substring(0, 5);
                    }
                    
                    // If it's a string that might be a time
                    if (typeof timeValue === 'string') {
                        // Try to parse as Date first
                        const date = new Date(timeValue);
                        if (!isNaN(date.getTime())) {
                            return date.toTimeString().substring(0, 5);
                        }
                        // If it's already in HH:MM format, return as is
                        if (/^\d{2}:\d{2}$/.test(timeValue)) {
                            return timeValue;
                        }
                    }
                    
                    // If it's a number (timestamp)
                    if (typeof timeValue === 'number') {
                        const date = new Date(timeValue);
                        return date.toTimeString().substring(0, 5);
                    }
                    
                    return '00:00';
                } catch (error) {
                    console.warn('Error converting time:', timeValue, error);
                    return '00:00';
                }
            }

            // Cloud Sync Management
            let syncManager = null;
            let syncSettings = {
                provider: 'github', // 'github' or 'webdav'
                github: {
                    token: '',
                    gistId: '',
                    autoSync: false
                },
                webdav: {
                    url: '',
                    username: '',
                    password: ''
                }
            };
            let autocompleteSelectedIndex = -1;
            
            // Sync scroll functionality
            let syncScrollEnabled = true; // Enable by default for testing
            let syncScrollIgnoreNext = false;
            
            // Font and theme settings
            let currentFontSize = 22;
            let currentEditorTheme = 'default';

            // Fold state for headers
            let isAllHeadersFolded = false;

            // Search related variables
            let searchBar = null;
            let searchInput = null;
            let searchPrevBtn = null;
            let searchNextBtn = null;
            let searchScopeToggle = null;
            let searchCloseBtn = null;
            let searchMatchCount = null;
			let searchToggleButton = null; // 搜尋切換按鈕的引用

            let allSearchResults = []; // Stores { fileId, from, to } for all files
            let currentHighlightedMarkers = []; // CodeMirror TextMarker objects for all matches
            let currentMatchMarker = null; // CodeMirror TextMarker for the currently focused match
            let currentSearchMatchIndex = -1;
            let currentSearchScope = 'current'; // 'current' or 'all'
            let searchKeywords = []; // Array of strings for multi-keyword search
            let selectedTags = new Set(); // Set of selected tag names for filtering
            let availableTags = []; // Array of available tags from NoteTag.md

            // DOM Elements
            const mainContainer = document.getElementById('main-container');
            const filePanel = document.getElementById('file-panel');
            const sidebarToggle = document.getElementById('sidebar-toggle');
            const viewModeToggle = document.getElementById('view-mode-toggle');
            const mobileViewToggle = document.getElementById('mobile-view-toggle');
            
            // Separate states
            let sidebarVisible = false;
            let viewMode = 'files'; // 'files', 'toc', 'dual'
            let mobileViewMode = 'edit'; // 'edit', 'preview' for mobile
            const closeFilePanelBtn = document.getElementById('close-file-panel');
            const newFileBtn = document.getElementById('new-file-btn');
            
            // Editor toolbar buttons
            const editorNewFileBtn = document.getElementById('editor-new-file-btn');
            const editorOpenFilesBtn = document.getElementById('editor-open-files-btn');
            const previewContainer = document.querySelector('.preview-container');
            const timerModal = document.getElementById('timer-modal');
            const fontSettingsModal = document.getElementById('font-settings-modal');
            const allButtons = document.querySelectorAll('button'); // For event delegation
            const fileListEl = document.getElementById('file-list');
            const tocListEl = document.getElementById('toc-list');
            const fileInput = document.getElementById('file-input');
            const workspaceInput = document.getElementById('workspace-input');
            const exportWorkspaceBtn = document.getElementById('export-workspace-btn');
            const importWorkspaceBtn = document.getElementById('import-workspace-btn');
            const currentFileNameEl = document.getElementById('current-file-name');

            // Search Bar Elements
            searchBar = document.getElementById('search-bar');
            searchInput = document.getElementById('search-input');
            searchPrevBtn = document.getElementById('search-prev-btn');
            searchNextBtn = document.getElementById('search-next-btn');
            searchScopeToggle = document.getElementById('search-scope-toggle');
            searchCloseBtn = document.getElementById('search-close-btn');
            searchMatchCount = document.getElementById('search-match-count');
			searchToggleButton = document.getElementById('search-toggle-btn'); // 獲取按鈕引用
            searchTagFilterBtn = document.getElementById('search-tag-filter-btn');
            
            // Tag Filter Modal Elements
            const tagFilterModal = document.getElementById('tag-filter-modal');
            const closeTagFilterBtn = document.getElementById('close-tag-filter-btn');
            const tagFilterList = document.getElementById('tag-filter-list');
            const selectAllTagsBtn = document.getElementById('select-all-tags-btn');
            const deselectAllTagsBtn = document.getElementById('deselect-all-tags-btn');
            const applyTagFilterBtn = document.getElementById('apply-tag-filter-btn');
            const cancelTagFilterBtn = document.getElementById('cancel-tag-filter-btn');
            
            // Sync Modal Elements
            const syncSettingsModal = document.getElementById('sync-settings-modal');
            const versionHistoryModal = document.getElementById('version-history-modal');
            const syncToCloudBtn = document.getElementById('sync-to-cloud-btn');
            const loadFromCloudBtn = document.getElementById('load-from-cloud-btn');
            const syncSettingsBtn = document.getElementById('sync-settings-btn');
            
            // Cloud Sync Manager Class
            class CloudSyncManager {
                constructor() {
                    this.apiUrl = 'https://api.github.com';
                    this.versions = [];
                }
                
                async syncToGist() {
                    const { token, gistId } = syncSettings.github;
                    if (!token) {
                        throw new Error('GitHub token 未設定');
                    }
                    
                    const workspace = await this.exportSyncFilteredWorkspace();
                    const gistData = {
                        description: `PowerNote Workspace - ${new Date().toLocaleString()}`,
                        public: false,
                        files: {
                            'powernote-workspace.json': {
                                content: JSON.stringify(workspace, null, 2)
                            }
                        }
                    };
                    
                    const headers = {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    };
                    
                    let response;
                    if (gistId) {
                        // Update existing gist
                        response = await fetch(`${this.apiUrl}/gists/${gistId}`, {
                            method: 'PATCH',
                            headers,
                            body: JSON.stringify(gistData)
                        });
                    } else {
                        // Create new gist
                        response = await fetch(`${this.apiUrl}/gists`, {
                            method: 'POST',
                            headers,
                            body: JSON.stringify(gistData)
                        });
                    }
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`GitHub API Error: ${error.message}`);
                    }
                    
                    const result = await response.json();
                    
                    // Save gist ID if it's a new gist
                    if (!gistId) {
                        syncSettings.github.gistId = result.id;
                        await this.saveSyncSettings();
                    }
                    
                    return result;
                }
                
                async loadFromGist(gistId = null, version = null, useMergeMode = true) {
                    const { token } = syncSettings.github;
                    const targetGistId = gistId || syncSettings.github.gistId;
                    
                    if (!token || !targetGistId) {
                        throw new Error('GitHub token 或 Gist ID 未設定');
                    }
                    
                    const headers = {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    };
                    
                    let url = `${this.apiUrl}/gists/${targetGistId}`;
                    if (version) {
                        url += `/${version}`;
                    }
                    
                    const response = await fetch(url, { headers });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`GitHub API Error: ${error.message}`);
                    }
                    
                    const gist = await response.json();
                    const workspaceFile = gist.files['powernote-workspace.json'];
                    
                    if (!workspaceFile) {
                        throw new Error('工作區檔案不存在');
                    }
                    
                    const workspace = JSON.parse(workspaceFile.content);
                    await this.importWorkspace(workspace, useMergeMode); // 使用指定的模式
                    
                    return gist;
                }
                
                async getVersionHistory(gistId = null) {
                    const { token } = syncSettings.github;
                    const targetGistId = gistId || syncSettings.github.gistId;
                    
                    if (!token || !targetGistId) {
                        throw new Error('GitHub token 或 Gist ID 未設定');
                    }
                    
                    const headers = {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    };
                    
                    const response = await fetch(`${this.apiUrl}/gists/${targetGistId}/commits`, { headers });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`GitHub API Error: ${error.message}`);
                    }
                    
                    return await response.json();
                }
                
                async exportCurrentWorkspace() {
                    await updateNoteTaskFile();
                    const workspace = {
                        version: '2.0',
                        exportDate: new Date().toISOString(),
                        files: files.map(file => ({
                            ...file,
                            exportedAt: new Date().getTime()
                        })),
                        tasks: tasks,
                        timerHistory: timerHistory,
                        syncSettings: {
                            provider: syncSettings.provider,
                            lastSync: new Date().toISOString()
                        }
                    };
                    return workspace;
                }
                
                // 獲取NoteTag.md中標記為UNSYNC的檔案列表
                getUnsyncFilesFromNoteTag(filesList = null) {
                    // 使用傳入的檔案列表，或者全域的files變數
                    const currentFiles = filesList || (typeof files !== 'undefined' ? files : []);
                    const noteTagFile = currentFiles.find(f => f.name === 'NoteTag.md');
                    if (!noteTagFile || !noteTagFile.content) return new Set();
                    
                    const unsyncFiles = new Set();
                    const lines = noteTagFile.content.split('\n');
                    let inUnsyncSection = false;
                    
                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        
                        // 檢查是否進入UNSYNC區段
                        if (trimmedLine === '### UNSYNC') {
                            inUnsyncSection = true;
                            continue;
                        }
                        
                        // 檢查是否離開UNSYNC區段（遇到其他標題）
                        if (trimmedLine.startsWith('### ') && trimmedLine !== '### UNSYNC') {
                            inUnsyncSection = false;
                            continue;
                        }
                        
                        // 如果在UNSYNC區段中，提取檔案連結
                        if (inUnsyncSection && trimmedLine.includes('[[') && trimmedLine.includes(']]')) {
                            const matches = trimmedLine.match(/\[\[([^\]]+)\]\]/g);
                            if (matches) {
                                matches.forEach(match => {
                                    // 提取檔案名稱，去掉.md擴展名（如果有的話）
                                    let fileName = match.slice(2, -2); // 移除 [[ 和 ]]
                                    if (fileName.includes('#')) {
                                        fileName = fileName.split('#')[0]; // 移除段落引用
                                    }
                                    if (!fileName.endsWith('.md')) {
                                        fileName += '.md'; // 確保有.md擴展名
                                    }
                                    unsyncFiles.add(fileName);
                                });
                            }
                        }
                    }
                    
                    return unsyncFiles;
                }

                // 檢查檔案是否在NoteTag.md中被標記為UNSYNC (用於視覺顯示橘色框)
                isUnsyncInNoteTag(file, filesList = null) {
                    if (!file.name) return false;
                    
                    // 從NoteTag.md獲取UNSYNC檔案列表
                    const unsyncFiles = this.getUnsyncFilesFromNoteTag(filesList);
                    
                    // 只根據NoteTag.md中的標記來判斷
                    return unsyncFiles.has(file.name);
                }

                // 檢查檔案是否包含 #UNSYNC 標籤 (不同步) - 用於同步邏輯
                hasUnsyncTag(file, filesList = null) {
                    if (!file.name) return false;
                    
                    // 優先檢查NoteTag.md中的標記
                    const unsyncFiles = this.getUnsyncFilesFromNoteTag(filesList);
                    if (unsyncFiles.has(file.name)) {
                        return true;
                    }
                    
                    // 同時檢查檔案內容中的#UNSYNC標籤（用於同步邏輯）
                    if (!file.content) return false;
                    return file.content.includes('#UNSYNC');
                }
                
                // 檢查檔案是否包含 #SHARE 標籤 (可分享)
                hasShareTag(file) {
                    if (!file.content) return false;
                    return file.content.includes('#SHARE');
                }
                
                // 檢查是否為系統配置檔案
                isSystemFile(file) {
                    const systemFileNames = [
                        'NoteTag.md',
                        'NoteConfig.md', 
                        'NoteTask.md'
                    ];
                    return systemFileNames.includes(file.name);
                }
                
                // 導出所有檔案，但排除包含 #UNSYNC 標籤的檔案
                async exportSyncFilteredWorkspace() {
                    await updateNoteTaskFile();
                    
                    // 過濾檔案：排除含有 #UNSYNC 標籤的檔案
                    const filteredFiles = files.filter(file => 
                        !this.hasUnsyncTag(file, files)
                    );
                    
                    const workspace = {
                        version: '2.0',
                        exportDate: new Date().toISOString(),
                        files: filteredFiles.map(file => ({
                            ...file,
                            exportedAt: new Date().getTime()
                        })),
                        tasks: tasks,
                        timerHistory: timerHistory,
                        syncSettings: {
                            provider: syncSettings.provider,
                            lastSync: new Date().toISOString()
                        }
                    };
                    return workspace;
                }
                
                async importWorkspace(workspace, mergeMode = false) {
                    if (workspace.files && Array.isArray(workspace.files)) {
                        if (mergeMode) {
                            // 合併模式：更新現有筆記，新增不存在的筆記，保留UNSYNC筆記
                            const existingFiles = [...files]; // 保留原有檔案列表的副本
                            const existingFileMap = new Map(existingFiles.map(file => [file.id, file]));
                            
                            // 處理從雲端/工作區匯入的檔案
                            workspace.files.forEach(importedFile => {
                                const normalizedFile = {
                                    ...importedFile,
                                    id: importedFile.id || this.generateFileId(),
                                    name: importedFile.name || 'untitled.md',
                                    content: importedFile.content || '',
                                    lastModified: new Date(importedFile.lastModified || Date.now())
                                };
                                
                                if (existingFileMap.has(normalizedFile.id)) {
                                    // 更新現有檔案（只有當本地檔案不是UNSYNC時）
                                    const existingFile = existingFileMap.get(normalizedFile.id);
                                    if (!this.hasUnsyncTag(existingFile, existingFiles)) {
                                        existingFileMap.set(normalizedFile.id, normalizedFile);
                                    }
                                    // 如果是UNSYNC檔案，保持原狀不更新
                                } else {
                                    // 新增不存在的檔案
                                    existingFileMap.set(normalizedFile.id, normalizedFile);
                                }
                            });
                            
                            // 更新files陣列
                            files = Array.from(existingFileMap.values());
                        } else {
                            // 原有的覆蓋模式
                            files = workspace.files.map(file => ({
                                ...file,
                                id: file.id || this.generateFileId(),
                                name: file.name || 'untitled.md',
                                content: file.content || '',
                                lastModified: new Date(file.lastModified || Date.now())
                            }));
                        }
                    }
                    
                    if (workspace.tasks && Array.isArray(workspace.tasks)) {
                        tasks = workspace.tasks.map(task => ({
                            ...task,
                            startTime: task.startTime ? new Date(task.startTime) : null,
                            endTime: task.endTime ? new Date(task.endTime) : null,
                            duration: task.duration || 0
                        }));
                    }
                    
                    if (workspace.timerHistory) {
                        // Process timerHistory to ensure dates are properly converted
                        const processedHistory = {};
                        for (const [date, tasks] of Object.entries(workspace.timerHistory)) {
                            processedHistory[date] = tasks.map(task => ({
                                ...task,
                                startTime: task.startTime ? new Date(task.startTime) : null,
                                endTime: task.endTime ? new Date(task.endTime) : null,
                                duration: task.duration || 0
                            }));
                        }
                        Object.assign(timerHistory, processedHistory);
                    }
                    
                    await saveDataToStorage();
                    renderFileList();
                    
                    if (files.length > 0) {
                        loadFile(files[0].id);
                    }
                }
                
                generateFileId() {
                    return 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                }
                
                // 生成靜態HTML頁面用於分享
                generateStaticHTML(file) {
                    if (!file || !file.content) return null;
                    
                    // 移除 #SHARE 標籤，避免在分享頁面中顯示
                    const cleanContent = file.content.replace(/#SHARE\s*/g, '');
                    
                    // 使用 marked 渲染 Markdown
                    const htmlContent = marked.parse(cleanContent);
                    
                    // 獲取文章標題（第一個 # 標題或檔案名）
                    const titleMatch = cleanContent.match(/^#\s+(.+)$/m);
                    const title = titleMatch ? titleMatch[1] : file.name.replace('.md', '');
                    
                    // 生成完整的HTML頁面
                    const staticHTML = `<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title} - PowerNote 分享</title>
    <meta name="description" content="由 PowerNote 分享的文章">
    <meta property="og:title" content="${title}">
    <meta property="og:description" content="由 PowerNote 分享的文章">
    <meta property="og:type" content="article">
    
    <!-- 樣式 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #fff;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .header .meta {
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .content {
            font-size: 16px;
        }
        
        .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 {
            margin: 1.5em 0 0.5em 0;
            color: #2c3e50;
        }
        
        .content h1 { font-size: 2em; }
        .content h2 { font-size: 1.6em; }
        .content h3 { font-size: 1.3em; }
        
        .content p {
            margin: 1em 0;
        }
        
        .content ul, .content ol {
            margin: 1em 0;
            padding-left: 2em;
        }
        
        .content li {
            margin: 0.5em 0;
        }
        
        .content blockquote {
            border-left: 4px solid #3498db;
            padding-left: 1em;
            margin: 1em 0;
            font-style: italic;
            background: #f8f9fa;
            padding: 1em;
        }
        
        .content code {
            background: #f1f2f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .content pre {
            background: #2f3640;
            color: #f5f6fa;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1em 0;
        }
        
        .content pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        
        .content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        
        .content th, .content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .content th {
            background: #f8f9fa;
            font-weight: bold;
        }
        
        .footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .powernote-badge {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            text-decoration: none;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .powernote-badge:hover {
            background: #2980b9;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            
            .content {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>${title}</h1>
        <div class="meta">
            分享時間：${new Date().toLocaleString('zh-TW')}
        </div>
    </div>
    
    <div class="content">
        ${htmlContent}
    </div>
    
    <div class="footer">
        <p>本文章由 <strong>PowerNote</strong> 生成並分享</p>
        <a href="#" class="powernote-badge">🚀 PowerNote</a>
    </div>
</body>
</html>`;
                    
                    return staticHTML;
                }
                
                // 獲取所有可分享的檔案
                getShareableFiles() {
                    return files.filter(file => this.hasShareTag(file));
                }
                
                // 生成所有分享檔案的靜態HTML (舊方法，保留備用)
                generateAllSharedHTML() {
                    const shareableFiles = this.getShareableFiles();
                    const htmlFiles = {};
                    
                    shareableFiles.forEach(file => {
                        const filename = file.name.replace('.md', '.html');
                        const html = this.generateStaticHTML(file);
                        if (html) {
                            htmlFiles[filename] = html;
                        }
                    });
                    
                    return htmlFiles;
                }
                
                // 創建公開 Gist 用於分享
                async createPublicShareGist() {
                    const { token } = syncSettings.github;
                    if (!token) {
                        throw new Error('GitHub token 未設定');
                    }
                    
                    const shareableFiles = this.getShareableFiles();
                    if (shareableFiles.length === 0) {
                        throw new Error('沒有找到含有 #SHARE 標籤的檔案');
                    }
                    
                    // 準備 Gist 檔案
                    const gistFiles = {};
                    shareableFiles.forEach(file => {
                        gistFiles[file.name] = {
                            content: file.content
                        };
                    });
                    
                    const gistData = {
                        description: `PowerNote 分享 - ${new Date().toLocaleString('zh-TW')}`,
                        public: true, // 設為公開
                        files: gistFiles
                    };
                    
                    const headers = {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    };
                    
                    console.log('Creating public share gist with files:', Object.keys(gistFiles));
                    
                    const response = await fetch(`${this.apiUrl}/gists`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(gistData)
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`建立分享 Gist 失敗: ${error.message}`);
                    }
                    
                    const result = await response.json();
                    console.log('Public share gist created:', result.id);
                    
                    return result;
                }
                
                // 生成分享連結
                generateShareLinks(gistId, files) {
                    const baseUrl = window.location.origin + window.location.pathname.replace('index.html', '') + 'shared.html';
                    const links = [];
                    
                    files.forEach(file => {
                        const shareUrl = `${baseUrl}?gist=${gistId}&file=${encodeURIComponent(file.name)}`;
                        links.push({
                            fileName: file.name,
                            title: this.extractTitle(file.content),
                            url: shareUrl
                        });
                    });
                    
                    return links;
                }
                
                // 從內容中提取標題
                extractTitle(content) {
                    if (!content) return '無標題';
                    
                    // 移除 #SHARE 標籤後再提取標題
                    const cleanContent = content.replace(/#SHARE\s*/g, '');
                    const titleMatch = cleanContent.match(/^#\s+(.+)$/m);
                    
                    return titleMatch ? titleMatch[1] : '無標題';
                }
                
                async testConnection() {
                    const { token } = syncSettings.github;
                    if (!token) {
                        throw new Error('GitHub token 未設定');
                    }
                    
                    const headers = {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    };
                    
                    const response = await fetch(`${this.apiUrl}/user`, { headers });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`連接失敗: ${error.message}`);
                    }
                    
                    const user = await response.json();
                    return user;
                }
                
                async saveSyncSettings() {
                    await saveToIndexedDB('powernote_sync_settings', syncSettings);
                }
                
                async loadSyncSettings() {
                    const saved = await loadFromIndexedDB('powernote_sync_settings');
                    if (saved) {
                        Object.assign(syncSettings, saved);
                    }
                }
            }
            
            // Timer Modal Elements
            const timerBtn = document.getElementById('timer-btn');
            const timerDisplay = document.getElementById('timer-display');
            const datePicker = document.getElementById('date-picker');
            const todayBtn = document.getElementById('today-btn');
            const modalTaskInput = document.getElementById('modal-task-input');
            const modalStartBtn = document.getElementById('modal-start-btn');
            const modalStopBtn = document.getElementById('modal-stop-btn');
            const modalAutoTimerToggle = document.getElementById('modal-auto-timer-toggle');
            const modalExportCsvBtn = document.getElementById('modal-export-csv-btn');
            const modalInsertGanttBtn = document.getElementById('modal-insert-gantt-btn');
            const timelineView = document.getElementById('timeline-view');
            const totalTimeEl = document.getElementById('total-time');
            const taskCountEl = document.getElementById('task-count');
            
            // Chart Elements
            const timelineTabBtn = document.getElementById('timeline-tab-btn');
            const chartTabBtn = document.getElementById('chart-tab-btn');
            const timelineContainer = document.getElementById('timeline-container');
            const chartContainer = document.getElementById('chart-container');
            const chartLevelSelect = document.getElementById('chart-level-select');
            const chartView = document.getElementById('chart-view');
            
            // Presentation Elements
            const presentationMode = document.getElementById('presentation-mode');
            const presentationToggleBtn = document.getElementById('presentation-toggle-btn');
            const presentationSlides = document.getElementById('presentation-slides');
            const prevSlideBtn = document.getElementById('prev-slide-btn');
            const nextSlideBtn = document.getElementById('next-slide-btn');
            const exitPresentationBtn = document.getElementById('exit-presentation-btn');
            
            // State
            let revealInstance = null;
            let isPresentationMode = false;
            
            // Timer state
            let timerHistory = {}; // { 'YYYY-MM-DD': [tasks] }
            let currentTimerStartTime = null;
            let timerInterval = null;


            // --- Initialization ---
            async function initialize() {
                initEditor();
                configureMarked();
                mermaid.initialize({ startOnLoad: false, theme: 'default' });

                await loadDataFromStorage();
                await loadSettingsFromStorage();
                
                // Initialize hashtag snapshots for all files
                files.forEach(file => {
                    initializeHashtagSnapshot(file.id);
                });
                
                // Initialize Cloud Sync Manager
                syncManager = new CloudSyncManager();
                await syncManager.loadSyncSettings();
                
                // Check for URL parameters for file sharing
                checkUrlParameters();
                
                updateCurrentTime();
                setInterval(updateCurrentTime, 1000);

                attachEventListeners();
                
                // 初始化console日誌
                console.log('PowerNote Pro 2.2 系統啟動');
                console.log(`自動計時功能：${autoTimerEnabled ? '已開啟' : '已關閉'} (觸發方式：Enter按鍵)`);
                console.log('=== 開始載入配置 ===');
                console.log('載入配置前的狀態 - currentFile:', currentFile, 'viewMode:', viewMode, 'fileSortMode:', fileSortMode);
                
                // Load configuration from NoteConfig.md FIRST, before any UI initialization
                const configLoaded = await loadConfiguration();
                
                // Initialize UI state AFTER loading configuration
                updateViewModeUI();
                updateSidebarContent();
                
                // Only set default view mode if configuration wasn't loaded
                if (!configLoaded) {
                    console.log('No configuration loaded, using default view mode');
                    // Set view mode without triggering save during initialization
                    currentViewMode = 'split';
                    // Apply view mode UI changes manually without calling setViewMode
                    const editorPanel = document.getElementById('editor-panel');
                    const previewPanel = document.getElementById('preview-panel');
                    const drawingPanel = document.getElementById('drawing-panel');
                    const splitBtn = document.getElementById('split-view-btn');
                    
                    if (editorPanel) editorPanel.style.display = 'flex';
                    if (previewPanel) previewPanel.style.display = 'flex';
                    if (drawingPanel) drawingPanel.style.display = 'none';
                    if (splitBtn) splitBtn.classList.add('active');
                    
                    // Show sync scroll button in split mode
                    const syncScrollToggle = document.getElementById('sync-scroll-toggle');
                    if (syncScrollToggle) syncScrollToggle.style.display = 'block';
                    
                    // Remove active class from other buttons
                    const editBtn = document.getElementById('edit-only-btn');
                    const previewBtn = document.getElementById('preview-only-btn');
                    const drawingBtn = document.getElementById('drawing-mode-btn');
                    [editBtn, previewBtn, drawingBtn].forEach(btn => {
                        if (btn) btn.classList.remove('active');
                    });
                }
                
                // Initialize mobile view if on mobile device
                if (isMobileDevice()) {
                    updateMobileViewUI();
                }
                console.log('=== 配置載入完成 ===', configLoaded);
                
                if (!configLoaded) {
                    // No configuration loaded, use default behavior
                    renderFileList(); // Render file list with default sorting
                    if (files.length > 0) {
                        loadFile(files[0].id);
                    } else {
                        editor.setValue(getWelcomeMessage());
                    }
                } else {
                    // Configuration was loaded successfully
                    // If no file was loaded (empty workspace), show welcome message
                    if (files.length === 0) {
                        editor.setValue(getWelcomeMessage());
                    }
                    // renderFileList() is already called in loadConfiguration()
                }
                
                // Initialize hashtag tracking after loading files
                setTimeout(() => {
                    initializeHashtagTracking();
                }, 500);
                
                // Initialize auto timer UI
                updateAutoTimerUI();
                
                // Initialize sync scroll button state
                const syncScrollToggle = document.getElementById('sync-scroll-toggle');
                if (syncScrollToggle && syncScrollEnabled) {
                    syncScrollToggle.classList.add('active');
                    syncScrollToggle.title = '同步滾動 (已開啟)';
                    console.log('Sync scroll enabled by default');
                }
                
                console.log('系統初始化完成 - 自動計時功能:', autoTimerEnabled ? '已開啟' : '已關閉');
            }

            // --- Code Folding Functions ---
            
            // Simple and safe markdown fold function
            function markdownHeaderFold(cm, start) {
                try {
                    const line = cm.getLine(start.line);
                    const trimmed = line.trim();
                    
                    console.log(`markdownHeaderFold called for line ${start.line}: "${trimmed}"`);
                    
                    // Handle headers (H2 and above only - ## or more)
                    const headerMatch = line.match(/^(#{2,6})\s/);
                    if (headerMatch) {
                        const headerLevel = headerMatch[1].length;
                        console.log(`Found header level ${headerLevel} at line ${start.line}`);
                        let end = start.line + 1;
                        
                        while (end < cm.lineCount()) {
                            const nextLine = cm.getLine(end);
                            const nextMatch = nextLine.match(/^(#{1,6})\s/);
                            
                            console.log(`Checking line ${end}: "${nextLine.trim()}"`);
                            
                            // Stop at any header that is same level or higher (including H1)
                            if (nextMatch && nextMatch[1].length <= headerLevel) {
                                console.log(`Found stopping header at line ${end}, level ${nextMatch[1].length}`);
                                break;
                            }
                            end++;
                        }
                        
                        console.log(`Header fold range: ${start.line} to ${end - 1}, total lines: ${cm.lineCount()}`);
                        
                        // If we reached the end of the document, include everything up to the last line
                        if (end >= cm.lineCount()) {
                            end = cm.lineCount();
                        }
                        
                        if (end > start.line + 1) {
                            const result = {
                                from: CodeMirror.Pos(start.line, line.length),
                                to: CodeMirror.Pos(end - 1, cm.getLine(end - 1).length)
                            };
                            console.log(`Returning fold result:`, result);
                            return result;
                        } else {
                            console.log(`No content to fold after header at line ${start.line} (end=${end}, start=${start.line})`);
                        }
                    }
                    
                    // Handle code blocks (including mermaid)
                    if (trimmed.startsWith('```')) {
                        let end = start.line + 1;
                        let foundClosing = false;
                        
                        while (end < cm.lineCount()) {
                            const nextLine = cm.getLine(end);
                            if (nextLine.trim() === '```') {
                                foundClosing = true;
                                break;
                            }
                            end++;
                        }
                        
                        if (foundClosing && end > start.line) {
                            return {
                                from: CodeMirror.Pos(start.line, line.length),
                                to: CodeMirror.Pos(end, cm.getLine(end).length)
                            };
                        }
                    }
                    
                    // Handle single line items (links, images, inline code)
                    if (trimmed.match(/^!\[.*\]\(.*\)/) || trimmed.match(/^\[.*\]\(.*\)/) || trimmed.match(/^`[^`]+`/)) {
                        return {
                            from: CodeMirror.Pos(start.line, 0),
                            to: CodeMirror.Pos(start.line, line.length)
                        };
                    }
                    
                    return null;
                } catch(error) {
                    return null;
                }
            }
            
            // Fold helper will be registered in initEditor()
            
            // Function to check if a line is a foldable header (H2 and above)
            function isFoldableHeader(lineText, cm = null, lineNum = null) {
                const hasHeaderPattern = lineText.match(/^#{2,6}\s/);
                
                // If it looks like a header, check if it's inside a code block
                if (hasHeaderPattern && cm && lineNum !== null) {
                    if (isLineInCodeBlock(cm, lineNum)) {
                        return false;
                    }
                }
                
                return !!hasHeaderPattern;
            }
            
            // Function to check if a line is inside a code block
            function isLineInCodeBlock(cm, lineNum) {
                let inCodeBlock = false;
                let codeBlockStart = -1;
                
                // Additional check: if we're on a line that starts with ```, 
                // it's the boundary of a code block, not inside it
                const currentLine = cm.getLine(lineNum).trim();
                if (currentLine.startsWith('```')) {
                    return false;
                }
                
                // Check all lines from the beginning up to (but not including) the current line
                for (let i = 0; i < lineNum; i++) {
                    const line = cm.getLine(i).trim();
                    if (line.startsWith('```')) {
                        if (!inCodeBlock) {
                            // Starting a code block
                            inCodeBlock = true;
                            codeBlockStart = i;
                        } else {
                            // Ending a code block
                            inCodeBlock = false;
                            codeBlockStart = -1;
                        }
                    }
                }
                
                // Add debug info
                if (lineNum !== undefined && cm.getLine(lineNum).trim().match(/^#{2,6}\s/)) {
                    console.log(`Debug line ${lineNum}: inCodeBlock=${inCodeBlock}, codeBlockStart=${codeBlockStart}`);
                }
                
                return inCodeBlock;
            }
            
            // Function to check if a line is foldable
            function isFoldableLine(lineText, cm = null, lineNum = null) {
                const trimmed = lineText.trim();
                
                // Check if line contains a header-like pattern
                const hasHeaderPattern = lineText.match(/^#{2,6}\s/);
                
                // If it looks like a header, check if it's inside a code block
                if (hasHeaderPattern && cm && lineNum !== null) {
                    const inCodeBlock = isLineInCodeBlock(cm, lineNum);
                    console.log(`Line ${lineNum}: "${trimmed}" - Header pattern: ${!!hasHeaderPattern}, In code block: ${inCodeBlock}`);
                    if (inCodeBlock) {
                        // If inside code block, this is not a foldable header
                        return false;
                    }
                }
                
                return (
                    // Headers (H2 and above only - ## or more, but not inside code blocks)
                    hasHeaderPattern ||
                    // Code blocks (including mermaid)
                    trimmed.startsWith('```') ||
                    // Links (but not inside code blocks)
                    (trimmed.match(/^\[.*\]\(.*\)/) && (cm === null || lineNum === null || !isLineInCodeBlock(cm, lineNum))) ||
                    // Images (but not inside code blocks)
                    (trimmed.match(/^!\[.*\]\(.*\)/) && (cm === null || lineNum === null || !isLineInCodeBlock(cm, lineNum))) ||
                    // Inline code with content (but not inside code blocks)
                    (trimmed.match(/^`[^`]+`/) && (cm === null || lineNum === null || !isLineInCodeBlock(cm, lineNum)))
                );
            }
            
            
            // Toggle fold all headers function
            function foldAllContent() {
                if (!editor) return;
                
                const btn = document.getElementById('fold-all-btn');
                const icon = btn.querySelector('i');
                const cm = editor;
                
                if (isAllHeadersFolded) {
                    // Unfold all
                    cm.execCommand("unfoldAll");
                    
                    // Reset all line number colors
                    setTimeout(() => {
                        const gutterElement = cm.getGutterElement();
                        const lineElements = gutterElement.querySelectorAll('.CodeMirror-linenumber');
                        
                        for (let i = 0; i < cm.lineCount(); i++) {
                            const line = cm.getLine(i);
                            if (isFoldableHeader(line) && lineElements[i]) {
                                lineElements[i].style.color = '#666';
                                lineElements[i].style.fontWeight = '';
                                lineElements[i].style.backgroundColor = '';
                            }
                        }
                    }, 100);
                    
                    // Update button state
                    isAllHeadersFolded = false;
                    btn.classList.remove('active');
                    icon.className = 'fas fa-compress';
                    btn.title = '收摺所有標題';
                    // 已展開所有標題
                    
                } else {
                    // Fold all headers
                    let foldedCount = 0;
                    
                    for (let i = 0; i < cm.lineCount(); i++) {
                        const line = cm.getLine(i);
                        if (isFoldableHeader(line)) {
                            const pos = CodeMirror.Pos(i, 0);
                            // Only fold if not already folded
                            if (!cm.isFolded(pos)) {
                                const result = cm.foldCode(pos);
                                if (result !== false) {
                                    foldedCount++;
                                    updateLineNumberColor(cm, i, true);
                                }
                            }
                        }
                    }
                    
                    // Update button state
                    isAllHeadersFolded = true;
                    btn.classList.add('active');
                    icon.className = 'fas fa-expand';
                    btn.title = '展開所有標題';
                    
                    if (foldedCount > 0) {
                        // 已收摺 ${foldedCount} 個標題
                    } else {
                        // 所有標題已收摺
                    }
                }
            }
            
            // Function to update line number color based on fold state
            function updateLineNumberColor(cm, line, isFolded) {
                setTimeout(() => {
                    const gutterElement = cm.getGutterElement();
                    const lineElements = gutterElement.querySelectorAll('.CodeMirror-linenumber');
                    const lineNumberElement = lineElements[line];
                    
                    if (lineNumberElement) {
                        if (isFolded) {
                            lineNumberElement.style.color = '#007bff';
                            lineNumberElement.style.fontWeight = 'bold';
                            lineNumberElement.style.backgroundColor = '#e3f2fd';
                        } else {
                            lineNumberElement.style.color = '#666';
                            lineNumberElement.style.fontWeight = '';
                            lineNumberElement.style.backgroundColor = '';
                        }
                        lineNumberElement.style.cursor = 'pointer';
                    }
                }, 50);
            }
            
            // Initialize line number colors for foldable lines
            function initLineNumberColors(cm) {
                setTimeout(() => {
                    const gutterElement = cm.getGutterElement();
                    const lineElements = gutterElement.querySelectorAll('.CodeMirror-linenumber');
                    
                    for (let i = 0; i < cm.lineCount(); i++) {
                        const lineText = cm.getLine(i);
                        if (isFoldableLine(lineText, cm, i)) {
                            if (lineElements[i]) {
                                lineElements[i].style.cursor = 'pointer';
                                
                                // Set different tooltips based on content type
                                const trimmed = lineText.trim();
                                let tooltip = '點擊折疊/展開';
                                if (trimmed.match(/^#{2,6}\s/) && !isLineInCodeBlock(cm, i)) {
                                    tooltip += '此標題區塊';
                                } else if (trimmed.startsWith('```')) {
                                    if (trimmed.includes('mermaid')) {
                                        tooltip += '此Mermaid圖表';
                                    } else {
                                        tooltip += '此代碼塊';
                                    }
                                } else if (trimmed.match(/^!\[.*\]\(.*\)/) && !isLineInCodeBlock(cm, i)) {
                                    tooltip += '此圖片';
                                } else if (trimmed.match(/^\[.*\]\(.*\)/) && !isLineInCodeBlock(cm, i)) {
                                    tooltip += '此鏈接';
                                } else if (trimmed.match(/^`[^`]+`/) && !isLineInCodeBlock(cm, i)) {
                                    tooltip += '此代碼';
                                }
                                
                                lineElements[i].title = tooltip;
                                
                                // Add hover effect for foldable lines
                                lineElements[i].addEventListener('mouseenter', function() {
                                    if (this.style.backgroundColor !== '#e3f2fd') {
                                        this.style.backgroundColor = '#f0f0f0';
                                    }
                                });
                                lineElements[i].addEventListener('mouseleave', function() {
                                    if (this.style.backgroundColor === '#f0f0f0') {
                                        this.style.backgroundColor = '';
                                    }
                                });
                            }
                        }
                    }
                }, 150);
            }
            
            // 處理 TODO 項目樣式的函數
            function updateTodoStyles(cm) {
                if (!cm) return;
                
                // 獲取所有行
                for (let i = 0; i < cm.lineCount(); i++) {
                    const lineText = cm.getLine(i);
                    const lineElement = cm.getLineHandle(i);
                    
                    // 檢查是否為已完成的 TODO 項目 (- [x] 或 * [x])
                    if (lineText.match(/^[\s]*[-*]\s*\[x\]/i)) {
                        // 為已完成的 TODO 添加樣式類
                        cm.addLineClass(i, 'text', 'completed-todo');
                    } else {
                        // 移除已完成 TODO 的樣式類
                        cm.removeLineClass(i, 'text', 'completed-todo');
                    }
                }
            }
            
            // 處理結構符號加粗的函數
            function applyStructuralBold(cm) {
                if (!cm) return;
                
                // 清除之前的標記
                if (window.boldMarks) {
                    window.boldMarks.forEach(mark => mark.clear());
                }
                window.boldMarks = [];
                
                for (let i = 0; i < cm.lineCount(); i++) {
                    const lineText = cm.getLine(i);
                    if (!lineText) continue;
                    
                    // 在代碼塊中不處理
                    if (isInsideCodeBlock(cm, i)) continue;
                    
                    // 處理標題符號 # ## ###
                    const headerMatch = lineText.match(/^(\s*)(#{1,6})(\s)/);
                    if (headerMatch) {
                        const start = headerMatch[1].length;
                        const end = start + headerMatch[2].length;
                        const mark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: end},
                            {className: 'bold-structural-symbol'}
                        );
                        window.boldMarks.push(mark);
                    }
                    
                    // 處理引用符號 >
                    const quoteMatch = lineText.match(/^(\s*)(>)(\s)/);
                    if (quoteMatch) {
                        const start = quoteMatch[1].length;
                        const end = start + 1;
                        const mark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: end},
                            {className: 'bold-structural-symbol'}
                        );
                        window.boldMarks.push(mark);
                    }
                    
                    // 處理無序列表符號 - * +
                    const ulMatch = lineText.match(/^(\s*)([-*+])(\s)/);
                    if (ulMatch) {
                        const start = ulMatch[1].length;
                        const end = start + 1;
                        const mark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: end},
                            {className: 'bold-structural-symbol'}
                        );
                        window.boldMarks.push(mark);
                    }
                    
                    // 處理有序列表符號 1. 2. a. b.
                    const olMatch = lineText.match(/^(\s*)(\d+\.|[a-zA-Z]\.)(\s)/);
                    if (olMatch) {
                        const start = olMatch[1].length;
                        const end = start + olMatch[2].length;
                        const mark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: end},
                            {className: 'bold-structural-symbol'}
                        );
                        window.boldMarks.push(mark);
                    }
                }
            }
            
            // 存儲隱藏的標記
            let hiddenMarks = [];
            
            // 隱藏 Markdown 格式符號的函數
            function hideMarkdownSyntax(cm) {
                if (!cm) return;
                
                // 清除之前的標記
                hiddenMarks.forEach(mark => mark.clear());
                hiddenMarks = [];
                
                const cursor = cm.getCursor();
                const currentLine = cursor.line;
                
                for (let i = 0; i < cm.lineCount(); i++) {
                    // 跳過當前游標所在行
                    if (i === currentLine) continue;
                    
                    const lineText = cm.getLine(i);
                    if (!lineText) continue;
                    
                    // 在代碼塊中不處理
                    if (isInsideCodeBlock(cm, i)) continue;
                    
                    // 處理粗體 **text** 或 __text__
                    let boldRegex = /(\*\*|__)((?:(?!\1)[^\\]|\\.)+?)\1/g;
                    let match;
                    while ((match = boldRegex.exec(lineText)) !== null) {
                        const start = match.index;
                        const end = start + match[0].length;
                        const innerStart = start + match[1].length;
                        const innerEnd = end - match[1].length;
                        
                        // 隱藏開始符號
                        const startMark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: innerStart},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(startMark);
                        
                        // 隱藏結束符號
                        const endMark = cm.markText(
                            {line: i, ch: innerEnd},
                            {line: i, ch: end},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(endMark);
                    }
                    
                    // 處理斜體 *text* 或 _text_ (但不是粗體的一部分)
                    // 先移除所有粗體部分，然後處理剩餘的斜體
                    let lineTextForItalic = lineText.replace(/(\*\*|__)[^*_\n]+?\1/g, (match) => ' '.repeat(match.length));
                    let italicRegex = /(\*|_)([^*_\n]+?)\1/g;
                    while ((match = italicRegex.exec(lineTextForItalic)) !== null) {
                        const start = match.index;
                        const end = start + match[0].length;
                        const innerStart = start + 1;
                        const innerEnd = end - 1;
                        
                        // 隱藏開始符號
                        const startMark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: innerStart},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(startMark);
                        
                        // 隱藏結束符號
                        const endMark = cm.markText(
                            {line: i, ch: innerEnd},
                            {line: i, ch: end},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(endMark);
                    }
                    
                    // 處理內聯代碼 `code`
                    let codeRegex = /`([^`\n]+?)`/g;
                    while ((match = codeRegex.exec(lineText)) !== null) {
                        const start = match.index;
                        const end = start + match[0].length;
                        const innerStart = start + 1;
                        const innerEnd = end - 1;
                        
                        // 隱藏開始符號
                        const startMark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: innerStart},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(startMark);
                        
                        // 隱藏結束符號
                        const endMark = cm.markText(
                            {line: i, ch: innerEnd},
                            {line: i, ch: end},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(endMark);
                    }
                    
                    // 處理刪除線 ~~text~~
                    let strikeRegex = /~~([^~\n]+?)~~/g;
                    while ((match = strikeRegex.exec(lineText)) !== null) {
                        const start = match.index;
                        const end = start + match[0].length;
                        const innerStart = start + 2;
                        const innerEnd = end - 2;
                        
                        // 隱藏開始符號
                        const startMark = cm.markText(
                            {line: i, ch: start},
                            {line: i, ch: innerStart},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(startMark);
                        
                        // 隱藏結束符號
                        const endMark = cm.markText(
                            {line: i, ch: innerEnd},
                            {line: i, ch: end},
                            {
                                css: 'display: none',
                                className: 'hidden-markdown-syntax'
                            }
                        );
                        hiddenMarks.push(endMark);
                    }
                }
            }
            
            // Unfold all sections function (for Ctrl+Shift+Q)
            function unfoldAllSections() {
                if (!editor) return;
                editor.execCommand("unfoldAll");
                
                // Reset all line number colors
                setTimeout(() => {
                    const gutterElement = editor.getGutterElement();
                    const lineElements = gutterElement.querySelectorAll('.CodeMirror-linenumber');
                    
                    for (let i = 0; i < editor.lineCount(); i++) {
                        const line = editor.getLine(i);
                        if (isFoldableLine(line, editor, i) && lineElements[i]) {
                            lineElements[i].style.color = '#666';
                            lineElements[i].style.fontWeight = '';
                            lineElements[i].style.backgroundColor = '';
                        }
                    }
                }, 100);
                
                // Reset button state
                const btn = document.getElementById('fold-all-btn');
                if (btn) {
                    isAllHeadersFolded = false;
                    btn.classList.remove('active');
                    const icon = btn.querySelector('i');
                    if (icon) {
                        icon.className = 'fas fa-compress';
                        btn.title = '收摺所有內容';
                    }
                }
                
                // 已展開所有區塊
            }

            // --- Editor, Preview, and Scroll Sync ---
            function handleCursorTimerTracking() {
                if (!autoTimerEnabled) return;
                if (!editor) return;

                const cursor = editor.getCursor();
                const lines = editor.getValue().split('\n');
                let currentHeading = null;
                let currentHeadingLine = null;

                // 從游標行往上找最近的標題
                for (let i = cursor.line; i >= 0; i--) {
                    const match = lines[i].match(/^#+\s+(.+)$/);
                    if (match) {
                        currentHeading = match[0];
                        currentHeadingLine = i;
                        break;
                    }
                }

            }

            // Smart hiding for HTML syntax and markdown links
            function handleSmartHiding(cm) {
                if (!cm) return;
                
                const cursor = cm.getCursor();
                const line = cursor.line;
                const ch = cursor.ch;
                
                // Clear all existing marks
                const marks = cm.getAllMarks();
                marks.forEach(mark => {
                    if (mark.className && mark.className.includes('smart-hide')) {
                        mark.clear();
                    }
                });
                
                const totalLines = cm.lineCount();
                
                // Handle HTML blocks (independent processing)
                handleHtmlBlocks(cm, cursor, totalLines);
                
                // Handle markdown links (independent processing)
                handleMarkdownLinks(cm, cursor, totalLines);
            }
            
            // Handle HTML blocks - identify and hide multi-line HTML regions
            function handleHtmlBlocks(cm, cursor, totalLines) {
                const processedLines = new Set(); // Track processed lines to avoid duplicate processing
                
                for (let i = 0; i < totalLines; i++) {
                    if (processedLines.has(i) || isInsideCodeBlock(cm, i)) {
                        continue;
                    }
                    
                    const lineText = cm.getLine(i);
                    
                    // Check if this line contains HTML tags
                    const htmlTagRegex = /<[^>]+>/;
                    if (htmlTagRegex.test(lineText)) {
                        // Find the HTML block boundaries
                        const htmlBlock = findHtmlBlock(cm, i, totalLines);
                        
                        // Mark processed lines
                        for (let j = htmlBlock.start; j <= htmlBlock.end; j++) {
                            processedLines.add(j);
                        }
                        
                        // Check if cursor is within this HTML block
                        const isCursorInBlock = cursor.line >= htmlBlock.start && cursor.line <= htmlBlock.end;
                        
                        if (!isCursorInBlock) {
                            // Hide the HTML block, keeping only first 30 chars of first line
                            hideHtmlBlock(cm, htmlBlock);
                        }
                    }
                }
            }
            
            // Find HTML block boundaries (multi-line HTML detection)
            function findHtmlBlock(cm, startLine, totalLines) {
                let start = startLine;
                let end = startLine;
                
                // Look backwards to find actual start of HTML block
                for (let i = startLine - 1; i >= 0; i--) {
                    if (isInsideCodeBlock(cm, i)) break;
                    
                    const lineText = cm.getLine(i);
                    if (/<[^>]+>/.test(lineText) || lineText.trim() === '') {
                        if (/<[^>]+>/.test(lineText)) {
                            start = i;
                        }
                    } else {
                        break;
                    }
                }
                
                // Look forwards to find end of HTML block
                for (let i = startLine + 1; i < totalLines; i++) {
                    if (isInsideCodeBlock(cm, i)) break;
                    
                    const lineText = cm.getLine(i);
                    if (/<[^>]+>/.test(lineText) || lineText.trim() === '') {
                        if (/<[^>]+>/.test(lineText)) {
                            end = i;
                        }
                    } else {
                        break;
                    }
                }
                
                return { start, end };
            }
            
            // Hide HTML block, keeping only first 30 chars of first line
            function hideHtmlBlock(cm, htmlBlock) {
                if (htmlBlock.start === htmlBlock.end) {
                    // Single line HTML - just hide part of it
                    const firstLineText = cm.getLine(htmlBlock.start);
                    const keepLength = Math.min(30, firstLineText.length);
                    
                    if (firstLineText.length > 30) {
                        cm.markText(
                            {line: htmlBlock.start, ch: keepLength}, 
                            {line: htmlBlock.start, ch: firstLineText.length}, 
                            {
                                className: 'smart-hide',
                                css: 'display: none;'
                            }
                        );
                    }
                } else {
                    // Multi-line HTML - use folding
                    const firstLineText = cm.getLine(htmlBlock.start);
                    const keepLength = Math.min(30, firstLineText.length);
                    
                    // Create a truncated version of the first line
                    let truncatedText = firstLineText.substring(0, keepLength);
                    if (firstLineText.length > 30) {
                        truncatedText += '...';
                    }
                    
                    // Create a fold range that hides the content but shows truncated first line
                    const range = {
                        from: {line: htmlBlock.start, ch: 0},
                        to: {line: htmlBlock.end, ch: cm.getLine(htmlBlock.end).length}
                    };
                    
                    // Create a custom fold widget
                    const foldWidget = document.createElement('span');
                    foldWidget.className = 'smart-hide-html-fold';
                    foldWidget.style.cssText = 'background: #f0f0f0; padding: 2px 4px; border-radius: 3px; color: #666; cursor: pointer; font-size: 0.9em;';
                    foldWidget.textContent = truncatedText;
                    foldWidget.title = 'Click to expand HTML block';
                    
                    // Replace the entire HTML block with the widget
                    const marker = cm.markText(range.from, range.to, {
                        className: 'smart-hide',
                        replacedWith: foldWidget,
                        clearOnEnter: false,
                        handleMouseEvents: true
                    });
                    
                    // Add click handler to expand when clicked
                    foldWidget.addEventListener('click', function(e) {
                        e.preventDefault();
                        marker.clear();
                        cm.setCursor(htmlBlock.start, 0);
                        cm.focus();
                    });
                }
            }
            
            // Handle markdown links independently
            function handleMarkdownLinks(cm, cursor, totalLines) {
                for (let i = 0; i < totalLines; i++) {
                    if (isInsideCodeBlock(cm, i)) {
                        continue;
                    }
                    
                    const lineText = cm.getLine(i);
                    
                    // Handle markdown links [text](url)
                    const markdownLinkRegex = /\[([^\]]*)\]\(([^)]*)\)/g;
                    let match;
                    
                    while ((match = markdownLinkRegex.exec(lineText)) !== null) {
                        const start = match.index;
                        const end = start + match[0].length;
                        const linkText = match[1];
                        
                        // Check if cursor is on this line and within the link
                        const isActive = (cursor.line === i && cursor.ch >= start && cursor.ch <= end);
                        
                        if (isActive) {
                            // Show full syntax when cursor is on it
                            continue;
                        } else {
                            // Hide brackets and URL, show only link text
                            if (linkText.trim()) {
                                // Hide opening bracket
                                cm.markText({line: i, ch: start}, {line: i, ch: start + 1}, {
                                    className: 'smart-hide',
                                    css: 'display: none;'
                                });
                                
                                // Hide closing bracket and opening parenthesis
                                cm.markText({line: i, ch: start + 1 + linkText.length}, {line: i, ch: start + 1 + linkText.length + 2}, {
                                    className: 'smart-hide',
                                    css: 'display: none;'
                                });
                                
                                // Hide URL and closing parenthesis
                                cm.markText({line: i, ch: start + 1 + linkText.length + 2}, {line: i, ch: end}, {
                                    className: 'smart-hide',
                                    css: 'display: none;'
                                });
                            }
                        }
                    }
                }
            }
            
            // Helper function to check if a line is inside a code block
            function isInsideCodeBlock(cm, lineNum) {
                const totalLines = cm.lineCount();
                let inCodeBlock = false;
                
                for (let i = 0; i <= lineNum && i < totalLines; i++) {
                    const lineText = cm.getLine(i);
                    
                    // Check for code block delimiters (```)
                    if (lineText.trim().startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                    }
                    
                    // If we're at the target line and it's a code block delimiter, 
                    // consider it as not inside code block for the purpose of hiding
                    if (i === lineNum && lineText.trim().startsWith('```')) {
                        return false;
                    }
                }
                
                return inCodeBlock;
            }

            // Detect mobile device
            function isMobileDevice() {
                return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            function initEditor() {
                const isMobile = isMobileDevice();
                
                editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
                    mode: 'markdown',
                    theme: 'default',
                    lineNumbers: true,
                    lineWrapping: true, // Always enable line wrapping
                    autofocus: !isMobile, // Disable autofocus on mobile to prevent keyboard popup
                    foldGutter: false,
                    gutters: ["CodeMirror-linenumbers"],
                    extraKeys: {
                        "Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); },
                        "Ctrl-Shift-Q": function(cm){ cm.execCommand("unfoldAll"); }
                    }
                });
                
                // Register custom markdown fold function
                CodeMirror.registerHelper("fold", "markdown", markdownHeaderFold);
                
                // Add click handler for line numbers to fold/unfold
                editor.on("gutterClick", function(cm, line, gutter, clickEvent) {
                    if (gutter === "CodeMirror-linenumbers") {
                        const lineText = cm.getLine(line);
                        if (isFoldableLine(lineText, cm, line)) {
                            const pos = CodeMirror.Pos(line, 0);
                            if (cm.isFolded(pos)) {
                                cm.unfoldCode(pos);
                                updateLineNumberColor(cm, line, false);
                            } else {
                                cm.foldCode(pos);
                                updateLineNumberColor(cm, line, true);
                            }
                        }
                    }
                });
                
                // Force word wrapping for all devices
                editor.setOption("lineWrapping", true);
                editor.refresh();
                
                // Initialize line number colors for foldable lines
                setTimeout(() => {
                    initLineNumberColors(editor);
                    // 初始化 TODO 樣式
                    updateTodoStyles(editor);
                    // 初始化結構符號加粗
                    applyStructuralBold(editor);
                    // 初始化 Markdown 語法隱藏
                    hideMarkdownSyntax(editor);
                }, 200);
                
                // Re-initialize line numbers when content changes
                editor.on('change', function(cm) {
                    setTimeout(() => {
                        initLineNumberColors(cm);
                        // Reset button state when content changes
                        const btn = document.getElementById('fold-all-btn');
                        if (btn && isAllHeadersFolded) {
                            isAllHeadersFolded = false;
                            btn.classList.remove('active');
                            const icon = btn.querySelector('i');
                            if (icon) {
                                icon.className = 'fas fa-compress';
                                btn.title = '收摺所有內容';
                            }
                        }
                        // 處理 TODO 項目樣式
                        updateTodoStyles(cm);
                        // 更新結構符號加粗
                        applyStructuralBold(cm);
                        // 更新 Markdown 語法隱藏
                        hideMarkdownSyntax(cm);
                        // 更新 hashtag 高亮
                        applyHashtagHighlighting();
                        
                        // 延遲同步 hashtag 變更 (2秒後)
                        if (hashtagSyncTimer) {
                            clearTimeout(hashtagSyncTimer);
                        }
                        hashtagSyncTimer = setTimeout(() => {
                            if (currentFile && currentFile.name !== 'NoteTag.md') {
                                console.log(`⏰ Auto-syncing hashtags for ${currentFile.name}`);
                                syncHashtagChanges(currentFile.id, editor.getValue());
                            }
                        }, 2000);
                    }, 100);
                });
                
                // Handle window resize for orientation changes
                window.addEventListener('resize', () => {
                    setTimeout(() => {
                        if (editor) {
                            // Always keep line wrapping enabled for better UX
                            editor.setOption("lineWrapping", true);
                            editor.refresh();
                        }
                        // Update mobile UI when device orientation changes
                        if (isMobileDevice()) {
                            updateMobileViewUI();
                        } else {
                            // Remove mobile classes if no longer on mobile
                            mainContainer.classList.remove('mobile-edit-only', 'mobile-preview-only');
                        }
                    }, 100);
                });
                // 移除游標活動計時觸發，改用文字編輯觸發
                // editor.on('cursorActivity', handleCursorTimerTracking);

                editor.on('change', async (instance, changeObj) => {
                    console.log('編輯器change事件觸發:', {
                        origin: changeObj.origin,
                        text: changeObj.text,
                        textLength: changeObj.text.length,
                        removed: changeObj.removed,
                        from: changeObj.from,
                        to: changeObj.to
                    });
                    
                    if (currentFile) {
                        const oldContent = currentFile.content;
                        currentFile.content = editor.getValue();
                        currentFile.lastModified = Date.now(); // Update modification timestamp
                        await saveFilesToStorage();
                        
                        // Check if UNSYNC status changed and update file list styling
                        const oldHasUnsync = oldContent.includes('#UNSYNC');
                        const newHasUnsync = currentFile.content.includes('#UNSYNC');
                        if (oldHasUnsync !== newHasUnsync) {
                            renderFileList(); // Re-render to update UNSYNC styling
                        }
                        
                        // Schedule hashtag update check if editing NoteTag.md
                        if (currentFile.name === 'NoteTag.md') {
                            // Clear existing timer
                            if (hashtagUpdateTimer) {
                                clearTimeout(hashtagUpdateTimer);
                            }
                            
                            // Set 5-second delay timer
                            hashtagUpdateTimer = setTimeout(async () => {
                                await detectAndUpdateHashtagChanges();
                                hashtagUpdateTimer = null;
                            }, 5000);
                        }
                    }
                    updatePreview();
                    
                    // Update TOC if it's currently shown
                    if (sidebarVisible && (viewMode === 'toc' || viewMode === 'dual')) {
                        updateToc();
                    }
                    
                    // Handle autocomplete (wiki links and hashtags)
                    if (changeObj.origin === '+input' && changeObj.text.length === 1) {
                        const cursor = editor.getCursor();
                        const line = editor.getLine(cursor.line);
                        const beforeCursor = line.substring(0, cursor.ch);
                        
                        // Check if we just typed '[['
                        if (beforeCursor.endsWith('[[')) {
                            const items = getAutocompleteItems('');
                            if (items.length > 0) {
                                createAutocompleteDropdown(items, cursor);
                            }
                        }
                        // Check if we're typing inside [[]]
                        else if (beforeCursor.match(/\[\[([^\]]*?)$/)) {
                            const wikiLinkMatch = beforeCursor.match(/\[\[([^\]]*?)$/);
                            const query = wikiLinkMatch[1];
                            const items = getAutocompleteItems(query);
                            if (items.length > 0) {
                                createAutocompleteDropdown(items, cursor);
                            } else {
                                removeAutocompleteDropdown();
                            }
                        }
                        // Check if we just typed '#'
                        else if (beforeCursor.endsWith('#')) {
                            const items = getHashtagAutocompleteItems('');
                            if (items.length > 0) {
                                createHashtagAutocompleteDropdown(items, cursor);
                            }
                        }
                        // Check if we're typing after #
                        else if (beforeCursor.match(/#([^#\s]*)$/)) {
                            const hashtagMatch = beforeCursor.match(/#([^#\s]*)$/);
                            const query = hashtagMatch[1];
                            const items = getHashtagAutocompleteItems(query);
                            if (items.length > 0) {
                                createHashtagAutocompleteDropdown(items, cursor);
                            } else {
                                removeAutocompleteDropdown();
                            }
                        }
                        // Remove autocomplete if none of the above conditions match
                        else {
                            removeAutocompleteDropdown();
                        }
                    }
                    
                    // 只處理Enter按鍵的自動計時觸發
                    if (changeObj.origin === '+input' && autoTimerEnabled) {
                        // 檢查是否按了Enter鍵 (Enter會產生換行符)
                        if (changeObj.text.length === 1 && changeObj.text[0] === '\n') {
                            console.log('change事件偵測到Enter按鍵（備用觸發）');
                            // Enter按鍵的處理主要在keydown中，這裡作為備用
                            await handleAutoTimerOnEnter(changeObj);
                        }
                    }
                });
                
                // Handle keyboard navigation for autocomplete and auto list
                editor.on('keydown', (instance, e) => {
                    if (handleAutocompleteNavigation(e)) {
                        return;
                    }
                    
                    // Handle Enter key for auto list continuation
                    if (e.key === 'Enter') {
                        console.log('keydown事件偵測到Enter按鍵');
                        
                        // 先觸發自動計時（在auto list處理之前）
                        if (autoTimerEnabled) {
                            console.log('在keydown中觸發自動計時');
                            // 使用setTimeout確保在DOM更新後執行
                            setTimeout(async () => {
                                const cursor = instance.getCursor();
                                await handleAutoTimerOnEnter({
                                    origin: '+input',
                                    text: ['\n'],
                                    from: cursor,
                                    to: cursor
                                });
                            }, 0);
                        }
                        
                        if (handleAutoListContinuation(instance, e)) {
                            return;
                        }
                    }
                });
                
                // Smart hiding for HTML and markdown links
                editor.on('cursorActivity', function(cm) {
                    handleSmartHiding(cm);
                    // 更新結構符號加粗（當游標移動時）
                    applyStructuralBold(cm);
                    // 更新 Markdown 語法隱藏（當游標移動時）
                    hideMarkdownSyntax(cm);
                    
                    // 手機版游標移動檢測，更新轉跳按鈕
                    if (isMobileDevice()) {
                        updateMobileJumpButton(cm);
                    }
                });
                
                // Add click handler for Ctrl+Click navigation
                editor.on('mousedown', function(cm, event) {
                    // 電腦版：檢查 Ctrl/Cmd + 點擊
                    if (!isMobileDevice() && (event.ctrlKey || event.metaKey)) {
                        const pos = cm.coordsChar({left: event.clientX, top: event.clientY});
                        const token = cm.getTokenAt(pos);
                        const line = cm.getLine(pos.line);
                        
                        if (handleEditorLinkClick(cm, pos, line, token)) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                });
                
                // Scroll Sync Listener
                editor.on('scroll', syncPreviewScroll);
                
                // Setup drag and drop for images
                setupImageDragDrop();
            }

            // Setup drag and drop functionality for images
            function setupImageDragDrop() {
                const editorElement = editor.getWrapperElement();
                
                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    editorElement.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false);
                });
                
                // Highlight drop area
                ['dragenter', 'dragover'].forEach(eventName => {
                    editorElement.addEventListener(eventName, highlight, false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    editorElement.addEventListener(eventName, unhighlight, false);
                });
                
                // Handle dropped files
                editorElement.addEventListener('drop', handleImageDrop, false);
                
                function preventDefaults(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                function highlight(e) {
                    editorElement.style.border = '2px dashed #007bff';
                    editorElement.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                }
                
                function unhighlight(e) {
                    editorElement.style.border = '';
                    editorElement.style.backgroundColor = '';
                }
                
                function handleImageDrop(e) {
                    const dt = e.dataTransfer;
                    const files = dt.files;
                    
                    [...files].forEach(file => {
                        if (file.type.startsWith('image/')) {
                            insertImageReference(file);
                        }
                    });
                }
                
                function insertImageReference(file) {
                    const cursor = editor.getCursor();
                    const filePath = file.path || file.name;
                    
                    // Try to create a relative path if possible
                    let imagePath = filePath;
                    const currentDir = getCurrentDirectory();
                    
                    if (filePath.startsWith(currentDir)) {
                        // Create relative path
                        imagePath = './' + filePath.substring(currentDir.length + 1).replace(/\\/g, '/');
                    } else {
                        // Use absolute path
                        imagePath = filePath.replace(/\\/g, '/');
                    }
                    
                    const imageMarkdown = `![${file.name}](${imagePath})`;
                    editor.replaceRange(imageMarkdown, cursor);
                    
                    // Move cursor to end of inserted text
                    const newCursor = {
                        line: cursor.line,
                        ch: cursor.ch + imageMarkdown.length
                    };
                    editor.setCursor(newCursor);
                    
                    // Trigger preview update
                    updatePreview();
                }
            }

            function configureMarked() {
                const renderer = new marked.Renderer();
                
                // Override text renderer to handle wiki links
                renderer.text = function(text) {
                    // Handle wiki links [[note name]] or [[note name#section]]
                    text = text.replace(/\[\[([^\]]+)\]\]/g, function(match, linkContent) {
                        const parts = linkContent.split('#');
                        const noteName = parts[0];
                        const sectionName = parts[1];
                        
                        const targetFile = files.find(f => 
                            f.name.toLowerCase().includes(noteName.toLowerCase()) ||
                            f.name.replace(/\.[^/.]+$/, "").toLowerCase() === noteName.toLowerCase()
                        );
                        
                        if (targetFile) {
                            const displayText = sectionName ? `${noteName}#${sectionName}` : noteName;
                            return `<a href="#" class="wiki-link" data-file-id="${targetFile.id}" data-section="${sectionName || ''}" title="跳轉到 ${targetFile.name}${sectionName ? ' - ' + sectionName : ''}">${displayText}</a>`;
                        } else {
                            return `<span class="wiki-link-missing" title="找不到筆記: ${noteName}">${linkContent}</span>`;
                        }
                    });
                    return text;
                };
                
                marked.setOptions({ 
                    renderer: renderer,
                    highlight: function(code, lang) {
                        // 清理語言名稱
                        if (lang) {
                            lang = lang.toLowerCase().trim();
                            // 處理常見的語言別名
                            const langMap = {
                                'js': 'javascript',
                                'py': 'python',
                                'c++': 'cpp',
                                'c#': 'csharp',
                                'ts': 'typescript',
                                'sh': 'bash',
                                'shell': 'bash'
                            };
                            lang = langMap[lang] || lang;
                        }
                        
                        // 特殊處理 mermaid 圖表
                        if (lang === 'mermaid') {
                            return code; // 不進行語法高亮，保持原始代碼
                        }
                        
                        if (lang && hljs.getLanguage(lang)) {
                            try {
                                const result = hljs.highlight(code, { language: lang });
                                return result.value;
                            } catch (err) {
                                console.warn('Highlight.js error for language', lang, ':', err);
                            }
                        }
                        
                        try {
                            const result = hljs.highlightAuto(code);
                            return result.value;
                        } catch (err) {
                            console.warn('Highlight.js auto-detection error:', err);
                            return code;
                        }
                    },
                    breaks: true, 
                    gfm: true,
                    sanitize: false  // Allow HTML content
                });
            }

            // 增強程式碼區塊顯示功能
            function enhanceCodeBlocks(container) {
                const codeBlocks = container.querySelectorAll('pre code');
                
                codeBlocks.forEach((codeBlock, index) => {
                    const pre = codeBlock.parentElement;
                    
                    // 確保code元素有hljs類名
                    if (!codeBlock.classList.contains('hljs')) {
                        codeBlock.classList.add('hljs');
                    }
                    
                    // 添加語言標籤
                    const className = codeBlock.className;
                    if (className.includes('language-')) {
                        const lang = className.replace('language-', '').split(' ')[0];
                        if (!pre.querySelector('.lang-label')) {
                            const langLabel = document.createElement('span');
                            langLabel.className = 'lang-label';
                            langLabel.textContent = lang.toUpperCase();
                            langLabel.style.cssText = `
                                position: absolute;
                                top: 8px;
                                right: 8px;
                                background: rgba(0,0,0,0.6);
                                color: white;
                                padding: 2px 6px;
                                border-radius: 3px;
                                font-size: 10px;
                                font-weight: bold;
                                z-index: 5;
                            `;
                            pre.appendChild(langLabel);
                        }
                    }
                    
                    // 添加複製按鈕
                    if (!pre.querySelector('.copy-button')) {
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'copy-button';
                        copyBtn.innerHTML = '📋';
                        copyBtn.title = '複製程式碼';
                        copyBtn.onclick = function() {
                            navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                                copyBtn.innerHTML = '✅';
                                setTimeout(() => {
                                    copyBtn.innerHTML = '📋';
                                }, 1000);
                            });
                        };
                        pre.appendChild(copyBtn);
                    }
                    
                    // 處理超長行和縮排
                    const lines = codeBlock.textContent.split('\n');
                    let maxIndent = 0;
                    let hasLongLines = false;
                    
                    lines.forEach(line => {
                        if (line.length > 80) hasLongLines = true;
                        const indent = line.match(/^\s*/);
                        if (indent) {
                            maxIndent = Math.max(maxIndent, indent[0].length);
                        }
                    });
                    
                    // 如果縮排過深，調整樣式
                    if (maxIndent > 16) {
                        pre.style.fontSize = '12px';
                        pre.style.tabSize = '2';
                    }
                    
                    // 如果有長行，確保水平滾動
                    if (hasLongLines) {
                        pre.style.overflowX = 'auto';
                        pre.style.whiteSpace = 'pre';
                        codeBlock.style.whiteSpace = 'pre';
                        codeBlock.style.wordWrap = 'normal';
                    }
                });
            }

            // Process local images in preview
            function processLocalImages(container) {
                const images = container.querySelectorAll('img');
                images.forEach(img => {
                    const src = img.getAttribute('src');
                    if (src && isLocalPath(src)) {
                        // Convert relative paths to absolute paths if needed
                        const absolutePath = resolveLocalPath(src);
                        // Create file URL for local images
                        img.src = `file:///${absolutePath.replace(/\\/g, '/')}`;
                        img.onerror = function() {
                            this.style.border = '2px dashed #ccc';
                            this.style.padding = '10px';
                            this.style.backgroundColor = '#f9f9f9';
                            this.alt = `圖片載入失敗: ${src}`;
                            this.title = `無法載入圖片: ${absolutePath}`;
                        };
                    }
                });
            }

            // Check if path is local
            function isLocalPath(path) {
                if (!path) return false;
                // Check for relative paths (./ or ../) or absolute paths (C:\ or /)
                return path.startsWith('./') || 
                       path.startsWith('../') || 
                       /^[A-Za-z]:[\\\/]/.test(path) || 
                       path.startsWith('/') && !path.startsWith('//') && !path.includes('://');
            }

            // Resolve local path to absolute path
            function resolveLocalPath(path) {
                if (path.startsWith('./')) {
                    // Relative to current directory
                    const currentDir = getCurrentDirectory();
                    return currentDir + '\\' + path.substring(2).replace(/\//g, '\\');
                } else if (path.startsWith('../')) {
                    // Relative to parent directory
                    const currentDir = getCurrentDirectory();
                    const parts = currentDir.split('\\');
                    const upLevels = (path.match(/\.\.\//g) || []).length;
                    const newParts = parts.slice(0, -upLevels);
                    const remainingPath = path.replace(/\.\.\//g, '').replace(/\//g, '\\');
                    return newParts.join('\\') + '\\' + remainingPath;
                } else if (/^[A-Za-z]:[\\\/]/.test(path)) {
                    // Already absolute path
                    return path.replace(/\//g, '\\');
                } else if (path.startsWith('/')) {
                    // Unix-style absolute path - treat as relative to current drive
                    const currentDir = getCurrentDirectory();
                    const drive = currentDir.split(':')[0] + ':';
                    return drive + path.replace(/\//g, '\\');
                }
                return path;
            }

            // Get current directory (approximation)
            function getCurrentDirectory() {
                // Use the document location to approximate current directory
                // This is a best-effort approach for file:// URLs
                const pathname = window.location.pathname;
                if (pathname.includes('/')) {
                    const parts = pathname.split('/');
                    parts.pop(); // Remove filename
                    return parts.join('\\').substring(1); // Remove leading slash and convert to backslashes
                }
                // Fallback to a reasonable default
                return 'C:\\Users\\28041\\OneDrive - UL Solutions\\Documents\\zzz_Automation Tools\\tool_index_page\\PowerNote';
            }
            
            // Get hashtag autocomplete items from NoteTag.md
            function getHashtagAutocompleteItems(query) {
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) {
                    return [{
                        label: `新增標籤 "${query}"`,
                        value: query,
                        isNew: true
                    }];
                }
                
                // Extract existing hashtags from NoteTag.md
                const hashtagRegex = /^### (.+)$/gm;
                const hashtags = [];
                let match;
                
                while ((match = hashtagRegex.exec(noteTagFile.content)) !== null) {
                    hashtags.push(match[1]);
                }
                
                // Filter hashtags based on query
                const filteredHashtags = hashtags.filter(hashtag => 
                    hashtag.toLowerCase().includes(query.toLowerCase())
                );
                
                const items = filteredHashtags.map(hashtag => ({
                    label: `#${hashtag}`,
                    value: hashtag,
                    isNew: false
                }));
                
                // Add "new hashtag" option if query doesn't match exactly
                if (query && !hashtags.includes(query)) {
                    items.push({
                        label: `新增標籤 "#${query}"`,
                        value: query,
                        isNew: true
                    });
                }
                
                return items;
            }
            
            // Create hashtag autocomplete dropdown
            function createHashtagAutocompleteDropdown(items, cursor) {
                removeAutocompleteDropdown(); // Remove existing dropdown
                
                const dropdown = document.createElement('div');
                dropdown.className = 'autocomplete-dropdown hashtag-dropdown';
                dropdown.style.position = 'absolute';
                dropdown.style.zIndex = '1000';
                dropdown.style.maxHeight = '200px';
                dropdown.style.overflowY = 'auto';
                
                items.forEach((item, index) => {
                    const option = document.createElement('div');
                    option.className = 'autocomplete-item' + (item.isNew ? ' new-hashtag' : '');
                    option.textContent = item.label;
                    option.dataset.insertText = item.value; // Store value for keyboard selection
                    option.onclick = () => selectHashtag(item, cursor);
                    
                    // Set initial selection
                    if (index === 0) {
                        option.classList.add('selected');
                    }
                    
                    dropdown.appendChild(option);
                });
                
                // Position dropdown
                const coords = editor.cursorCoords(cursor, 'local');
                const rect = editor.getWrapperElement().getBoundingClientRect();
                dropdown.style.left = (rect.left + coords.left) + 'px';
                dropdown.style.top = (rect.top + coords.bottom + 5) + 'px';
                
                document.body.appendChild(dropdown);
                autocompleteDropdown = dropdown;
                autocompleteSelectedIndex = 0;
                
                // Store cursor position for keyboard selection
                autocompleteDropdown.cursorPosition = cursor;
            }
            
            // Select hashtag from dropdown
            function selectHashtag(item, cursor) {
                const line = editor.getLine(cursor.line);
                const beforeCursor = line.substring(0, cursor.ch);
                const hashtagMatch = beforeCursor.match(/#([^#\s]*)$/);
                
                if (hashtagMatch) {
                    const startPos = cursor.ch - hashtagMatch[0].length;
                    const endPos = cursor.ch;
                    
                    editor.replaceRange(`#${item.value} `, 
                        { line: cursor.line, ch: startPos },
                        { line: cursor.line, ch: endPos }
                    );
                    
                    if (item.isNew) {
                        // Create new hashtag
                        const currentFileName = getCurrentFileName();
                        handleHashtagCreation(item.value, currentFileName);
                    } else {
                        // Add to existing hashtag
                        const currentFileName = getCurrentFileName();
                        handleHashtagCreation(item.value, currentFileName);
                    }
                }
                
                removeAutocompleteDropdown();
            }
            
            // Navigate to hashtag in NoteTag.md
            function navigateToHashtag(hashtag) {
                // Find NoteTag.md file
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) {
                    showNotification('找不到 NoteTag.md 文件');
                    return;
                }
                
                // Load NoteTag.md
                loadFile(noteTagFile.id);
                
                // Navigate to the hashtag section after file loads
                setTimeout(() => {
                    navigateToSection(hashtag);
                    showNotification(`已跳轉到標籤：#${hashtag}`);
                }, 100);
            }
            
            // Process hashtags in markdown content
            function getValidHashtagsFromNoteTag() {
                // Get valid hashtags from NoteTag.md
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) return new Set();
                
                const validHashtags = new Set();
                const headerRegex = /^### (.+)$/gm;
                let match;
                
                while ((match = headerRegex.exec(noteTagFile.content)) !== null) {
                    validHashtags.add(match[1]);
                }
                
                return validHashtags;
            }
            
            function processHashtags(markdown) {
                // Get valid hashtags from NoteTag.md
                const validHashtags = getValidHashtagsFromNoteTag();
                if (validHashtags.size === 0) {
                    return markdown; // No valid hashtags, return unchanged
                }
                
                // Replace standalone hashtags with clickable links only if they exist in NoteTag.md
                const lines = markdown.split('\n');
                const processedLines = [];
                let inCodeBlock = false;
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    
                    // Check if we're entering or leaving a code block
                    if (line.trim().startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        processedLines.push(line);
                        continue;
                    }
                    
                    // If we're in a code block, don't process hashtags
                    if (inCodeBlock) {
                        processedLines.push(line);
                        continue;
                    }
                    
                    // Process hashtags in this line
                    // Match #word at start of line or after whitespace, but not in headers
                    if (!line.match(/^#{1,6}\s/)) { // Not a markdown header
                        line = line.replace(/^#([^\s#]+)(?=\s|$)/g, (match, hashtag) => {
                            // Only render as link if hashtag exists in NoteTag.md
                            if (validHashtags.has(hashtag)) {
                                return `<a href="#" class="hashtag-link" data-hashtag="${hashtag}" title="跳轉到 ${hashtag} 標籤">#${hashtag}</a>`;
                            }
                            return match; // Return unchanged if not in NoteTag.md
                        });
                        
                        // Also match hashtags after whitespace
                        line = line.replace(/(\s)#([^\s#]+)(?=\s|$)/g, (match, whitespace, hashtag) => {
                            // Only render as link if hashtag exists in NoteTag.md
                            if (validHashtags.has(hashtag)) {
                                return `${whitespace}<a href="#" class="hashtag-link" data-hashtag="${hashtag}" title="跳轉到 ${hashtag} 標籤">#${hashtag}</a>`;
                            }
                            return match; // Return unchanged if not in NoteTag.md
                        });
                    }
                    
                    processedLines.push(line);
                }
                
                return processedLines.join('\n');
            }

            async function updatePreview() {
                let markdown = editor.getValue();
                
                // Process hashtags before markdown parsing
                markdown = processHashtags(markdown);
                
                const previewEl = document.getElementById('preview');
                previewEl.innerHTML = marked.parse(markdown);
                
                // Process local images
                processLocalImages(previewEl);
                
                // 手動對程式碼區塊應用語法高亮
                const codeBlocks = previewEl.querySelectorAll('pre code:not(.hljs)');
                codeBlocks.forEach(block => {
                    hljs.highlightElement(block);
                });
                
                // 增強程式碼區塊顯示
                enhanceCodeBlocks(previewEl);
                
                await mermaid.run({ nodes: document.querySelectorAll('.language-mermaid') });
                
                // Process math formulas with KaTeX
                if (typeof renderMathInElement !== 'undefined') {
                    try {
                        renderMathInElement(previewEl, {
                            delimiters: [
                                { left: '$$', right: '$$', display: true },
                                { left: '$', right: '$', display: false },
                                { left: '\\[', right: '\\]', display: true },
                                { left: '\\(', right: '\\)', display: false }
                            ]
                        });
                    } catch (error) {
                        console.warn('KaTeX rendering error in main preview:', error);
                    }
                }
                
                // Add click handlers for wiki links
                previewEl.querySelectorAll('.wiki-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const fileId = e.target.dataset.fileId;
                        const sectionName = e.target.dataset.section;
                        if (fileId) {
                            loadFile(fileId);
                            if (sectionName) {
                                // Navigate to specific section after file loads
                                setTimeout(() => {
                                    navigateToSection(sectionName);
                                }, 100);
                                showNotification(`已跳轉到筆記：${e.target.textContent}`);
                            } else {
                                showNotification(`已跳轉到筆記：${e.target.textContent}`);
                            }
                        }
                    });
                });
                
                // Add hover preview for wiki links
                previewEl.querySelectorAll('.wiki-link').forEach(link => {
                    let hoverTimeout;
                    
                    link.addEventListener('mouseenter', (e) => {
                        // Only show preview if Ctrl key is pressed
                        if (e.ctrlKey) {
                            // Clear any existing hide timeout
                            const previewPopup = document.getElementById('wiki-preview-popup');
                            if (previewPopup && previewPopup.hideTimeout) {
                                clearTimeout(previewPopup.hideTimeout);
                                previewPopup.hideTimeout = null;
                            }
                            
                            hoverTimeout = setTimeout(() => {
                                const fileId = e.target.dataset.fileId;
                                const sectionName = e.target.dataset.section;
                                if (fileId) {
                                    showWikiPreview(e.target, fileId, sectionName);
                                }
                            }, 500); // 500ms delay before showing preview
                        }
                    });
                    
                    link.addEventListener('mouseleave', () => {
                        clearTimeout(hoverTimeout);
                        // Start countdown to hide preview, but only if mouse is not over the popup
                        setTimeout(() => {
                            const previewPopup = document.getElementById('wiki-preview-popup');
                            if (previewPopup && !previewPopup.matches(':hover')) {
                                previewPopup.hideTimeout = setTimeout(() => {
                                    hideWikiPreview();
                                }, 1000); // 1 second delay
                            }
                        }, 100); // Small delay to allow mouse to move to popup
                    });
                });
                
                // Add click handlers for hashtag links
                previewEl.querySelectorAll('.hashtag-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const hashtag = e.target.dataset.hashtag;
                        if (hashtag) {
                            navigateToHashtag(hashtag);
                        }
                    });
                });
                
                // 確保預覽容器可以滾動
                setTimeout(() => {
                    if (previewContainer.scrollHeight > previewContainer.clientHeight) {
                        previewContainer.style.overflowY = 'auto';
                    }
                    
                    // Rebuild line to element mapping after preview update
                    buildLineToElementMapping();
                }, 100);
            }

            // Line to DOM element mapping for precise sync
            let lineToElementMap = new Map();
            let elementToLineMap = new Map();
            
            // Build mapping between editor lines and preview DOM elements
            function buildLineToElementMapping() {
                lineToElementMap.clear();
                elementToLineMap.clear();
                
                try {
                    const previewContainer = document.getElementById('preview');
                    if (!previewContainer) return;
                    
                    const markdownText = editor.getValue();
                    const lines = markdownText.split('\n');
                    
                    // Get all significant elements from preview
                    const elements = previewContainer.querySelectorAll('h1, h2, h3, h4, h5, h6, p, pre, ul, ol, blockquote, table, hr, .mermaid');
                    
                    let elementIndex = 0;
                    let inCodeBlock = false;
                    let codeBlockStartLine = -1;
                    
                    // Improved mapping strategy
                    for (let i = 0; i < lines.length && elementIndex < elements.length; i++) {
                        const line = lines[i];
                        const trimmedLine = line.trim();
                        
                        // Handle code blocks specially
                        if (trimmedLine.startsWith('```')) {
                            if (!inCodeBlock) {
                                inCodeBlock = true;
                                codeBlockStartLine = i;
                            } else {
                                inCodeBlock = false;
                                // Map the entire code block to the pre element
                                const element = elements[elementIndex];
                                if (element && (element.tagName === 'PRE' || element.classList.contains('mermaid'))) {
                                    lineToElementMap.set(codeBlockStartLine, element);
                                    elementToLineMap.set(element, codeBlockStartLine);
                                    element.setAttribute('data-line', codeBlockStartLine);
                                    elementIndex++;
                                }
                            }
                            continue;
                        }
                        
                        // Skip lines inside code blocks
                        if (inCodeBlock) continue;
                        
                        // Skip empty lines
                        if (!trimmedLine) continue;
                        
                        // Map different markdown elements
                        let shouldMap = false;
                        const element = elements[elementIndex];
                        
                        if (trimmedLine.match(/^#{1,6}\s/)) {
                            // Headers
                            shouldMap = element && element.tagName.match(/^H[1-6]$/);
                        } else if (trimmedLine.match(/^\s*[-*+]\s/) || trimmedLine.match(/^\s*\d+\.\s/)) {
                            // List items - map to ul/ol, not individual li
                            shouldMap = element && (element.tagName === 'UL' || element.tagName === 'OL');
                        } else if (trimmedLine.match(/^>\s/)) {
                            // Blockquotes
                            shouldMap = element && element.tagName === 'BLOCKQUOTE';
                        } else if (trimmedLine.match(/^\|.*\|/)) {
                            // Tables
                            shouldMap = element && element.tagName === 'TABLE';
                        } else if (trimmedLine.match(/^---+$/)) {
                            // Horizontal rules
                            shouldMap = element && element.tagName === 'HR';
                        } else if (trimmedLine.length > 0) {
                            // Regular paragraphs
                            shouldMap = element && element.tagName === 'P';
                        }
                        
                        if (shouldMap && element) {
                            lineToElementMap.set(i, element);
                            elementToLineMap.set(element, i);
                            element.setAttribute('data-line', i);
                            elementIndex++;
                        }
                    }
                    
                    console.log(`Built improved line mapping: ${lineToElementMap.size} elements mapped from ${elements.length} total elements`);
                } catch (error) {
                    console.warn('Error building line mapping:', error);
                }
            }
            
            // Find the closest preview element for a given line number
            function findPreviewElementByLine(lineNumber) {
                // Direct mapping first
                if (lineToElementMap.has(lineNumber)) {
                    return lineToElementMap.get(lineNumber);
                }
                
                // Find closest mapped line
                let closestLine = -1;
                let closestDistance = Infinity;
                
                for (const [mappedLine] of lineToElementMap) {
                    const distance = Math.abs(mappedLine - lineNumber);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestLine = mappedLine;
                    }
                }
                
                return closestLine >= 0 ? lineToElementMap.get(closestLine) : null;
            }

            function syncPreviewScroll() {
                if (isSyncing || !syncScrollEnabled) return;
                isSyncing = true;
                
                try {
                    // Use the preview container parent which is the actual scrollable container
                    const previewContainer = document.querySelector('.preview-container');
                    if (!previewContainer) return;
                    
                    // Get scroll info from editor
                    const scrollInfo = editor.getScrollInfo();
                    const editorMaxScroll = scrollInfo.height - scrollInfo.clientHeight;
                    const previewMaxScroll = previewContainer.scrollHeight - previewContainer.clientHeight;
                    
                    // Simple ratio-based sync (now should work correctly with matched bottom padding)
                    if (editorMaxScroll > 0 && previewMaxScroll > 0) {
                        const editorRatio = scrollInfo.top / editorMaxScroll;
                        previewContainer.scrollTop = previewMaxScroll * editorRatio;
                    }
                    
                } catch (error) {
                    console.warn('Sync scroll error:', error);
                }
                
                setTimeout(() => { isSyncing = false; }, 50);
            }

            // Find the line number for a given preview element
            function findLineByPreviewElement(element) {
                if (elementToLineMap.has(element)) {
                    return elementToLineMap.get(element);
                }
                
                // Check if element has data-line attribute
                const dataLine = element.getAttribute('data-line');
                if (dataLine !== null) {
                    return parseInt(dataLine);
                }
                
                // Find closest parent with line mapping
                let current = element.parentElement;
                while (current && current !== document.getElementById('preview')) {
                    if (elementToLineMap.has(current)) {
                        return elementToLineMap.get(current);
                    }
                    const parentDataLine = current.getAttribute('data-line');
                    if (parentDataLine !== null) {
                        return parseInt(parentDataLine);
                    }
                    current = current.parentElement;
                }
                
                return null;
            }
            
            function syncEditorScroll() {
                if (isSyncing || !syncScrollEnabled) return;
                isSyncing = true;
                
                try {
                    // Use the preview container parent which is the actual scrollable container
                    const previewContainer = document.querySelector('.preview-container');
                    if (!previewContainer) return;
                    
                    // Simple ratio-based reverse sync
                    const previewMaxScroll = previewContainer.scrollHeight - previewContainer.clientHeight;
                    const editorScrollInfo = editor.getScrollInfo();
                    const editorMaxScroll = editorScrollInfo.height - editorScrollInfo.clientHeight;
                    
                    if (previewMaxScroll > 0 && editorMaxScroll > 0) {
                        const previewRatio = previewContainer.scrollTop / previewMaxScroll;
                        editor.scrollTo(null, editorMaxScroll * previewRatio);
                    }
                    
                } catch (error) {
                    console.warn('Reverse sync scroll error:', error);
                }
                
                setTimeout(() => { isSyncing = false; }, 50);
            }

            // Toggle sync scroll functionality
            function toggleSyncScroll() {
                syncScrollEnabled = !syncScrollEnabled;
                const syncScrollToggle = document.getElementById('sync-scroll-toggle');
                if (syncScrollToggle) {
                    if (syncScrollEnabled) {
                        syncScrollToggle.classList.add('active');
                        syncScrollToggle.title = '同步滾動 (已開啟)';
                    } else {
                        syncScrollToggle.classList.remove('active');
                        syncScrollToggle.title = '同步滾動 (已關閉)';
                    }
                }
            }

            // --- Table of Contents ---
            function generateToc() {
                tocListEl.innerHTML = '';
                if (!editor) return;
                editor.getValue().split('\n').forEach((line, index) => {
                    const match = line.match(/^(#+)\s+(.*)/);
                    if (match) {
                        const li = document.createElement('li');
                        li.textContent = match[2];
                        li.className = `toc-h${match[1].length}`;
                        li.dataset.line = index;
                        tocListEl.appendChild(li);
                    }
                });
            }
            
            function updateToc() {
                generateToc();
            }

            function navigateToTocLine(line) {
                editor.setCursor({ line: parseInt(line), ch: 0 });
                editor.focus();
                
                // Auto close sidebar on mobile after navigation
                if (isMobileDevice() && sidebarVisible) {
                    closeSidebar();
                }
            }

            // --- Time and Task Management ---
            function updateCurrentTime() { 
                updateTimerDisplay();
            }
            
            function updateTimerDisplay() {
                if (isTimerRunning && currentTimerStartTime) {
                    const elapsed = Math.floor((Date.now() - currentTimerStartTime) / 1000);
                    timerDisplay.textContent = formatDurationShort(elapsed);
                    timerBtn.classList.add('timing');
                } else {
                    const now = new Date();
                    timerDisplay.textContent = now.toTimeString().substring(0, 5); // HH:MM
                    timerBtn.classList.remove('timing');
                }
            }
            
            function formatDuration(s) { return new Date(s * 1000).toISOString().substr(11, 8); }
            function formatDurationShort(s) {
                const hours = Math.floor(s / 3600);
                const minutes = Math.floor((s % 3600) / 60);
                return hours > 0 ? `${hours}:${String(minutes).padStart(2, '0')}` : `${minutes}:${String(s % 60).padStart(2, '0')}`;
            }
            
            function getTodayDateString() {
                return new Date().toISOString().split('T')[0];
            }
            
            function getDateString(date) {
                return date.toISOString().split('T')[0];
            }
            
            // Timer History Management
            async function addTaskToHistory(task) {
                const dateStr = getDateString(task.startTime);
                if (!timerHistory[dateStr]) {
                    timerHistory[dateStr] = [];
                }
                
                // 使用任務開始時已經記錄的檔案和章節資訊，不再重新獲取
                // task.fileId, task.fileName, task.section 已經在任務創建時設定
                
                timerHistory[dateStr].push(task);
                await saveTimerHistory();
            }
            
            function getCurrentSection() {
                if (!editor) return null;
                
                const cursor = editor.getCursor();
                const lines = editor.getValue().split('\n');
                let currentSection = null;
                
                // Find the most recent heading before current cursor position
                for (let i = cursor.line; i >= 0; i--) {
                    const match = lines[i].match(/^(#+)\s+(.*)/);
                    if (match) {
                        currentSection = {
                            level: match[1].length,
                            title: match[2],
                            line: i
                        };
                        break;
                    }
                }
                
                return currentSection;
            }
            
            function navigateToTask(task) {
                if (task.fileId && task.fileId !== (currentFile ? currentFile.id : null)) {
                    // Switch to the correct file first
                    loadFile(task.fileId);
                }
                
                // Navigate to section if available
                if (task.section && task.section.line !== undefined) {
                    setTimeout(() => {
                        editor.setCursor({ line: task.section.line, ch: 0 });
                        editor.focus();
                        timerModal.style.display = 'none';
                    }, 100);
                } else {
                    timerModal.style.display = 'none';
                }
            }

            // 自動計時處理函數 - 基於Enter按鍵觸發
            // 當用戶按Enter後，檢查前一行的內容來決定是否開始/切換計時
            
            async function handleAutoTimerOnEnter(changeObj) {
                console.log('handleAutoTimerOnEnter called - Enter key detected');
                
                if (!currentFile) {
                    console.log('沒有當前檔案，跳過自動計時');
                    return;
                }
                
                // Enter按鍵後，新行被插入在 changeObj.from.line 位置
                // 我們需要檢查當前光標位置所屬的章節
                const currentLineNum = changeObj.from.line;
                
                console.log(`Enter按鍵在第${currentLineNum + 1}行觸發，檢查當前位置所屬章節`);
                
                // 先檢查是否在上一行輸入了結束線
                if (currentLineNum > 0) {
                    const previousLine = editor.getLine(currentLineNum - 1);
                    if (previousLine && previousLine.trim() === '---') {
                        console.log('偵測到前一行是結束線 ---，停止計時');
                        if (isTimerRunning) {
                            console.log('停止目前進行中的任務');
                            await stopCurrentTask();
                        }
                        return;
                    }
                }
                
                // 找到當前位置所屬的章節（向上查找最近的標題）
                const currentSection = findCurrentSection(currentLineNum);
                if (!currentSection) {
                    console.log('未找到當前位置的章節標題，無法開始計時');
                    return;
                }
                
                console.log(`當前位置屬於章節：「${currentSection.title}」(第${currentSection.line + 1}行，層級${currentSection.level})`);
                
                // 檢查是否需要切換任務（檢查檔案和章節）
                const needSwitchTask = !isTimerRunning || 
                                     !currentTask || 
                                     !currentTask.hierarchy ||
                                     currentTask.fileId !== currentFile.id ||  // 檢查是否為不同檔案
                                     currentTask.hierarchy[currentTask.hierarchy.length - 1]?.line !== currentSection.line;
                
                if (needSwitchTask) {
                    let switchReason = '';
                    if (!isTimerRunning) {
                        switchReason = '目前沒有計時任務';
                    } else if (!currentTask) {
                        switchReason = '沒有當前任務';
                    } else if (currentTask.fileId !== currentFile.id) {
                        switchReason = `檔案切換 (從 ${currentTask.fileName || '未知檔案'} 到 ${currentFile.name})`;
                    } else if (currentTask.hierarchy[currentTask.hierarchy.length - 1]?.line !== currentSection.line) {
                        switchReason = '章節切換';
                    }
                    
                    console.log(`需要切換任務：${switchReason}`);
                    
                    // 停止當前任務（如果有的話）
                    if (isTimerRunning && currentTask) {
                        console.log(`停止目前進行中的任務：${currentTask.name}`);
                        await stopCurrentTask();
                    }
                    
                    // 開始新的章節任務，使用完整的層級結構
                    await startAutoTaskWithHierarchy(currentSection.line, currentSection.title);
                } else {
                    console.log('在當前計時章節中按Enter，繼續計時');
                }
            }

            // 獲取標題的完整層級路徑（只包含直系祖先）
            function getHeadingHierarchy(lineNumber) {
                const lines = editor.getValue().split('\n');
                const currentLine = lines[lineNumber];
                const currentMatch = currentLine.match(/^(#+)\s+(.+)$/);
                
                console.log(`getHeadingHierarchy: 分析第${lineNumber + 1}行的層級結構`);
                console.log(`getHeadingHierarchy: 當前行內容: "${currentLine}"`);
                
                if (!currentMatch) {
                    console.log('getHeadingHierarchy: 當前行不是標題格式');
                    return null;
                }
                
                const currentLevel = currentMatch[1].length;
                const currentTitle = currentMatch[2].trim();
                console.log(`getHeadingHierarchy: 當前標題: "${currentTitle}" (層級${currentLevel})`);
                
                const hierarchy = [];
                
                // 追蹤需要找的下一個父級層級
                let nextParentLevel = currentLevel - 1;
                console.log(`getHeadingHierarchy: 開始尋找父級標題，下一層級: ${nextParentLevel}`);
                
                // 往上找直系祖先標題
                for (let i = lineNumber - 1; i >= 0 && nextParentLevel > 0; i--) {
                    const line = lines[i];
                    const match = line.match(/^(#+)\s+(.+)$/);
                    if (match) {
                        const level = match[1].length;
                        const title = match[2].trim();
                        
                        // 只找直系父級（層級剛好少1的標題）
                        if (level === nextParentLevel) {
                            console.log(`getHeadingHierarchy: 找到父級標題: "${title}" (層級${level}, 行${i + 1})`);
                            hierarchy.unshift({ level, title, line: i });
                            nextParentLevel = level - 1; // 繼續找上一級的父級
                        }
                    }
                }
                
                // 加入當前標題
                hierarchy.push({ level: currentLevel, title: currentTitle, line: lineNumber });
                
                console.log(`getHeadingHierarchy: 完整層級路徑:`, hierarchy.map(h => h.title).join(' → '));
                return hierarchy;
            }
            
            // 找到指定行號所屬的標題章節
            function findCurrentSection(lineNumber) {
                const lines = editor.getValue().split('\n');
                
                console.log(`findCurrentSection: 從第${lineNumber + 1}行往上查找標題`);
                
                // 從指定行號往上查找最近的標題行
                for (let i = lineNumber; i >= 0; i--) {
                    const line = lines[i];
                    const match = line.match(/^(#+)\s+(.+)$/);
                    if (match) {
                        const level = match[1].length;
                        const title = match[2].trim();
                        console.log(`findCurrentSection: 找到標題「${title}」在第${i + 1}行 (層級${level})`);
                        return {
                            line: i,
                            level: level,
                            title: title,
                            fullLine: line
                        };
                    }
                }
                
                console.log('findCurrentSection: 沒有找到任何標題');
                return null; // 沒有找到標題
            }
            
            // 構建帶層級的任務名稱
            function buildHierarchicalTaskName(hierarchy) {
                if (!hierarchy || hierarchy.length === 0) return '未命名任務';
                
                // 取得文件名（去掉副檔名）
                const fileName = currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") : '未命名文件';
                
                // 構建層級路徑
                const hierarchyPath = hierarchy.map(h => h.title).join('_');
                
                return `${fileName}_${hierarchyPath}`;
            }
            
            // 帶層級的自動任務開始
            async function startAutoTaskWithHierarchy(lineNumber, taskName) {
                console.log(`開始層級自動計時：${taskName} (行號: ${lineNumber + 1})`);
                
                const hierarchy = getHeadingHierarchy(lineNumber);
                if (!hierarchy) {
                    console.log('無法獲取層級結構，使用簡單任務名稱');
                    await startAutoTask(taskName);
                    return;
                }
                
                const hierarchicalName = buildHierarchicalTaskName(hierarchy);
                
                console.log('層級結構:', hierarchy.map(h => `${h.level}級: ${h.title} (行${h.line + 1})`));
                console.log('完整層級路徑:', hierarchy.map(h => h.title).join(' → '));
                console.log('最終任務名稱:', hierarchicalName);
                
                const now = new Date();
                currentTask = { 
                    id: `auto-task-${now.getTime()}`, 
                    name: `📝 ${hierarchicalName}`, 
                    originalTitle: taskName,
                    hierarchy: hierarchy,
                    startTime: now, 
                    endTime: null, 
                    duration: 0,
                    isAutoGenerated: true,
                    // 在任務開始時就固定檔案和章節資訊
                    fileId: currentFile ? currentFile.id : null,
                    fileName: currentFile ? currentFile.name : null,
                    section: getCurrentSection()
                };
                tasks.push(currentTask);
                isTimerRunning = true;
                currentTimerStartTime = now.getTime();
                updateTimerUI();
                await saveTasks();
                
                // Update modal UI if it's open
                if (timerModal.style.display === 'block') {
                    updateModalTimerUI();
                }
                
                // 顯示通知
                showNotification(`已開始計時：${taskName}`);
            }
            
            // 保留舊的函數用於手動任務
            async function startAutoTask(taskName) {
                console.log(`開始自動計時：${taskName}`);
                const now = new Date();
                currentTask = { 
                    id: `auto-task-${now.getTime()}`, 
                    name: `📝 ${taskName}`, 
                    startTime: now, 
                    endTime: null, 
                    duration: 0,
                    isAutoGenerated: true,
                    // 在任務開始時就固定檔案和章節資訊
                    fileId: currentFile ? currentFile.id : null,
                    fileName: currentFile ? currentFile.name : null,
                    section: getCurrentSection()
                };
                tasks.push(currentTask);
                isTimerRunning = true;
                currentTimerStartTime = now.getTime();
                updateTimerUI();
                await saveTasks();
                
                // Update modal UI if it's open
                if (timerModal.style.display === 'block') {
                    updateModalTimerUI();
                }
                
                // 顯示通知
                showNotification(`已開始計時：${taskName}`);
            }

            // 顯示通知
            function showNotification(message) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed; 
                    top: 60px; 
                    right: 20px; 
                    background: var(--accent-color); 
                    color: white; 
                    padding: 10px 20px; 
                    border-radius: 6px; 
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
                    z-index: 1002; 
                    font-size: 14px;
                    opacity: 0;
                    transition: opacity 0.3s;
                `;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                // 淡入效果
                setTimeout(() => notification.style.opacity = '1', 100);
                
                // 3秒後移除
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(notification), 300);
                }, 3000);
            }

            
            async function startModalTask() {
                if (isTimerRunning) await stopCurrentTask();
                const taskName = modalTaskInput.value.trim() || `未命名任務`;
                const now = new Date();
                currentTask = { 
                    id: `modal-task-${now.getTime()}`, 
                    name: taskName, 
                    startTime: now, 
                    endTime: null, 
                    duration: 0,
                    // 在任務開始時就固定檔案和章節資訊
                    fileId: currentFile ? currentFile.id : null,
                    fileName: currentFile ? currentFile.name : null,
                    section: getCurrentSection()
                };
                tasks.push(currentTask);
                isTimerRunning = true;
                currentTimerStartTime = now.getTime();
                updateModalTimerUI();
                await saveTasks();
                showNotification(`已開始計時：${taskName}`);
            }

            async function stopCurrentTask() {
                if (!currentTask) return;
                currentTask.endTime = new Date();
                currentTask.duration = Math.round((currentTask.endTime - currentTask.startTime) / 1000);
                
                // Add to timer history
                await addTaskToHistory(currentTask);
                
                // 如果是自動生成的任務，顯示完成通知
                if (currentTask.isAutoGenerated) {
                    showNotification(`計時結束：${currentTask.name.replace('📝 ', '')} (${formatDuration(currentTask.duration)})`);
                }
                
                isTimerRunning = false; 
                currentTimerStartTime = null;
                currentTask = null;
                updateTimerUI(); 
                updateModalTimerUI();
                await saveTasks();
                
                // Update timeline if modal is open
                if (timerModal.style.display === 'block') {
                    renderTimeline();
                }
            }
            
            function updateModalTimerUI() {
                if (modalStartBtn) modalStartBtn.disabled = isTimerRunning;
                if (modalStopBtn) modalStopBtn.disabled = !isTimerRunning;
                if (modalTaskInput) modalTaskInput.value = '';
            }

            function updateTimerUI() {
                // This function is kept for compatibility but doesn't need to do anything now
            }

            function renderTasks() {
                // This function is kept for compatibility with existing task system
                // The new timer system uses renderTimeline() instead
            }

            function insertGanttChart() {
                // Get today's tasks from timer history
                const todayStr = getTodayDateString();
                const todayTasks = timerHistory[todayStr] || [];
                const completedTasks = todayTasks.filter(task => task.endTime);
                
                if (completedTasks.length === 0) {
                    showNotification('今日沒有已完成的任務可生成甘特圖');
                    return;
                }
                
                // Sort tasks by start time
                const sortedTasks = [...completedTasks].sort((a, b) => a.startTime - b.startTime);
                
                // Create hourly-based Gantt chart with today's date
                const today = new Date();
                const todayDateStr = today.toISOString().split('T')[0];
                
                let gantt = `\`\`\`mermaid
gantt
    title 今日任務甘特圖 (${todayDateStr})
    dateFormat YYYY-MM-DD HH:mm
    axisFormat %H:%M
    
    section 今日任務
`;
                
                sortedTasks.forEach((task, index) => {
                    const taskName = task.name.replace(/📝 /, '').replace(/[:\[\]]/g, ''); // Clean task name
                    const startTime = `${todayDateStr} ${safeTimeToString(task.startTime)}`;
                    const endTime = `${todayDateStr} ${safeTimeToString(task.endTime)}`;
                    const duration = Math.round(task.duration / 60); // Convert to minutes for better display
                    
                    gantt += `    ${taskName} (${duration}min) :done, task${index + 1}, ${startTime}, ${endTime}\n`;
                });
                
                gantt += '```';
                editor.replaceSelection(gantt);
                showNotification(`已插入包含 ${completedTasks.length} 個任務的小時制甘特圖`);
            }

            // --- File Management & Persistence ---
            function handleFileSelection(event) {
                Array.from(event.target.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const newFile = { id: `file-${Date.now()}-${Math.random()}`, name: file.name, content: e.target.result };
                        files.push(newFile);
                        await saveFilesToStorage(); renderFileList(); loadFile(newFile.id);
                    };
                    reader.readAsText(file);
                });
            }

            // Wiki preview functions
            function showWikiPreview(linkElement, fileId, sectionName) {
                const previewPopup = document.getElementById('wiki-preview-popup');
                const previewTitle = document.getElementById('wiki-preview-title');
                const previewContent = document.getElementById('wiki-preview-content');
                
                // Find the target file
                const targetFile = files.find(f => f.id === fileId);
                if (!targetFile) return;
                
                // Set title
                previewTitle.textContent = targetFile.name + (sectionName ? ` - ${sectionName}` : '');
                
                // Render content
                let content = targetFile.content;
                if (sectionName) {
                    // Extract content for specific section
                    const lines = content.split('\n');
                    let startIndex = -1;
                    let endIndex = lines.length;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line.match(/^#{1,6}\s/) && line.includes(sectionName)) {
                            startIndex = i;
                            break;
                        }
                    }
                    
                    if (startIndex !== -1) {
                        // Find the end of this section
                        const headerLevel = lines[startIndex].match(/^(#{1,6})/)[1].length;
                        for (let i = startIndex + 1; i < lines.length; i++) {
                            const line = lines[i].trim();
                            const match = line.match(/^(#{1,6})\s/);
                            if (match && match[1].length <= headerLevel) {
                                endIndex = i;
                                break;
                            }
                        }
                        content = lines.slice(startIndex, endIndex).join('\n');
                    }
                }
                
                // Render full markdown content with all features
                try {
                    // Use the same markdown renderer as the main preview
                    previewContent.innerHTML = marked.parse(content);
                    
                    // Process mermaid diagrams if they exist
                    const mermaidElements = previewContent.querySelectorAll('code.language-mermaid, .mermaid');
                    if (mermaidElements.length > 0 && typeof mermaid !== 'undefined') {
                        mermaidElements.forEach((element, index) => {
                            const mermaidCode = element.textContent;
                            const mermaidId = `mermaid-preview-${Date.now()}-${index}`;
                            element.id = mermaidId;
                            element.innerHTML = mermaidCode;
                            element.className = 'mermaid';
                            
                            // Initialize mermaid for this element
                            mermaid.init(undefined, element);
                        });
                    }
                    
                    // Process math formulas with KaTeX
                    if (typeof renderMathInElement !== 'undefined') {
                        try {
                            renderMathInElement(previewContent, {
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false },
                                    { left: '\\[', right: '\\]', display: true },
                                    { left: '\\(', right: '\\)', display: false }
                                ]
                            });
                        } catch (error) {
                            console.warn('KaTeX rendering error in wiki preview:', error);
                        }
                    }
                    
                    // Process any other elements that need special handling
                    const links = previewContent.querySelectorAll('a[href^="http"]');
                    links.forEach(link => {
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                    });
                    
                } catch (error) {
                    console.error('Error rendering preview content:', error);
                    previewContent.innerHTML = '<p>預覽渲染錯誤</p>';
                }
                
                // Position popup near the link
                const rect = linkElement.getBoundingClientRect();
                const previewContainer = document.getElementById('preview');
                const previewRect = previewContainer ? previewContainer.getBoundingClientRect() : { width: window.innerWidth * 0.5 };
                const popupWidth = previewRect.width * 0.8; // 80% of preview container width
                const popupHeight = 400;
                
                let left = rect.right + 10;
                let top = rect.top;
                
                // Adjust position if popup would go off screen
                if (left + popupWidth > window.innerWidth) {
                    left = rect.left - popupWidth - 10;
                }
                if (top + popupHeight > window.innerHeight) {
                    top = window.innerHeight - popupHeight - 10;
                }
                if (top < 0) top = 10;
                
                previewPopup.style.left = left + 'px';
                previewPopup.style.top = top + 'px';
                previewPopup.style.width = popupWidth + 'px';
                
                // Show popup
                previewPopup.classList.add('show');
                
                // Initialize hide timeout property
                previewPopup.hideTimeout = null;
                
                // Remove any existing event listeners to avoid duplicates
                previewPopup.onmouseenter = null;
                previewPopup.onmouseleave = null;
                
                // Add mouse events to popup itself
                previewPopup.onmouseenter = () => {
                    // Cancel any pending hide timeout when mouse enters popup
                    if (previewPopup.hideTimeout) {
                        clearTimeout(previewPopup.hideTimeout);
                        previewPopup.hideTimeout = null;
                    }
                };
                
                previewPopup.onmouseleave = () => {
                    // Delay hiding preview by 1 second when leaving popup
                    previewPopup.hideTimeout = setTimeout(() => {
                        hideWikiPreview();
                    }, 1000);
                };
            }
            
            function hideWikiPreview() {
                const previewPopup = document.getElementById('wiki-preview-popup');
                if (previewPopup) {
                    previewPopup.classList.remove('show');
                    // Clear any pending timeout
                    if (previewPopup.hideTimeout) {
                        clearTimeout(previewPopup.hideTimeout);
                        previewPopup.hideTimeout = null;
                    }
                }
            }
            
            // Hashtag functionality
            function getCurrentFileName() {
                // Always return the current file name (without .md extension)
                return currentFile ? currentFile.name.replace('.md', '') : 'Untitled';
            }
            
            async function handleHashtagCreation(hashtag, fileName) {
                
                // Find or create NoteTag.md file
                let noteTagFile = files.find(f => f.name === 'NoteTag.md');
                
                if (!noteTagFile) {
                    // Create new NoteTag.md file
                    noteTagFile = {
                        id: Date.now().toString(),
                        name: 'NoteTag.md',
                        content: '# Note Tags\n\n'
                    };
                    files.push(noteTagFile);
                    updateFileList();
                }
                
                // Check if this hashtag already exists in NoteTag.md
                const hashtagHeaderRegex = new RegExp(`^### ${hashtag}$`, 'm');
                if (!hashtagHeaderRegex.test(noteTagFile.content)) {
                    // Add new hashtag section
                    const newSection = `\n### ${hashtag}\n[[${fileName}]]\n`;
                    noteTagFile.content += newSection;
                } else {
                    // Add link to existing hashtag section
                    const lines = noteTagFile.content.split('\n');
                    let insertIndex = -1;
                    
                    // Find the hashtag header
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i] === `### ${hashtag}`) {
                            // Find the next header or end of file
                            insertIndex = i + 1;
                            // Skip empty lines after header
                            while (insertIndex < lines.length && lines[insertIndex].trim() === '') {
                                insertIndex++;
                            }
                            
                            // Find where to insert (before next header or at end)
                            while (insertIndex < lines.length && !lines[insertIndex].match(/^###\s/)) {
                                insertIndex++;
                            }
                            break;
                        }
                    }
                    
                    if (insertIndex !== -1) {
                        // Check if this link already exists in the content
                        const linkToAdd = `[[${fileName}]]`;
                        let linkExists = false;
                        
                        // Check if the link already exists in this hashtag section
                        // Look from the hashtag header to the next header (or end of file)
                        let hashtagStartIndex = -1;
                        for (let i = 0; i < lines.length; i++) {
                            if (lines[i] === `### ${hashtag}`) {
                                hashtagStartIndex = i;
                                break;
                            }
                        }
                        
                        if (hashtagStartIndex !== -1) {
                            // Check from header to next header or end of file
                            for (let i = hashtagStartIndex + 1; i < lines.length; i++) {
                                if (lines[i].match(/^###\s/)) break; // reached next header
                                if (lines[i].includes(`[[${fileName}]]`)) {
                                    linkExists = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!linkExists) {
                            // Find where to add the link - right after the hashtag header
                            if (hashtagStartIndex !== -1) {
                                // Check if there's already content on the line after the header
                                const contentLineIndex = hashtagStartIndex + 1;
                                if (contentLineIndex < lines.length && lines[contentLineIndex].trim() !== '') {
                                    // Add to existing content on same line
                                    lines[contentLineIndex] += ` ${linkToAdd}`;
                                } else {
                                    // Create new line with the link
                                    lines.splice(contentLineIndex, 0, linkToAdd);
                                }
                                noteTagFile.content = lines.join('\n');
                            }
                        }
                    }
                }
                
                await saveFilesToStorage();
            }
            
            // Function to detect hashtag changes and update related files
            async function detectAndUpdateHashtagChanges() {
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) return;
                
                // Extract current hashtags from NoteTag.md
                const currentHashtags = new Map();
                const hashtagRegex = /^### (.+)$/gm;
                let match;
                
                while ((match = hashtagRegex.exec(noteTagFile.content)) !== null) {
                    const hashtagTitle = match[1];
                    currentHashtags.set(hashtagTitle, hashtagTitle);
                }
                
                // Compare with original hashtags to detect changes
                const changes = [];
                
                // Check for renamed hashtags (assuming position-based changes)
                const originalTitles = Array.from(originalHashtags.keys());
                const currentTitles = Array.from(currentHashtags.keys());
                
                // Simple approach: detect if hashtag count is same but content changed
                if (originalTitles.length === currentTitles.length) {
                    for (let i = 0; i < originalTitles.length; i++) {
                        if (originalTitles[i] !== currentTitles[i]) {
                            changes.push({
                                oldTitle: originalTitles[i],
                                newTitle: currentTitles[i]
                            });
                        }
                    }
                }
                
                // Update all files that contain the changed hashtags
                if (changes.length > 0) {
                    for (const change of changes) {
                        await updateHashtagInAllFiles(change.oldTitle, change.newTitle);
                    }
                    
                    // Update originalHashtags map
                    originalHashtags.clear();
                    currentHashtags.forEach((value, key) => {
                        originalHashtags.set(key, value);
                    });
                    
                    // Refresh preview if current file was updated
                    updatePreview();
                    
                    showNotification(`已更新標籤：${changes.map(c => `#${c.oldTitle} → #${c.newTitle}`).join(', ')}`);
                }
            }
            
            // Function to update hashtag references in all files
            async function updateHashtagInAllFiles(oldTitle, newTitle) {
                for (const file of files) {
                    if (file.name === 'NoteTag.md') continue; // Skip NoteTag.md itself
                    
                    let updated = false;
                    let content = file.content;
                    
                    // Update hashtag references in the file
                    // Match #oldTitle at word boundaries
                    const hashtagPattern = new RegExp(`(^|\\s)#${oldTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(?=\\s|$)`, 'gm');
                    const newContent = content.replace(hashtagPattern, `$1#${newTitle}`);
                    
                    if (newContent !== content) {
                        file.content = newContent;
                        file.lastModified = Date.now();
                        updated = true;
                    }
                    
                    // If this is the currently displayed file, update the editor
                    if (updated && currentFile && currentFile.id === file.id) {
                        editor.setValue(file.content);
                    }
                }
                
                await saveFilesToStorage();
            }
            
            // Function to initialize hashtag tracking
            function initializeHashtagTracking() {
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) return;
                
                // Store initial hashtag state
                originalHashtags.clear();
                const hashtagRegex = /^### (.+)$/gm;
                let match;
                
                while ((match = hashtagRegex.exec(noteTagFile.content)) !== null) {
                    const hashtagTitle = match[1];
                    originalHashtags.set(hashtagTitle, hashtagTitle);
                }
            }
            
            function loadFile(fileId) {
                const previousFile = currentFile;
                
                // Sync hashtag changes for the previous file before switching
                if (previousFile && previousFile.name !== 'NoteTag.md' && editor) {
                    console.log(`🔄 Syncing hashtags before switching from ${previousFile.name}`);
                    syncHashtagChanges(previousFile.id, editor.getValue());
                }
                
                // Check if we're switching away from NoteTag.md and need to trigger hashtag update
                if (currentFile && currentFile.name === 'NoteTag.md' && hashtagUpdateTimer) {
                    clearTimeout(hashtagUpdateTimer);
                    // Immediately trigger hashtag update when switching files
                    detectAndUpdateHashtagChanges().then(() => {
                        hashtagUpdateTimer = null;
                    });
                }
                
                // 切換檔案時不中斷計時，讓計時繼續進行
                if (autoTimerEnabled && isTimerRunning && currentTask) {
                    console.log(`切換檔案：從 "${previousFile?.name}" 到 "${files.find(f => f.id === fileId)?.name}"，計時繼續進行`);
                }
                
                currentFile = files.find(f => f.id === fileId) || files[0];
                if (!currentFile) return;
                
                console.log(`載入檔案：${currentFile.name}`);
                
                // Initialize hashtag tracking when loading NoteTag.md
                if (currentFile.name === 'NoteTag.md') {
                    setTimeout(() => {
                        initializeHashtagTracking();
                    }, 100);
                }
                
                // Initialize hashtag snapshot for the current file
                initializeHashtagSnapshot(currentFile.id);
                
                editor.setValue(currentFile.content);
                
                // Apply hashtag highlighting after content is loaded
                setTimeout(() => {
                    applyHashtagHighlighting();
                }, 100);
                editor.clearHistory();
                currentFileNameEl.textContent = currentFile.name;
                renderFileList();
                generateToc(); // 刷新目錄
				// Re-highlight search results for the newly loaded file
                if (searchBar.classList.contains('active')) { // Only if search bar is active
                    highlightAllSearchResults();
                    highlightCurrentMatch(); // Ensure the current match is highlighted if it's in this file
                }
                
                // Auto close sidebar on mobile after loading file
                if (isMobileDevice() && sidebarVisible) {
                    closeSidebar();
                }
                
                // Only save configuration if not currently loading configuration
                if (!isLoadingConfiguration) {
                    saveConfiguration(); // Auto-save configuration
                }
            }

            // File sorting state
            let fileSortMode = 'name-asc'; // 'name-asc', 'name-desc', 'time-asc', 'time-desc'
            
            // Configuration loading state
            let isLoadingConfiguration = false;
            
            function renderFileList() {
                fileListEl.innerHTML = '';
                if (files.length === 0) {
                    fileListEl.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">尚未開啟任何檔案</div>';
                    return;
                }
                
                // Sort files - system files follow normal sort order, not pinned to top
                const sortedFiles = getSortedFiles();
                
                sortedFiles.forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.dataset.fileId = file.id;
                    if (currentFile && currentFile.id === file.id) item.classList.add('active');
                    
                    // Add system file class for styling if needed
                    if (isSystemFile(file.name)) {
                        item.classList.add('system-file');
                    }
                    
                    // Add unsync file class only for files explicitly marked in NoteTag.md
                    if (syncManager && syncManager.isUnsyncInNoteTag(file, files)) {
                        item.classList.add('unsync-file');
                    }
                    
                    // Add pinned class for user-pinned files
                    if (pinnedFiles.has(file.id)) {
                        item.classList.add('pinned');
                    }
                    
                    const isPinned = pinnedFiles.has(file.id);
                    const pinIcon = isPinned ? 'fas fa-thumbtack' : 'fas fa-thumbtack';
                    
                    item.innerHTML = `
                        <div class="file-item-name" data-file-id="${file.id}">${file.name}</div>
                        <button class="pin-button ${isPinned ? 'pinned' : ''}" data-file-id="${file.id}" title="${isPinned ? '取消釘選' : '釘選檔案'}">
                            <i class="${pinIcon}"></i>
                        </button>
                        <div class="file-item-actions">
                            <button class="file-action-btn rename-btn" data-file-id="${file.id}" title="重新命名">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="file-action-btn delete-btn" data-file-id="${file.id}" title="刪除檔案">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                    
                    fileListEl.appendChild(item);
                });
            }
            
            function isSystemFile(fileName) {
                return fileName === 'NoteTag.md' || fileName === 'NoteTask.md' || fileName === 'NoteConfig.md';
            }
            
            // Helper function to sort file arrays based on current sort mode
            function sortFileArray(fileArray, sortMode) {
                switch (sortMode) {
                    case 'name-asc':
                        fileArray.sort((a, b) => a.name.localeCompare(b.name));
                        break;
                    case 'name-desc':
                        fileArray.sort((a, b) => b.name.localeCompare(a.name));
                        break;
                    case 'time-asc':
                        fileArray.sort((a, b) => (a.lastModified || 0) - (b.lastModified || 0));
                        break;
                    case 'time-desc':
                        fileArray.sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0));
                        break;
                }
            }
            
            function getSortedFiles() {
                // Separate files into three categories:
                // 1. Pinned files (including pinned system files) - appear at top
                // 2. Regular non-system files - appear in middle  
                // 3. Unpinned system files - appear at bottom
                const pinnedFiles_array = files.filter(file => pinnedFiles.has(file.id));
                const regularFiles = files.filter(file => !pinnedFiles.has(file.id) && !isSystemFile(file.name));
                const unpinnedSystemFiles = files.filter(file => !pinnedFiles.has(file.id) && isSystemFile(file.name));
                
                // Sort each category based on current sort mode
                sortFileArray(pinnedFiles_array, fileSortMode);
                sortFileArray(regularFiles, fileSortMode); 
                sortFileArray(unpinnedSystemFiles, fileSortMode);
                
                // Return files in order: pinned files, regular files, unpinned system files
                return [...pinnedFiles_array, ...regularFiles, ...unpinnedSystemFiles];
            }
            
            function cycleSortMode() {
                const modes = ['name-asc', 'name-desc', 'time-asc', 'time-desc'];
                const currentIndex = modes.indexOf(fileSortMode);
                fileSortMode = modes[(currentIndex + 1) % modes.length];
                
                // Update button title and icon to show current mode
                const sortBtn = document.getElementById('sort-files-btn');
                const modeConfig = {
                    'name-asc': { name: '檔名(A→Z)', icon: 'fas fa-sort-alpha-down' },
                    'name-desc': { name: '檔名(Z→A)', icon: 'fas fa-sort-alpha-up' },
                    'time-asc': { name: '修改時間(舊→新)', icon: 'fas fa-sort-numeric-down' },
                    'time-desc': { name: '修改時間(新→舊)', icon: 'fas fa-sort-numeric-up' }
                };
                
                const currentConfig = modeConfig[fileSortMode];
                sortBtn.title = `檔案排序: ${currentConfig.name}`;
                sortBtn.innerHTML = `<i class="${currentConfig.icon}"></i>`;
                
                renderFileList();
                // Only save configuration if not currently loading configuration
                if (!isLoadingConfiguration) {
                    saveConfiguration(); // Auto-save configuration
                }
            }
            
            // Sidebar control functions
            function toggleSidebar() {
                sidebarVisible = !sidebarVisible;
                if (sidebarVisible) {
                    filePanel.classList.remove('collapsed');
                    updateSidebarContent();
                } else {
                    filePanel.classList.add('collapsed');
                }
            }
            
            function closeSidebar() {
                sidebarVisible = false;
                filePanel.classList.add('collapsed');
            }
            
            function toggleViewMode() {
                switch (viewMode) {
                    case 'files':
                        viewMode = 'toc';
                        break;
                    case 'toc':
                        viewMode = 'dual';
                        break;
                    case 'dual':
                        viewMode = 'files';
                        break;
                }
                updateViewModeUI();
                updateSidebarContent();
                // Only save configuration if not currently loading configuration
                if (!isLoadingConfiguration) {
                    saveConfiguration(); // Auto-save configuration
                }
            }
            
            function updateViewModeUI() {
                // Remove all mode classes
                viewModeToggle.classList.remove('files-mode', 'toc-mode', 'dual-mode');
                
                // Update button appearance and text
                switch (viewMode) {
                    case 'files':
                        viewModeToggle.classList.add('files-mode');
                        viewModeToggle.textContent = 'F';
                        viewModeToggle.title = '單檔案模式';
                        break;
                    case 'toc':
                        viewModeToggle.classList.add('toc-mode');
                        viewModeToggle.textContent = 'T';
                        viewModeToggle.title = '單目錄模式';
                        break;
                    case 'dual':
                        viewModeToggle.classList.add('dual-mode');
                        viewModeToggle.textContent = 'FT';
                        viewModeToggle.title = '雙顯示模式';
                        break;
                }
            }
            
            function updateSidebarContent() {
                if (!sidebarVisible) return;
                
                const fileList = document.getElementById('file-list');
                const tocContainer = document.getElementById('toc-container');
                
                // Remove dual mode class
                filePanel.classList.remove('dual-mode');
                
                switch (viewMode) {
                    case 'files':
                        fileList.style.display = 'block';
                        tocContainer.style.display = 'none';
                        break;
                    case 'toc':
                        fileList.style.display = 'none';
                        tocContainer.style.display = 'block';
                        updateToc();
                        break;
                    case 'dual':
                        fileList.style.display = 'block';
                        tocContainer.style.display = 'block';
                        filePanel.classList.add('dual-mode');
                        updateToc();
                        break;
                }
            }
            
            // Mobile view toggle functions
            function toggleMobileView() {
                if (!isMobileDevice()) return;
                
                mobileViewMode = mobileViewMode === 'edit' ? 'preview' : 'edit';
                updateMobileViewUI();
            }
            
            function updateMobileViewUI() {
                if (!isMobileDevice()) return;
                
                // Remove previous mobile view classes
                mainContainer.classList.remove('mobile-edit-only', 'mobile-preview-only');
                
                if (mobileViewMode === 'edit') {
                    mainContainer.classList.add('mobile-edit-only');
                    if (mobileViewToggle) {
                        mobileViewToggle.innerHTML = '<i class="fas fa-edit"></i>';
                        mobileViewToggle.title = '純編輯模式 - 點擊切換到渲染';
                    }
                } else if (mobileViewMode === 'preview') {
                    mainContainer.classList.add('mobile-preview-only');
                    if (mobileViewToggle) {
                        mobileViewToggle.innerHTML = '<i class="fas fa-eye"></i>';
                        mobileViewToggle.title = '純渲染模式 - 點擊切換到編輯';
                    }
                }
            }

            // TOC function moved to sidebar tabs - this function is no longer needed

            function updateSidebarLayout() {
                const filePanel = document.getElementById('file-panel');
                const fileList = document.getElementById('file-list');
                const tocContainer = document.getElementById('toc-container');
                const fileListVisible = !fileList.classList.contains('hidden');
                const tocVisible = !tocContainer.classList.contains('hidden');

                if (fileListVisible && tocVisible) {
                    filePanel.classList.add('split-view');
                } else {
                    filePanel.classList.remove('split-view');
                }

                if (!fileListVisible && !tocVisible) {
                    filePanel.classList.add('collapsed');
                } else {
                    filePanel.classList.remove('collapsed');
                }
            }
            
            // New file creation function
            async function createNewFile() {
                const fileName = prompt('請輸入新檔案名稱：', '新筆記');
                if (!fileName) return;
                
                // Add .md extension if not present
                const fullFileName = fileName.includes('.') ? fileName : `${fileName}.md`;
                
                // Check if file name already exists
                if (files.some(f => f.name === fullFileName)) {
                    alert('檔案名稱已存在，請選擇其他名稱。');
                    return;
                }
                
                // Create new file object
                const newFile = {
                    id: `file-${Date.now()}-${Math.random()}`,
                    name: fullFileName,
                    content: `# ${fileName}\n\n`,
                    lastModified: Date.now()
                };
                
                // Add to files array
                files.push(newFile);
                
                // Save to storage
                await saveFilesToStorage();
                
                // Load the new file
                loadFile(newFile.id);
                
                // Update file list
                renderFileList();
                
                // Show notification
                showNotification(`已創建新檔案「${fullFileName}」`);
                
                // Open sidebar and set to files mode if it's closed
                if (!sidebarVisible) {
                    sidebarVisible = true;
                    viewMode = 'files';
                    filePanel.classList.remove('collapsed');
                    updateViewModeUI();
                    updateSidebarContent();
                } else if (viewMode !== 'files') {
                    viewMode = 'files';
                    updateViewModeUI();
                    updateSidebarContent();
                }
            }
            
            // File management functions
            async function deleteFile(fileId) {
                const file = files.find(f => f.id === fileId);
                if (!file) return;
                
                if (confirm(`確定要刪除檔案「${file.name}」嗎？此操作無法復原。`)) {
                    // Remove from files array
                    files = files.filter(f => f.id !== fileId);
                    
                    // Remove from pinned files if it was pinned
                    if (pinnedFiles.has(fileId)) {
                        pinnedFiles.delete(fileId);
                        await savePinnedFilesToConfig();
                    }
                    
                    // If this was the current file, switch to another file or create new
                    if (currentFile && currentFile.id === fileId) {
                        if (files.length > 0) {
                            loadFile(files[0].id);
                        } else {
                            currentFile = null;
                            currentFileNameEl.textContent = '新筆記';
                            editor.setValue(getWelcomeMessage());
                        }
                    }
                    
                    await saveFilesToStorage();
                    renderFileList();
                    showNotification(`已刪除檔案「${file.name}」`);
                }
            }
            
            async function togglePinFile(fileId) {
                const file = files.find(f => f.id === fileId);
                if (!file) return;
                
                if (pinnedFiles.has(fileId)) {
                    // 取消釘選
                    pinnedFiles.delete(fileId);
                    showNotification(`已取消釘選檔案「${file.name}」`);
                } else {
                    // 釘選檔案
                    pinnedFiles.add(fileId);
                    showNotification(`已釘選檔案「${file.name}」`);
                }
                
                // 重新渲染檔案列表
                renderFileList();
                
                // 儲存釘選配置到NoteConfig.md
                await savePinnedFilesToConfig();
            }
            
            async function savePinnedFilesToConfig() {
                // 直接調用createOrUpdateNoteConfig來更新配置
                createOrUpdateNoteConfig();
                // 立即儲存到storage
                await saveFilesToStorage();
            }
            
            function startRenameFile(fileId) {
                const file = files.find(f => f.id === fileId);
                if (!file) return;
                
                const fileItemName = document.querySelector(`.file-item-name[data-file-id="${fileId}"]`);
                if (!fileItemName) return;
                
                const originalName = file.name;
                const nameWithoutExt = originalName.replace(/\.[^/.]+$/, "");
                
                fileItemName.innerHTML = `<input type="text" class="file-rename-input" value="${nameWithoutExt}" data-file-id="${fileId}" />`;
                
                const input = fileItemName.querySelector('.file-rename-input');
                input.focus();
                input.select();
                
                // Handle rename on Enter or blur
                const finishRename = async () => {
                    const newName = input.value.trim();
                    if (newName && newName !== nameWithoutExt) {
                        const extension = originalName.includes('.') ? originalName.split('.').pop() : 'md';
                        const fullNewName = newName.includes('.') ? newName : `${newName}.${extension}`;
                        
                        // Update wiki links in all files before renaming
                        const updatedCount = await updateWikiLinksAfterRename(originalName, fullNewName);
                        
                        file.name = fullNewName;
                        if (currentFile && currentFile.id === fileId) {
                            currentFileNameEl.textContent = fullNewName;
                        }
                        
                        await saveFilesToStorage();
                        
                        if (updatedCount > 0) {
                            showNotification(`檔案已重新命名為「${fullNewName}」，已自動更新 ${updatedCount} 個檔案中的相關連結`);
                        } else {
                            showNotification(`檔案已重新命名為「${fullNewName}」`);
                        }
                    }
                    renderFileList();
                };
                
                const cancelRename = () => {
                    renderFileList();
                };
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishRename();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelRename();
                    }
                });
                
                input.addEventListener('blur', finishRename);
            }

            async function loadDataFromStorage() {
                // Initialize IndexedDB and migrate data
                await initIndexedDB();
                await migrateToIndexedDB();
                
                // Load legacy tasks for backward compatibility
                try {
                    const savedTasks = await loadFromIndexedDB('powernote_tasks');
                    if (savedTasks && Array.isArray(savedTasks)) {
                        tasks = savedTasks.map(t => ({ 
                            ...t, 
                            startTime: new Date(t.startTime), 
                            endTime: t.endTime ? new Date(t.endTime) : null 
                        }));
                    }
                } catch (e) {
                    console.warn('Failed to load tasks:', e);
                    tasks = [];
                }
                
                // Load files
                try {
                    const savedFiles = await loadFromIndexedDB('powernote_files');
                    if (savedFiles && Array.isArray(savedFiles)) {
                        // Ensure all files have lastModified timestamp
                        files = savedFiles.map(file => ({
                            ...file,
                            lastModified: file.lastModified || Date.now()
                        })); 
                    }
                } catch (e) {
                    console.warn('Failed to load files:', e);
                    files = [];
                }
                
                // Load timer history from NoteTask.md file
                loadTimerHistoryFromNoteTask();
                
                // Migration: Import from localStorage if NoteTask.md doesn't exist but localStorage does
                const savedTimerHistory = localStorage.getItem('powernote_timer_history');
                if (Object.keys(timerHistory).length === 0 && savedTimerHistory) {
                    try {
                        const parsed = JSON.parse(savedTimerHistory);
                        timerHistory = {};
                        Object.keys(parsed).forEach(date => {
                            timerHistory[date] = parsed[date].map(t => ({
                                ...t,
                                startTime: new Date(t.startTime),
                                endTime: t.endTime ? new Date(t.endTime) : null
                            }));
                        });
                        // Migrate to new format and remove old data
                        updateNoteTaskFile();
                        localStorage.removeItem('powernote_timer_history');
                        console.log('Timer history migrated from localStorage to NoteTask.md');
                    } catch (e) {
                        console.warn('Failed to migrate timer history:', e);
                        timerHistory = {};
                    }
                }
            }
            async function saveTasks() { 
                await saveToIndexedDB('powernote_tasks', tasks);
            }
            async function saveFilesToStorage() { 
                await saveToIndexedDB('powernote_files', files);
            }
            
            // Save current file and update file list if UNSYNC status changed
            async function saveCurrentFile() {
                if (!currentFile) return;
                
                const oldContent = currentFile.content;
                const newContent = editor.getValue();
                currentFile.content = newContent;
                currentFile.lastModified = Date.now();
                await saveFilesToStorage();
                
                // Sync hashtag changes for non-NoteTag files
                console.log(`💾 Saving file: ${currentFile.name} (ID: ${currentFile.id})`);
                if (currentFile.name !== 'NoteTag.md') {
                    console.log(`🔍 Triggering hashtag sync for ${currentFile.name}`);
                    syncHashtagChanges(currentFile.id, newContent);
                } else {
                    console.log(`⏭️ Skipping hashtag sync for NoteTag.md`);
                }
                
                // Check if UNSYNC status changed and update file list styling
                const oldHasUnsync = oldContent.includes('#UNSYNC');
                const newHasUnsync = currentFile.content.includes('#UNSYNC');
                if (oldHasUnsync !== newHasUnsync) {
                    renderFileList(); // Re-render to update UNSYNC styling
                }
            }
            
            // Update wiki links when a file is renamed
            async function updateWikiLinksAfterRename(oldFileName, newFileName) {
                const oldNameWithoutExt = oldFileName.replace(/\.[^/.]+$/, "");
                const newNameWithoutExt = newFileName.replace(/\.[^/.]+$/, "");
                
                let updatedCount = 0;
                
                // Update all files that contain wiki links to the renamed file
                for (const file of files) {
                    if (file.name === oldFileName) continue; // Skip the renamed file itself
                    
                    let content = file.content;
                    let hasChanges = false;
                    
                    // Pattern 1: [[oldName]] -> [[newName]]
                    const simplePattern = new RegExp(`\\[\\[${escapeRegExp(oldNameWithoutExt)}\\]\\]`, 'g');
                    if (simplePattern.test(content)) {
                        content = content.replace(simplePattern, `[[${newNameWithoutExt}]]`);
                        hasChanges = true;
                    }
                    
                    // Pattern 2: [[oldName#section]] -> [[newName#section]]
                    const sectionPattern = new RegExp(`\\[\\[${escapeRegExp(oldNameWithoutExt)}(#[^\\]]+)\\]\\]`, 'g');
                    if (sectionPattern.test(content)) {
                        content = content.replace(sectionPattern, `[[${newNameWithoutExt}$1]]`);
                        hasChanges = true;
                    }
                    
                    if (hasChanges) {
                        file.content = content;
                        file.lastModified = Date.now();
                        updatedCount++;
                        
                        // If this is the current file being edited, update the editor
                        if (currentFile && currentFile.id === file.id) {
                            editor.setValue(content);
                            updatePreview();
                        }
                    }
                }
                
                // Also update NoteTag.md if it exists
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (noteTagFile) {
                    let tagContent = noteTagFile.content;
                    let tagHasChanges = false;
                    
                    // Update links in NoteTag.md
                    const tagSimplePattern = new RegExp(`\\[\\[${escapeRegExp(oldNameWithoutExt)}\\]\\]`, 'g');
                    if (tagSimplePattern.test(tagContent)) {
                        tagContent = tagContent.replace(tagSimplePattern, `[[${newNameWithoutExt}]]`);
                        tagHasChanges = true;
                    }
                    
                    const tagSectionPattern = new RegExp(`\\[\\[${escapeRegExp(oldNameWithoutExt)}(#[^\\]]+)\\]\\]`, 'g');
                    if (tagSectionPattern.test(tagContent)) {
                        tagContent = tagContent.replace(tagSectionPattern, `[[${newNameWithoutExt}$1]]`);
                        tagHasChanges = true;
                    }
                    
                    if (tagHasChanges) {
                        noteTagFile.content = tagContent;
                        noteTagFile.lastModified = Date.now();
                        updatedCount++;
                        
                        // If NoteTag.md is currently being edited, update the editor
                        if (currentFile && currentFile.id === noteTagFile.id) {
                            editor.setValue(tagContent);
                            updatePreview();
                        }
                    }
                }
                
                console.log(`Updated wiki links in ${updatedCount} files (including NoteTag.md if applicable)`);
                return updatedCount;
            }
            
            // Helper function to escape special regex characters
            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
            
            // --- Configuration Management ---
            function createOrUpdateNoteConfig() {
                console.log('createOrUpdateNoteConfig: called, isLoadingConfiguration:', isLoadingConfiguration);
                
                // CRITICAL: Don't overwrite config file while loading configuration!
                if (isLoadingConfiguration) {
                    console.log('createOrUpdateNoteConfig: BLOCKED - Configuration is being loaded, not overwriting file');
                    return null;
                }
                
                console.log('createOrUpdateNoteConfig: currentFile:', currentFile);
                console.log('createOrUpdateNoteConfig: viewMode:', viewMode, 'fileSortMode:', fileSortMode);
                console.log('createOrUpdateNoteConfig: currentFontSize:', currentFontSize, 'currentEditorTheme:', currentEditorTheme);
                console.log('createOrUpdateNoteConfig: sidebarVisible:', sidebarVisible, 'currentViewMode:', currentViewMode);
                
                let noteConfigFile = files.find(f => f.name === 'NoteConfig.md');
                
                const config = {
                    sidebarConfig: {
                        viewMode: viewMode,
                        fileSortMode: fileSortMode,
                        isVisible: sidebarVisible
                    },
                    fontSettings: {
                        fontSize: currentFontSize,
                        theme: currentEditorTheme
                    },
                    viewSettings: {
                        currentViewMode: currentViewMode,
                        mobileViewMode: mobileViewMode,
                        syncScrollEnabled: syncScrollEnabled
                    },
                    currentFile: {
                        id: currentFile ? currentFile.id : null,
                        name: currentFile ? currentFile.name : null
                    },
                    pinnedFiles: Array.from(pinnedFiles),
                    lastUpdated: new Date().toLocaleString()
                };
                
                const configContent = `# PowerNote Configuration\n\n` +
                    `> Last updated: ${config.lastUpdated}\n\n` +
                    `## Sidebar Configuration\n` +
                    `- View Mode: \`${config.sidebarConfig.viewMode}\`\n` +
                    `- File Sort Mode: \`${config.sidebarConfig.fileSortMode}\`\n` +
                    `- Sidebar Visible: ${config.sidebarConfig.isVisible}\n\n` +
                    `## Font Settings\n` +
                    `- Font Size: ${config.fontSettings.fontSize}px\n` +
                    `- Editor Theme: \`${config.fontSettings.theme}\`\n\n` +
                    `## View Settings\n` +
                    `- Current View Mode: \`${config.viewSettings.currentViewMode}\`\n` +
                    `- Mobile View Mode: \`${config.viewSettings.mobileViewMode}\`\n` +
                    `- Sync Scroll Enabled: \`${config.viewSettings.syncScrollEnabled}\`\n\n` +
                    `## Current File\n` +
                    `- File ID: \`${config.currentFile.id || 'none'}\`\n` +
                    `- File Name: \`${config.currentFile.name || 'none'}\`\n\n` +
                    `## Pinned Files\n` +
                    `${config.pinnedFiles.length > 0 ? config.pinnedFiles.map(fileId => `- \`${fileId}\``).join('\n') : '- None'}\n\n` +
                    `---\n` +
                    `*This configuration file is automatically generated and updated by PowerNote.*\n` +
                    `*Manual edits will be overwritten.*`;
                
                if (!noteConfigFile) {
                    noteConfigFile = {
                        id: `file-config-${Date.now()}`,
                        name: 'NoteConfig.md',
                        content: configContent,
                        lastModified: Date.now()
                    };
                    files.push(noteConfigFile);
                } else {
                    noteConfigFile.content = configContent;
                    noteConfigFile.lastModified = Date.now();
                }
                
                return config;
            }
            
            function parseNoteConfig() {
                console.log('parseNoteConfig: Looking for NoteConfig.md in files:', files.map(f => f.name));
                const noteConfigFile = files.find(f => f.name === 'NoteConfig.md');
                if (!noteConfigFile) {
                    console.log('parseNoteConfig: NoteConfig.md not found');
                    return null;
                }
                console.log('parseNoteConfig: Found NoteConfig.md, content length:', noteConfigFile.content.length);
                console.log('parseNoteConfig: Content preview:', noteConfigFile.content.substring(0, 500));
                
                const content = noteConfigFile.content;
                const config = {};
                
                try {
                    const viewModeMatch = content.match(/- View Mode: `([^`]+)`/);
                    const sortModeMatch = content.match(/- File Sort Mode: `([^`]+)`/);
                    const sidebarVisibleMatch = content.match(/- Sidebar Visible: (true|false)/);
                    
                    console.log('parseNoteConfig: Parsing sidebar config');
                    console.log('viewModeMatch:', viewModeMatch);
                    console.log('sortModeMatch:', sortModeMatch);
                    console.log('sidebarVisibleMatch:', sidebarVisibleMatch);
                    
                    config.sidebarConfig = {
                        viewMode: viewModeMatch ? viewModeMatch[1] : 'files',
                        fileSortMode: sortModeMatch ? sortModeMatch[1] : 'name-asc',
                        isVisible: sidebarVisibleMatch ? sidebarVisibleMatch[1] === 'true' : false
                    };
                    
                    const fontSizeMatch = content.match(/- Font Size: (\d+)px/);
                    const themeMatch = content.match(/- Editor Theme: `([^`]+)`/);
                    
                    config.fontSettings = {
                        fontSize: fontSizeMatch ? parseInt(fontSizeMatch[1]) : 22,
                        theme: themeMatch ? themeMatch[1] : 'default'
                    };
                    
                    const currentViewModeMatch = content.match(/- Current View Mode: `([^`]+)`/);
                    const mobileViewModeMatch = content.match(/- Mobile View Mode: `([^`]+)`/);
                    const syncScrollMatch = content.match(/- Sync Scroll Enabled: `([^`]+)`/);
                    
                    config.viewSettings = {
                        currentViewMode: currentViewModeMatch ? currentViewModeMatch[1] : 'split',
                        mobileViewMode: mobileViewModeMatch ? mobileViewModeMatch[1] : 'edit',
                        syncScrollEnabled: syncScrollMatch ? (syncScrollMatch[1] === 'true') : false
                    };
                    
                    const fileIdMatch = content.match(/- File ID: `([^`]+)`/);
                    const fileNameMatch = content.match(/- File Name: `([^`]+)`/);
                    
                    config.currentFile = {
                        id: fileIdMatch && fileIdMatch[1] !== 'none' ? fileIdMatch[1] : null,
                        name: fileNameMatch && fileNameMatch[1] !== 'none' ? fileNameMatch[1] : null
                    };
                    
                    // Parse pinned files
                    const pinnedFilesSection = content.match(/## Pinned Files\n([\s\S]*?)(?=\n---|$)/);
                    if (pinnedFilesSection) {
                        const pinnedFileLines = pinnedFilesSection[1].trim().split('\n');
                        config.pinnedFiles = [];
                        for (const line of pinnedFileLines) {
                            const fileIdMatch = line.match(/- `([^`]+)`/);
                            if (fileIdMatch && fileIdMatch[1] !== 'None') {
                                config.pinnedFiles.push(fileIdMatch[1]);
                            }
                        }
                    } else {
                        config.pinnedFiles = [];
                    }
                    
                } catch (e) {
                    console.warn('Failed to parse NoteConfig.md:', e);
                    return null;
                }
                
                return config;
            }
            
            async function saveConfiguration() {
                console.log('saveConfiguration: called, isLoadingConfiguration:', isLoadingConfiguration);
                console.trace('saveConfiguration: call stack'); // 顯示調用堆疊
                // Don't save configuration while loading configuration to avoid conflicts
                if (isLoadingConfiguration) {
                    console.log('saveConfiguration: skipped due to loading flag');
                    return;
                }
                
                console.log('saveConfiguration: proceeding with save');
                const result = createOrUpdateNoteConfig();
                if (result !== null) {
                    await saveFilesToStorage();
                    renderFileList();
                } else {
                    console.log('saveConfiguration: createOrUpdateNoteConfig returned null, skipping save');
                }
            }
            
            async function loadConfiguration() {
                console.log('loadConfiguration: Starting configuration load');
                
                // Set flag FIRST to prevent any saves during loading
                isLoadingConfiguration = true;
                
                // Try to find existing NoteConfig.md
                let noteConfigFile = files.find(f => f.name === 'NoteConfig.md');
                if (!noteConfigFile) {
                    console.log('loadConfiguration: No NoteConfig.md found, will return false to use defaults');
                    isLoadingConfiguration = false;
                    return false;
                } else {
                    console.log('loadConfiguration: Found existing NoteConfig.md');
                }
                
                console.log('loadConfiguration: About to parse config, files count:', files.length);
                const config = parseNoteConfig();
                if (!config) {
                    console.log('loadConfiguration: Failed to parse configuration, returning false');
                    isLoadingConfiguration = false; // Reset flag on failure
                    return false;
                }
                console.log('loadConfiguration: Configuration parsed:', config);
                
                // Double check the actual file content
                const checkFile = files.find(f => f.name === 'NoteConfig.md');
                if (checkFile) {
                    console.log('loadConfiguration: Actual file content in files array:');
                    console.log(checkFile.content);
                } else {
                    console.log('loadConfiguration: ERROR - NoteConfig.md not found in files array!');
                }
                
                try {
                    viewMode = config.sidebarConfig.viewMode;
                    fileSortMode = config.sidebarConfig.fileSortMode;
                    sidebarVisible = config.sidebarConfig.isVisible;
                    
                    // Load pinned files
                    if (config.pinnedFiles && Array.isArray(config.pinnedFiles)) {
                        pinnedFiles = new Set(config.pinnedFiles);
                        console.log('loadConfiguration: Loaded pinned files:', Array.from(pinnedFiles));
                    }
                    
                    // Apply font settings without triggering save
                    if (config.fontSettings.fontSize !== currentFontSize) {
                        currentFontSize = config.fontSettings.fontSize;
                        const codeMirrorElement = document.querySelector('.CodeMirror');
                        if (codeMirrorElement) {
                            codeMirrorElement.style.fontSize = currentFontSize + 'px';
                        }
                        const previewElement = document.getElementById('preview');
                        if (previewElement) {
                            previewElement.style.fontSize = currentFontSize + 'px';
                        }
                    }
                    
                    // Apply theme settings without triggering save
                    if (config.fontSettings.theme !== currentEditorTheme) {
                        currentEditorTheme = config.fontSettings.theme;
                        if (editor) {
                            editor.setOption('theme', currentEditorTheme);
                        }
                        // Apply theme classes to preview
                        const previewContainer = document.querySelector('.preview-container');
                        const presentationMode = document.getElementById('presentation-mode');
                        const themeClasses = ['theme-default', 'theme-monokai', 'theme-solarized', 'theme-material', 'theme-dracula', 'theme-github'];
                        
                        if (previewContainer) {
                            themeClasses.forEach(cls => previewContainer.classList.remove(cls));
                            previewContainer.classList.remove('dark');
                        }
                        if (presentationMode) {
                            themeClasses.forEach(cls => presentationMode.classList.remove(cls));
                            presentationMode.classList.remove('dark');
                        }
                        
                        let themeClass = 'theme-' + currentEditorTheme.replace(' ', '-');
                        let darkClass = '';
                        if (currentEditorTheme === 'solarized dark') {
                            themeClass = 'theme-solarized';
                            darkClass = 'dark';
                        }
                        
                        if (previewContainer) {
                            previewContainer.classList.add(themeClass);
                            if (darkClass) previewContainer.classList.add(darkClass);
                        }
                        if (presentationMode) {
                            presentationMode.classList.add(themeClass);
                            if (darkClass) presentationMode.classList.add(darkClass);
                        }
                    }
                    
                    currentViewMode = config.viewSettings.currentViewMode;
                    mobileViewMode = config.viewSettings.mobileViewMode;
                    syncScrollEnabled = config.viewSettings.syncScrollEnabled || false;
                    
                    // Apply sidebar visibility
                    const filePanel = document.getElementById('file-panel');
                    if (filePanel) {
                        if (sidebarVisible) {
                            filePanel.classList.remove('collapsed');
                        } else {
                            filePanel.classList.add('collapsed');
                        }
                    }
                    
                    updateViewModeUI();
                    updateSidebarContent();
                    
                    // Apply view mode without triggering save (replicate setViewMode logic)
                    const editorPanel = document.getElementById('editor-panel');
                    const previewPanel = document.getElementById('preview-panel');
                    const drawingPanel = document.getElementById('drawing-panel');
                    const splitBtn = document.getElementById('split-view-btn');
                    const editBtn = document.getElementById('edit-only-btn');
                    const previewBtn = document.getElementById('preview-only-btn');
                    const drawingBtn = document.getElementById('drawing-mode-btn');
                    
                    // Reset button states
                    [splitBtn, editBtn, previewBtn, drawingBtn].forEach(btn => {
                        if (btn) btn.classList.remove('active');
                    });
                    
                    // Apply view mode
                    const divider = document.getElementById('panel-divider');
                    const mainContent = document.querySelector('.main-editor-content');
                    
                    switch (currentViewMode) {
                        case 'split':
                            if (editorPanel) editorPanel.style.display = 'flex';
                            if (previewPanel) previewPanel.style.display = 'flex';
                            if (drawingPanel) drawingPanel.style.display = 'none';
                            if (divider) divider.style.display = 'flex';
                            if (mainContent) mainContent.classList.remove('drawing-mode');
                            if (splitBtn) splitBtn.classList.add('active');
                            // Show sync scroll button in split mode
                            const syncScrollToggle = document.getElementById('sync-scroll-toggle');
                            if (syncScrollToggle) syncScrollToggle.style.display = 'block';
                            break;
                        case 'edit-only':
                            if (editorPanel) editorPanel.style.display = 'flex';
                            if (previewPanel) previewPanel.style.display = 'none';
                            if (drawingPanel) drawingPanel.style.display = 'none';
                            if (divider) divider.style.display = 'none';
                            if (mainContent) mainContent.classList.remove('drawing-mode');
                            if (editBtn) editBtn.classList.add('active');
                            // Hide sync scroll button in edit-only mode
                            const syncScrollToggleEdit = document.getElementById('sync-scroll-toggle');
                            if (syncScrollToggleEdit) syncScrollToggleEdit.style.display = 'none';
                            break;
                        case 'preview-only':
                            if (editorPanel) editorPanel.style.display = 'none';
                            if (previewPanel) {
                                previewPanel.style.display = 'flex';
                                previewPanel.style.width = '100%';
                            }
                            if (drawingPanel) drawingPanel.style.display = 'none';
                            if (divider) divider.style.display = 'none';
                            if (mainContent) mainContent.classList.remove('drawing-mode');
                            if (previewBtn) previewBtn.classList.add('active');
                            // Hide sync scroll button in preview-only mode
                            const syncScrollTogglePreview = document.getElementById('sync-scroll-toggle');
                            if (syncScrollTogglePreview) syncScrollTogglePreview.style.display = 'none';
                            break;
                        case 'drawing':
                            if (editorPanel) editorPanel.style.display = 'flex';
                            if (previewPanel) previewPanel.style.display = 'none';
                            if (drawingPanel) drawingPanel.style.display = 'flex';
                            if (divider) divider.style.display = 'flex';
                            if (mainContent) mainContent.classList.add('drawing-mode');
                            if (drawingBtn) drawingBtn.classList.add('active');
                            // Hide sync scroll button in drawing mode
                            const syncScrollToggleDrawing = document.getElementById('sync-scroll-toggle');
                            if (syncScrollToggleDrawing) syncScrollToggleDrawing.style.display = 'none';
                            break;
                    }
                    
                    // Update sync scroll button state
                    const syncScrollToggle = document.getElementById('sync-scroll-toggle');
                    if (syncScrollToggle) {
                        if (syncScrollEnabled) {
                            syncScrollToggle.classList.add('active');
                            syncScrollToggle.title = '同步滾動 (已開啟)';
                        } else {
                            syncScrollToggle.classList.remove('active');
                            syncScrollToggle.title = '同步滾動 (已關閉)';
                        }
                    }
                    
                    renderFileList(); // Update file list with correct sorting
                    
                    // Update sort button icon and title
                    const sortBtn = document.getElementById('sort-files-btn');
                    if (sortBtn) {
                        const modeConfig = {
                            'name-asc': { name: '檔名(A→Z)', icon: 'fas fa-sort-alpha-down' },
                            'name-desc': { name: '檔名(Z→A)', icon: 'fas fa-sort-alpha-up' },
                            'time-asc': { name: '修改時間(舊→新)', icon: 'fas fa-sort-numeric-down' },
                            'time-desc': { name: '修改時間(新→舊)', icon: 'fas fa-sort-numeric-up' }
                        };
                        
                        const currentConfig = modeConfig[fileSortMode] || modeConfig['name-asc'];
                        sortBtn.title = `檔案排序: ${currentConfig.name}`;
                        sortBtn.innerHTML = `<i class="${currentConfig.icon}"></i>`;
                    }
                    
                    // Load the previously open file, or load first available file
                    let fileLoaded = false;
                    if (config.currentFile.id && config.currentFile.id !== 'null') {
                        console.log('loadConfiguration: Trying to load configured file:', config.currentFile.id);
                        const fileToLoad = files.find(f => f.id === config.currentFile.id);
                        if (fileToLoad) {
                            console.log('loadConfiguration: Found configured file, loading:', fileToLoad.name);
                            loadFile(fileToLoad.id);
                            fileLoaded = true;
                        } else {
                            console.log('loadConfiguration: Configured file not found');
                        }
                    } else {
                        console.log('loadConfiguration: No valid file ID in config, will load first available');
                    }
                    
                    // If the configured file wasn't found, load the first available file
                    if (!fileLoaded && files.length > 0) {
                        console.log('loadConfiguration: Loading first available file:', files[0].name);
                        loadFile(files[0].id);
                    }
                    
                    console.log('Configuration loaded successfully:', config);
                    return true;
                } catch (e) {
                    console.warn('Failed to apply loaded configuration:', e);
                    return false;
                } finally {
                    // Reset the flag after loading is complete
                    isLoadingConfiguration = false;
                }
            }
            
            // --- IndexedDB Management ---
            let dbInstance = null;
            const DB_NAME = 'PowerNoteDB';
            const DB_VERSION = 1;
            const STORE_NAME = 'data';
            
            // Initialize IndexedDB
            async function initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    
                    request.onerror = () => {
                        console.warn('IndexedDB initialization failed, falling back to localStorage');
                        resolve(null);
                    };
                    
                    request.onsuccess = (event) => {
                        dbInstance = event.target.result;
                        console.log('IndexedDB initialized successfully');
                        resolve(dbInstance);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });
                            store.createIndex('key', 'key', { unique: true });
                        }
                    };
                });
            }
            
            // Save data to IndexedDB with localStorage fallback
            async function saveToIndexedDB(key, data) {
                try {
                    if (!dbInstance) {
                        throw new Error('IndexedDB not available');
                    }
                    
                    const transaction = dbInstance.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const dataToStore = { key: key, value: JSON.stringify(data), timestamp: Date.now() };
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(dataToStore);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log(`✅ Data saved to IndexedDB: ${key}`);
                } catch (error) {
                    console.warn(`❌ IndexedDB save failed for ${key}, using localStorage fallback:`, error);
                    try {
                        localStorage.setItem(key, JSON.stringify(data));
                        console.log(`✅ Fallback to localStorage successful: ${key}`);
                    } catch (fallbackError) {
                        console.error(`❌ Both IndexedDB and localStorage failed for ${key}:`, fallbackError);
                    }
                }
            }
            
            // Load data from IndexedDB with localStorage fallback
            async function loadFromIndexedDB(key) {
                try {
                    if (!dbInstance) {
                        throw new Error('IndexedDB not available');
                    }
                    
                    const transaction = dbInstance.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    const result = await new Promise((resolve, reject) => {
                        const request = store.get(key);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (result && result.value) {
                        console.log(`✅ Data loaded from IndexedDB: ${key}`);
                        return JSON.parse(result.value);
                    } else {
                        console.log(`ℹ️ No data found in IndexedDB for: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.warn(`❌ IndexedDB load failed for ${key}, trying localStorage fallback:`, error);
                    try {
                        const fallbackData = localStorage.getItem(key);
                        if (fallbackData) {
                            console.log(`✅ Fallback data loaded from localStorage: ${key}`);
                            return JSON.parse(fallbackData);
                        } else {
                            console.log(`ℹ️ No fallback data found in localStorage for: ${key}`);
                            return null;
                        }
                    } catch (fallbackError) {
                        console.error(`❌ Both IndexedDB and localStorage load failed for ${key}:`, fallbackError);
                        return null;
                    }
                }
            }
            
            // Migrate data from localStorage to IndexedDB
            async function migrateToIndexedDB() {
                // Check if migration has already been completed
                const migrationComplete = await loadFromIndexedDB('migration_complete');
                if (migrationComplete) {
                    console.log('ℹ️ Migration already completed, skipping...');
                    return;
                }
                
                const keysToMigrate = [
                    'powernote_files',
                    'powernote_tasks', 
                    'powernote-font-size',
                    'powernote-editor-theme'
                ];
                
                let migratedCount = 0;
                for (const key of keysToMigrate) {
                    const localData = localStorage.getItem(key);
                    if (localData) {
                        try {
                            let parsedData;
                            // Handle theme setting which is a simple string, not JSON
                            if (key === 'powernote-editor-theme' || key === 'powernote-font-size') {
                                parsedData = localData.replace(/^"(.*)"$/, '$1'); // Remove quotes if present
                            } else {
                                parsedData = JSON.parse(localData);
                            }
                            await saveToIndexedDB(key, parsedData);
                            migratedCount++;
                            console.log(`✅ Migrated ${key} to IndexedDB`);
                            // Remove from localStorage after successful migration
                            localStorage.removeItem(key);
                        } catch (error) {
                            console.warn(`❌ Failed to migrate ${key}:`, error);
                        }
                    }
                }
                
                // Mark migration as complete
                await saveToIndexedDB('migration_complete', true);
                
                if (migratedCount > 0) {
                    console.log(`✅ Migration completed: ${migratedCount} items moved to IndexedDB`);
                    showNotification(`已遷移 ${migratedCount} 項資料到新的儲存系統，容量大幅提升！`);
                } else {
                    console.log('ℹ️ No items to migrate from localStorage');
                }
            }
            async function saveTimerHistory() { 
                await updateNoteTaskFile();
            }
            
            // Convert timerHistory to NoteTask.md markdown format
            function timerHistoryToMarkdown() {
                const lines = ['# 任務計時記錄\n'];
                
                // Sort dates in descending order (newest first)
                const sortedDates = Object.keys(timerHistory).sort((a, b) => new Date(b) - new Date(a));
                
                sortedDates.forEach(date => {
                    const tasks = timerHistory[date];
                    if (tasks.length === 0) return;
                    
                    // Format date header
                    const dateObj = new Date(date);
                    const weekdays = ['週日', '週一', '週二', '週三', '週四', '週五', '週六'];
                    const weekday = weekdays[dateObj.getDay()];
                    lines.push(`## ${date} (${weekday})\n`);
                    
                    let totalDuration = 0;
                    let manualDuration = 0;
                    let autoDuration = 0;
                    
                    tasks.forEach(task => {
                        if (!task.endTime) return;
                        
                        const startTime = safeTimeToString(task.startTime);
                        const endTime = safeTimeToString(task.endTime);
                        const durationText = formatDuration(task.duration);
                        const taskType = task.isAutoGenerated ? '自動計時' : '手動計時';
                        const emoji = task.isAutoGenerated ? '🤖' : '📝';
                        
                        lines.push(`### ${emoji} ${task.name}`);
                        lines.push(`- **開始時間**: ${startTime}`);
                        lines.push(`- **結束時間**: ${endTime}`);
                        lines.push(`- **持續時間**: ${durationText}`);
                        lines.push(`- **類型**: ${taskType}`);
                        
                        if (task.fileName) {
                            lines.push(`- **檔案**: ${task.fileName}`);
                        }
                        if (task.section && task.section.title) {
                            lines.push(`- **章節**: ${task.section.title}`);
                        }
                        lines.push('');
                        
                        totalDuration += task.duration;
                        if (task.isAutoGenerated) {
                            autoDuration += task.duration;
                        } else {
                            manualDuration += task.duration;
                        }
                    });
                    
                    lines.push('---');
                    lines.push(`**當日總計**: ${formatDuration(totalDuration)}`);
                    lines.push(`**手動計時**: ${formatDuration(manualDuration)} | **自動計時**: ${formatDuration(autoDuration)}`);
                    lines.push('');
                });
                
                return lines.join('\n');
            }
            
            // Parse NoteTask.md content back to timerHistory object
            function parseNoteTaskMarkdown(content) {
                const history = {};
                const lines = content.split('\n');
                
                let currentDate = null;
                let currentTask = null;
                let inTask = false;
                
                lines.forEach(line => {
                    line = line.trim();
                    
                    // Match date headers: ## 2025-07-28 (週一)
                    const dateMatch = line.match(/^## (\d{4}-\d{2}-\d{2})/);
                    if (dateMatch) {
                        currentDate = dateMatch[1];
                        history[currentDate] = [];
                        return;
                    }
                    
                    // Match task headers: ### 📝 or ### 🤖 or ### 🤖 📝
                    const taskMatch = line.match(/^### (?:[📝🤖]+ )?(.+)$/);
                    if (taskMatch && currentDate) {
                        if (currentTask) {
                            history[currentDate].push(currentTask);
                        }
                        currentTask = {
                            name: taskMatch[1],
                            isAutoGenerated: line.includes('🤖'),
                            fileName: null,
                            section: null
                        };
                        inTask = true;
                        return;
                    }
                    
                    if (inTask && currentTask && line.startsWith('-')) {
                        // Parse task properties
                        if (line.includes('**開始時間**:')) {
                            const timeStr = line.match(/: (.+)$/)?.[1];
                            if (timeStr && currentDate) {
                                // Support both HH:MM:SS and HH:MM formats
                                const fullTimeStr = timeStr.includes(':') && timeStr.split(':').length === 2 ? `${timeStr}:00` : timeStr;
                                currentTask.startTime = new Date(`${currentDate} ${fullTimeStr}`);
                            }
                        } else if (line.includes('**結束時間**:')) {
                            const timeStr = line.match(/: (.+)$/)?.[1];
                            if (timeStr && currentDate) {
                                // Support both HH:MM:SS and HH:MM formats
                                const fullTimeStr = timeStr.includes(':') && timeStr.split(':').length === 2 ? `${timeStr}:00` : timeStr;
                                currentTask.endTime = new Date(`${currentDate} ${fullTimeStr}`);
                            }
                        } else if (line.includes('**持續時間**:')) {
                            const durationStr = line.match(/: (.+)$/)?.[1];
                            currentTask.duration = parseDurationToSeconds(durationStr);
                        } else if (line.includes('**檔案**:')) {
                            currentTask.fileName = line.match(/: (.+)$/)?.[1];
                        } else if (line.includes('**章節**:')) {
                            const sectionTitle = line.match(/: (.+)$/)?.[1];
                            currentTask.section = { title: sectionTitle, line: 0 };
                        }
                    }
                    
                    // End of task section
                    if (line === '' && inTask && currentTask) {
                        if (currentDate && currentTask.startTime && currentTask.endTime) {
                            history[currentDate].push(currentTask);
                        }
                        currentTask = null;
                        inTask = false;
                    }
                });
                
                // Don't forget the last task
                if (currentTask && currentDate && currentTask.startTime && currentTask.endTime) {
                    history[currentDate].push(currentTask);
                }
                
                return history;
            }
            
            // Helper function to parse duration string back to seconds
            function parseDurationToSeconds(durationStr) {
                if (!durationStr) return 0;
                
                let totalSeconds = 0;
                
                // Support Chinese format: 1小時30分鐘2秒
                const hourMatch = durationStr.match(/(\d+)小時/);
                const minuteMatch = durationStr.match(/(\d+)分鐘/);
                const secondMatch = durationStr.match(/(\d+)秒/);
                
                if (hourMatch) totalSeconds += parseInt(hourMatch[1]) * 3600;
                if (minuteMatch) totalSeconds += parseInt(minuteMatch[1]) * 60;
                if (secondMatch) totalSeconds += parseInt(secondMatch[1]);
                
                // Support HH:MM:SS format: 00:20:02
                if (totalSeconds === 0 && durationStr.includes(':')) {
                    const timeParts = durationStr.split(':');
                    if (timeParts.length === 3) {
                        totalSeconds = parseInt(timeParts[0]) * 3600 + parseInt(timeParts[1]) * 60 + parseInt(timeParts[2]);
                    } else if (timeParts.length === 2) {
                        totalSeconds = parseInt(timeParts[0]) * 60 + parseInt(timeParts[1]);
                    }
                }
                
                return totalSeconds;
            }
            
            // Update or create NoteTask.md file
            async function updateNoteTaskFile() {
                const noteTaskFileName = 'NoteTask.md';
                let noteTaskFile = files.find(f => f.name === noteTaskFileName);
                
                const markdownContent = timerHistoryToMarkdown();
                
                if (!noteTaskFile) {
                    // Create new NoteTask.md file
                    noteTaskFile = {
                        id: `file-${Date.now()}-notetask`,
                        name: noteTaskFileName,
                        content: markdownContent
                    };
                    files.push(noteTaskFile);
                } else {
                    // Update existing file
                    noteTaskFile.content = markdownContent;
                }
                
                await saveFilesToStorage();
                renderFileList();
                
                // If current file is NoteTask.md, refresh editor
                if (currentFile && currentFile.name === noteTaskFileName) {
                    loadFile(noteTaskFile.id);
                }
            }
            
            // Load timer history from NoteTask.md file
            function loadTimerHistoryFromNoteTask() {
                const noteTaskFile = files.find(f => f.name === 'NoteTask.md');
                if (noteTaskFile && noteTaskFile.content) {
                    try {
                        timerHistory = parseNoteTaskMarkdown(noteTaskFile.content);
                        console.log('Timer history loaded from NoteTask.md');
                    } catch (e) {
                        console.warn('Failed to parse NoteTask.md:', e);
                        timerHistory = {};
                    }
                } else {
                    timerHistory = {};
                }
            }
            async function saveDataToStorage() {
                await saveFilesToStorage();
                await saveTimerHistory(); // Now async (saves to NoteTask.md)
                await saveTasks();
            }
            
            // Timeline rendering
            function renderTimeline() {
                const selectedDate = datePicker.value || getTodayDateString();
                const dayTasks = timerHistory[selectedDate] || [];
                
                timelineView.innerHTML = '';
                
                if (dayTasks.length === 0) {
                    timelineView.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;">此日期沒有計時記錄</div>';
                    updateStats(0, 0);
                    return;
                }
                
                // Sort tasks by start time
                const sortedTasks = [...dayTasks].sort((a, b) => a.startTime - b.startTime);
                
                let totalDuration = 0;
                sortedTasks.forEach(task => {
                    if (task.endTime) {
                        totalDuration += task.duration;
                        
                        const timelineItem = document.createElement('div');
                        timelineItem.className = 'timeline-item';
                        timelineItem.innerHTML = `
                            <div class="timeline-bar ${task.isAutoGenerated ? 'auto-generated' : ''}"></div>
                            <div class="timeline-time">${safeTimeToString(task.startTime)} - ${safeTimeToString(task.endTime)}</div>
                            <div class="timeline-duration">${formatDurationShort(task.duration)}</div>
                            <div class="timeline-task ${task.isAutoGenerated ? 'auto-generated' : ''}">
                                ${task.name}
                                ${task.section ? `<div style="font-size: 12px; color: #888;">📍 ${task.section.title}</div>` : ''}
                                ${task.fileName ? `<div style="font-size: 12px; color: #888;">📄 ${task.fileName}</div>` : ''}
                            </div>
                        `;
                        
                        timelineItem.addEventListener('click', () => navigateToTask(task));
                        timelineView.appendChild(timelineItem);
                    }
                });
                
                updateStats(sortedTasks.length, totalDuration);
            }
            
            function updateStats(taskCount, totalDuration) {
                taskCountEl.textContent = taskCount;
                totalTimeEl.textContent = formatDuration(totalDuration);
            }
            
            function openTimerModal() {
                // Set today's date
                datePicker.value = getTodayDateString();
                timerModal.style.display = 'block';
                renderTimeline();
                updateModalTimerUI();
                updateAutoTimerUI();
                
                // Initialize tab state
                showTimelineView();
            }
            
            // Tab switching functions
            function showTimelineView() {
                timelineTabBtn.classList.add('active');
                chartTabBtn.classList.remove('active');
                timelineContainer.style.display = 'block';
                chartContainer.style.display = 'none';
            }
            
            function showChartView() {
                timelineTabBtn.classList.remove('active');
                chartTabBtn.classList.add('active');
                timelineContainer.style.display = 'none';
                chartContainer.style.display = 'block';
                renderChart();
            }
            
            // Chart rendering function
            function renderChart() {
                const selectedDate = datePicker.value || getTodayDateString();
                const dayTasks = timerHistory[selectedDate] || [];
                const completedTasks = dayTasks.filter(task => task.endTime);
                const level = chartLevelSelect.value;
                
                chartView.innerHTML = '';
                
                if (completedTasks.length === 0) {
                    chartView.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;">此日期沒有已完成的任務</div>';
                    return;
                }
                
                // Group tasks by selected level
                const groupedData = groupTasksByLevel(completedTasks, level);
                const totalDuration = completedTasks.reduce((sum, task) => sum + task.duration, 0);
                
                // Sort by duration descending
                const sortedGroups = Object.entries(groupedData)
                    .map(([key, data]) => ({ key, ...data }))
                    .sort((a, b) => b.totalDuration - a.totalDuration);
                
                // Generate colors for pie slices
                const colors = generatePieColors(sortedGroups.length);
                
                // Create pie chart container
                const pieContainer = document.createElement('div');
                pieContainer.className = 'pie-chart-container';
                
                // Create SVG pie chart
                const pieChart = document.createElement('div');
                pieChart.className = 'pie-chart';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 200 200');
                
                let currentAngle = 0;
                const radius = 80;
                const centerX = 100;
                const centerY = 100;
                
                sortedGroups.forEach((group, index) => {
                    const percentage = (group.totalDuration / totalDuration) * 100;
                    const angle = (group.totalDuration / totalDuration) * 360;
                    
                    if (angle > 0) {
                        const slice = createPieSlice(centerX, centerY, radius, currentAngle, angle, colors[index]);
                        svg.appendChild(slice);
                        currentAngle += angle;
                    }
                });
                
                pieChart.appendChild(svg);
                pieContainer.appendChild(pieChart);
                
                // Create legend
                const legend = document.createElement('div');
                legend.className = 'pie-legend';
                
                sortedGroups.forEach((group, index) => {
                    const percentage = ((group.totalDuration / totalDuration) * 100).toFixed(1);
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background-color: ${colors[index]}"></div>
                        <div class="legend-label">${group.key}</div>
                        <div class="legend-duration">${formatDurationShort(group.totalDuration)}</div>
                        <div class="legend-percentage">${percentage}%</div>
                    `;
                    legend.appendChild(legendItem);
                });
                
                pieContainer.appendChild(legend);
                chartView.appendChild(pieContainer);
            }
            
            // Create SVG pie slice
            function createPieSlice(centerX, centerY, radius, startAngle, angle, color) {
                const startAngleRad = (startAngle * Math.PI) / 180;
                const endAngleRad = ((startAngle + angle) * Math.PI) / 180;
                
                const x1 = centerX + radius * Math.cos(startAngleRad);
                const y1 = centerY + radius * Math.sin(startAngleRad);
                const x2 = centerX + radius * Math.cos(endAngleRad);
                const y2 = centerY + radius * Math.sin(endAngleRad);
                
                const largeArcFlag = angle > 180 ? 1 : 0;
                
                const pathData = [
                    `M ${centerX} ${centerY}`,
                    `L ${x1} ${y1}`,
                    `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
                    'Z'
                ].join(' ');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('fill', color);
                path.setAttribute('stroke', '#fff');
                path.setAttribute('stroke-width', '2');
                
                return path;
            }
            
            // Generate colors for pie chart
            function generatePieColors(count) {
                const colors = [
                    '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
                    '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#e91e63',
                    '#16a085', '#27ae60', '#2980b9', '#8e44ad', '#f39800',
                    '#d35400', '#c0392b', '#7f8c8d', '#2c3e50', '#8bc34a'
                ];
                
                if (count <= colors.length) {
                    return colors.slice(0, count);
                }
                
                // Generate additional colors if needed
                const additionalColors = [];
                for (let i = colors.length; i < count; i++) {
                    const hue = (i * 137.5) % 360; // Golden angle for good distribution
                    additionalColors.push(`hsl(${hue}, 60%, 50%)`);
                }
                
                return [...colors, ...additionalColors];
            }
            
            // Group tasks by hierarchy level
            function groupTasksByLevel(tasks, level) {
                const groups = {};
                
                tasks.forEach(task => {
                    let groupKey = '未分類';
                    
                    if (level === 'file') {
                        groupKey = task.fileName || '未命名文件';
                    } else if (task.hierarchy && task.hierarchy.length > 0) {
                        const levelIndex = parseInt(level.replace('level', '')) - 1;
                        if (levelIndex < task.hierarchy.length) {
                            // Build hierarchical path up to the selected level
                            const pathParts = task.hierarchy.slice(0, levelIndex + 1).map(h => h.title);
                            groupKey = pathParts.join(' > ');
                        } else {
                            // If task doesn't have enough hierarchy levels, use the deepest available
                            groupKey = task.hierarchy.map(h => h.title).join(' > ');
                        }
                    }
                    
                    if (!groups[groupKey]) {
                        groups[groupKey] = {
                            totalDuration: 0,
                            taskCount: 0,
                            tasks: []
                        };
                    }
                    
                    groups[groupKey].totalDuration += task.duration;
                    groups[groupKey].taskCount += 1;
                    groups[groupKey].tasks.push(task);
                });
                
                return groups;
            }

            // --- Exporting ---
            function exportToMd() {
                const content = editor.getValue();
                const title = currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") : "document";
                downloadBlob(new Blob([content], { type: 'text/markdown' }), `${title}.md`);
                showNotification(`已匯出 ${title}.md 檔案`);
            }

            function exportToHtml() {
                const content = document.getElementById('preview').innerHTML;
                const title = currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") : "document";
                const html = `<!DOCTYPE html><html><head><title>${title}</title><style>body{font-family:sans-serif;max-width:800px;margin:auto;padding:20px;}.mermaid-container{text-align:center;}</style></head><body>${content}</body></html>`;
                downloadBlob(new Blob([html], { type: 'text/html' }), `${title}.html`);
                showNotification(`已匯出 ${title}.html 檔案`);
            }

            // Export presentation to standalone HTML - Ultra safe version
            function exportPresentationToHtml() {
                if (!isPresentationMode) {
                    showNotification('請先進入簡報模式再導出');
                    return;
                }

                var title = currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") + "_presentation" : "presentation";
                var slidesElement = document.getElementById('presentation-slides');
                var sections = slidesElement.getElementsByTagName('section');
                
                // Create HTML in small, safe pieces
                var parts = [];
                parts.push('<!DOCTYPE html>');
                parts.push('<html>');
                parts.push('<head>');
                parts.push('<meta charset="UTF-8">');
                parts.push('<title>' + title + '</title>');
                parts.push('<style>');
                parts.push('body{margin:0;font-family:Arial,sans-serif;background:white;color:black;overflow:hidden;}');
                parts.push('.slide{display:none;position:absolute;top:0;left:0;width:100vw;height:100vh;padding:60px;box-sizing:border-box;background:white;justify-content:center;align-items:center;flex-direction:column;text-align:center;}');
                parts.push('.slide.active{display:flex;}');
                parts.push('.slide h1{font-size:6em;margin:0.5em 0;color:black;}');
                parts.push('.slide h2{font-size:5em;margin:0.5em 0;color:black;}');
                parts.push('.slide h3{font-size:4em;margin:0.5em 0;color:black;}');
                parts.push('.slide p{font-size:2.6em;line-height:1.6;margin:0.5em 0;}');
                parts.push('.slide ul,.slide ol{font-size:2.6em;line-height:1.6;margin:0.5em 0;text-align:left;max-width:80%;padding-left:2em;}');
                parts.push('.slide li{margin:0.3em 0;text-align:left;}');
                parts.push('.slide table{border-collapse:collapse;margin:20px auto;font-size:2.6em;}');
                parts.push('.slide table,.slide th,.slide td{border:2px solid black;padding:15px;text-align:center;}');
                parts.push('.slide th{background:#f0f0f0;font-weight:bold;}');
                parts.push('.slide td{background:white;}');
                parts.push('.slide .mermaid{display:block;margin:10px auto;width:100% !important;max-width:100%;}');
                parts.push('.controls{position:fixed;bottom:15px;right:15px;z-index:1000;display:flex;gap:5px;}');
                parts.push('.btn{background:rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.3);color:black;padding:2px 3px;border-radius:50%;cursor:pointer;font-size:16px;width:26px;height:26px;display:inline-flex;align-items:center;justify-content:center;transition:all 0.3s ease;}');
                parts.push('.btn:hover{background:rgba(0,0,0,0.2);transform:scale(1.1);}');
                parts.push('.counter{position:fixed;bottom:15px;right:80px;background:rgba(0,0,0,0.1);color:black;padding:2.5px;border-radius:5px;font-size:3.5px;}');
                parts.push('</style>');
                parts.push('</head>');
                parts.push('<body>');
                
                // Add slides
                for (var i = 0; i < sections.length; i++) {
                    var activeClass = i === 0 ? ' active' : '';
                    parts.push('<div class="slide' + activeClass + '">');
                    parts.push(sections[i].innerHTML);
                    parts.push('</div>');
                }
                
                // Add controls
                parts.push('<div class="controls">');
                parts.push('<button class="btn" onclick="goPrev()">&lt;</button>');
                parts.push('<button class="btn" onclick="goNext()">&gt;</button>');
                parts.push('</div>');
                // parts.push('<div class="counter" id="counter">1 / ' + sections.length + '</div>');
                
                // Add safe JavaScript - no complex quotes
                parts.push('<script>');
                parts.push('var current=0;');
                parts.push('var total=' + sections.length + ';');
                parts.push('var slides=document.querySelectorAll(".slide");');
                parts.push('function updateDisplay(){');
                parts.push('for(var i=0;i<slides.length;i++){');
                parts.push('slides[i].classList.remove("active");');
                parts.push('}');
                parts.push('slides[current].classList.add("active");');
                parts.push('document.getElementById("counter").textContent=(current+1)+" / "+total;');
                parts.push('}');
                parts.push('function goNext(){');
                parts.push('if(current<total-1){');
                parts.push('current++;');
                parts.push('updateDisplay();');
                parts.push('}');
                parts.push('}');
                parts.push('function goPrev(){');
                parts.push('if(current>0){');
                parts.push('current--;');
                parts.push('updateDisplay();');
                parts.push('}');
                parts.push('}');
                parts.push('document.addEventListener("keydown",function(e){');
                parts.push('if(e.key=="ArrowRight"){goNext();}');
                parts.push('if(e.key=="ArrowLeft"){goPrev();}');
                parts.push('});');
                parts.push('</' + 'script>');
                parts.push('</body>');
                parts.push('</html>');
                
                var finalHtml = parts.join('');
                downloadBlob(new Blob([finalHtml], { type: 'text/html' }), title + '.html');
                showNotification('已匯出互動簡報檔案 ' + title + '.html');
            }

            // Get current theme helper function
            function getCurrentTheme() {
                const themeClasses = ['theme-default', 'theme-dark', 'theme-monokai', 'theme-solarized', 'theme-material', 'theme-dracula', 'theme-github'];
                const presentationMode = document.getElementById('presentation-mode');
                
                for (const themeClass of themeClasses) {
                    if (presentationMode && presentationMode.classList.contains(themeClass)) {
                        return themeClass.replace('theme-', '');
                    }
                }
                return 'default';
            }

            // Presentation Mode Functions
            function togglePresentationMode() {
                if (isPresentationMode) {
                    exitPresentationMode();
                } else {
                    enterPresentationMode();
                }
            }

            async function enterPresentationMode() {
                const markdown = editor.getValue();
                const slides = createSlidesFromMarkdown(markdown);
                
                presentationSlides.innerHTML = slides;
                presentationMode.classList.add('active');
                
                // Render Mermaid diagrams in presentation mode
                try {
                    await mermaid.run({ nodes: presentationSlides.querySelectorAll('.mermaid') });
                } catch (error) {
                    console.warn('Mermaid rendering error in presentation:', error);
                }
                
                // Initialize or reinitialize Reveal.js
                if (revealInstance) {
                    // Destroy existing instance to avoid conflicts
                    revealInstance.destroy();
                    revealInstance = null;
                }
                
                // Wait a bit for DOM to settle
                setTimeout(() => {
                    revealInstance = new Reveal({
                        hash: false, // Disable hash to avoid URL conflicts
                        controls: true,
                        progress: true,
                        center: true,
                        transition: 'slide',
                        embedded: false,
                        touch: true,
                        loop: false,
                        rtl: false,
                        navigationMode: 'default',
                        shuffle: false,
                        fragments: true,
                        fragmentInURL: false,
                        help: true,
                        pause: true,
                        showNotes: false,
                        autoPlayMedia: null,
                        preloadIframes: null,
                        autoAnimateEasing: 'ease',
                        autoAnimateDuration: 1.0,
                        autoAnimateUnmatched: true,
                        autoSlide: 0,
                        autoSlideStoppable: true,
                        autoSlideMethod: null,
                        defaultTiming: null,
                        mouseWheel: false,
                        previewLinks: false,
                        postMessage: true,
                        postMessageEvents: false,
                        focusBodyOnPageVisibilityChange: true,
                        transition: 'slide',
                        transitionSpeed: 'default',
                        backgroundTransition: 'fade'
                    });
                    
                    revealInstance.initialize().then(() => {
                        isPresentationMode = true;
                        updatePresentationButton();
                        showNotification('已進入簡報模式，使用方向鍵或按鈕切換投影片');
                        
                        // Force refresh of first slide to ensure proper display
                        setTimeout(() => {
                            if (revealInstance) {
                                revealInstance.sync();
                            }
                        }, 100);
                    });
                }, 50);
            }

            function exitPresentationMode() {
                presentationMode.classList.remove('active');
                isPresentationMode = false;
                updatePresentationButton();
                // 已退出簡報模式
                
                // Clean up reveal.js instance
                if (revealInstance) {
                    revealInstance.destroy();
                    revealInstance = null;
                }
            }

            function updatePresentationButton() {
                if (isPresentationMode) {
                    presentationToggleBtn.innerHTML = '<i class="fas fa-times"></i> 退出簡報';
                    presentationToggleBtn.style.background = '#dc3545';
                } else {
                    presentationToggleBtn.innerHTML = '<i class="fas fa-presentation-screen"></i> 簡報模式';
                    presentationToggleBtn.style.background = '';
                }
            }

            function createSlidesFromMarkdown(markdown) {
                // Clean up markdown first
                markdown = markdown.trim();
                if (!markdown) {
                    return '<section><h1>空白投影片</h1></section>';
                }
                
                // Split by horizontal rules (---) for slide breaks
                const slideContents = markdown.split(/^---$/m);
                let slides = [];
                
                if (slideContents.length > 1) {
                    // Use horizontal rules as separators
                    slides = slideContents.filter(slide => slide.trim());
                } else {
                    // Try splitting by h1 headers
                    const h1Parts = markdown.split(/^# /m);
                    if (h1Parts.length > 1) {
                        slides = h1Parts.filter(slide => slide.trim());
                        // Add back the # to non-first slides (except empty first part)
                        slides = slides.map((slide, index) => {
                            if (index === 0 && !slide.trim()) return null;
                            return index === 0 || !slide.trim() ? slide : '# ' + slide;
                        }).filter(slide => slide !== null);
                    } else {
                        // Try splitting by h2 headers
                        const h2Parts = markdown.split(/^## /m);
                        if (h2Parts.length > 1) {
                            slides = h2Parts.filter(slide => slide.trim());
                            // Add back the ## to non-first slides
                            slides = slides.map((slide, index) => {
                                if (index === 0 && !slide.trim()) return null;
                                return index === 0 || !slide.trim() ? slide : '## ' + slide;
                            }).filter(slide => slide !== null);
                        } else {
                            // No clear separators, use entire content as one slide
                            slides = [markdown];
                        }
                    }
                }

                // Process each slide and handle Mermaid content
                const processedSlides = slides.map((slideContent, index) => {
                    if (!slideContent || !slideContent.trim()) {
                        return '<section><p>空白投影片</p></section>';
                    }
                    
                    try {
                        const htmlContent = marked.parse(slideContent.trim());
                        const slideEl = document.createElement('div');
                        slideEl.innerHTML = htmlContent;
                        
                        // Process Mermaid diagrams in this slide
                        const mermaidElements = slideEl.querySelectorAll('code.language-mermaid');
                        let hasMermaid = false;
                        mermaidElements.forEach(mermaidEl => {
                            const mermaidCode = mermaidEl.textContent;
                            const mermaidContainer = document.createElement('div');
                            mermaidContainer.className = 'mermaid';
                            mermaidContainer.textContent = mermaidCode;
                            const preElement = mermaidEl.closest('pre');
                            if (preElement) {
                                preElement.replaceWith(mermaidContainer);
                                hasMermaid = true;
                            }
                        });
                        
                        // Process math formulas with KaTeX in slides
                        if (typeof renderMathInElement !== 'undefined') {
                            try {
                                renderMathInElement(slideEl, {
                                    delimiters: [
                                        { left: '$$', right: '$$', display: true },
                                        { left: '$', right: '$', display: false },
                                        { left: '\\[', right: '\\]', display: true },
                                        { left: '\\(', right: '\\)', display: false }
                                    ]
                                });
                            } catch (error) {
                                console.warn('KaTeX rendering error in slide:', error);
                            }
                        }
                        
                        // 如果包含 Mermaid，添加特殊類別
                        const sectionClass = hasMermaid ? ' class="has-mermaid"' : '';
                        return `<section${sectionClass}>${slideEl.innerHTML}</section>`;
                    } catch (error) {
                        console.error('Error parsing slide content:', error);
                        return `<section><p>投影片解析錯誤: ${error.message}</p></section>`;
                    }
                });

                return processedSlides.length > 0 ? processedSlides.join('') : '<section><h1>空白投影片</h1></section>';
            }

            function nextSlide() {
                if (revealInstance) {
                    revealInstance.next();
                }
            }

            function prevSlide() {
                if (revealInstance) {
                    revealInstance.prev();
                }
            }
            
            function exportToCsv() {
                // Get all tasks from timer history
                let allTasks = [];
                Object.keys(timerHistory).forEach(date => {
                    timerHistory[date].forEach(task => {
                        if (task.endTime) {
                            allTasks.push({
                                ...task,
                                date: date
                            });
                        }
                    });
                });
                
                if (allTasks.length === 0) {
                    showNotification('沒有可匯出的任務記錄');
                    return;
                }
                
                // Sort by date and start time
                allTasks.sort((a, b) => {
                    if (a.date !== b.date) return a.date.localeCompare(b.date);
                    return a.startTime - b.startTime;
                });
                
                const headers = ["日期", "任務名稱", "開始時間", "結束時間", "持續時間(秒)", "文件名", "章節", "類型"];
                let csv = allTasks.map(t => [
                    `"${t.date}"`,
                    `"${t.name}"`,
                    `"${t.startTime.toLocaleString()}"`,
                    `"${t.endTime.toLocaleString()}"`,
                    t.duration,
                    `"${t.fileName || ''}"`,
                    `"${t.section ? t.section.title : ''}"`,
                    `"${t.isAutoGenerated ? '自動計時' : '手動計時'}"`
                ].join(','));
                
                csv.unshift(headers.join(','));
                downloadBlob(new Blob(['\uFEFF' + csv.join('\n')], { type: 'text/csv;charset=utf-8;' }), `計時記錄_${new Date().toISOString().split('T')[0]}.csv`);
                showNotification(`已匯出 ${allTasks.length} 條計時記錄`);
            }

            function downloadBlob(blob, filename) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }

            // --- Event Listeners ---
            function attachEventListeners() {
                // Helper function to safely add event listeners
                function safeAddEventListener(elementId, event, handler) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.warn(`Element with id '${elementId}' not found`);
                    }
                }
                
                // Main actions
                safeAddEventListener('export-md-btn', 'click', exportToMd);
                safeAddEventListener('export-html-btn', 'click', exportToHtml);
                safeAddEventListener('presentation-toggle-btn', 'click', togglePresentationMode);
                safeAddEventListener('editor-open-files-btn', 'click', () => fileInput.click());
                if (fileInput) fileInput.addEventListener('change', handleFileSelection);
                
                // Presentation controls
                if (prevSlideBtn) prevSlideBtn.addEventListener('click', prevSlide);
                if (nextSlideBtn) nextSlideBtn.addEventListener('click', nextSlide);
                safeAddEventListener('export-presentation-html-btn', 'click', exportPresentationToHtml);
                if (exitPresentationBtn) exitPresentationBtn.addEventListener('click', exitPresentationMode);
                
                // Font settings controls
                safeAddEventListener('font-settings-btn', 'click', () => fontSettingsModal.style.display = 'block');
                safeAddEventListener('close-font-settings-btn', 'click', () => fontSettingsModal.style.display = 'none');
                
                // Shortcuts help controls
                safeAddEventListener('shortcuts-help-btn', 'click', () => document.getElementById('shortcuts-help-modal').style.display = 'block');
                safeAddEventListener('close-shortcuts-help-btn', 'click', () => document.getElementById('shortcuts-help-modal').style.display = 'none');
                safeAddEventListener('font-size-plus', 'click', increaseFontSize);
                safeAddEventListener('font-size-minus', 'click', decreaseFontSize);
                safeAddEventListener('font-size-slider', 'input', handleFontSizeSlider);
                safeAddEventListener('reset-settings-btn', 'click', resetSettings);
                safeAddEventListener('apply-settings-btn', 'click', applySettings);
                
                // Theme button delegation
                const themeButtons = document.querySelectorAll('.theme-btn');
                themeButtons.forEach(btn => {
                    btn.addEventListener('click', () => selectTheme(btn.dataset.theme));
                });
                
                // Timer modal actions
                if (timerBtn) timerBtn.addEventListener('click', openTimerModal);
                safeAddEventListener('close-timer-btn', 'click', () => timerModal.style.display = 'none');
                if (modalStartBtn) modalStartBtn.addEventListener('click', async () => await startModalTask());
                if (modalStopBtn) modalStopBtn.addEventListener('click', async () => await stopCurrentTask());
                if (modalAutoTimerToggle) modalAutoTimerToggle.addEventListener('click', toggleAutoTimer);
                if (modalExportCsvBtn) modalExportCsvBtn.addEventListener('click', exportToCsv);
                if (modalInsertGanttBtn) modalInsertGanttBtn.addEventListener('click', insertGanttChart);
                if (todayBtn) todayBtn.addEventListener('click', () => {
                    datePicker.value = getTodayDateString();
                    renderTimeline();
                    if (chartContainer.style.display !== 'none') {
                        renderChart();
                    }
                });
                if (datePicker) datePicker.addEventListener('change', () => {
                    renderTimeline();
                    if (chartContainer.style.display !== 'none') {
                        renderChart();
                    }
                });
                
                // Tab switching
                if (timelineTabBtn) timelineTabBtn.addEventListener('click', showTimelineView);
                if (chartTabBtn) chartTabBtn.addEventListener('click', showChartView);
                if (chartLevelSelect) chartLevelSelect.addEventListener('change', renderChart);
                
                // Cloud Sync Event Listeners
                if (syncToCloudBtn) syncToCloudBtn.addEventListener('click', handleSyncToCloud);
                if (loadFromCloudBtn) loadFromCloudBtn.addEventListener('click', handleLoadFromCloud);
                const publishSharedBtn = document.getElementById('publish-shared-btn');
                if (publishSharedBtn) publishSharedBtn.addEventListener('click', handlePublishShared);
                if (syncSettingsBtn) syncSettingsBtn.addEventListener('click', openSyncSettings);
                
                // Sync Settings Modal
                safeAddEventListener('close-sync-settings-btn', 'click', () => syncSettingsModal.style.display = 'none');
                safeAddEventListener('github-tab-btn', 'click', () => switchSyncTab('github'));
                safeAddEventListener('webdav-tab-btn', 'click', () => switchSyncTab('webdav'));
                safeAddEventListener('test-connection-btn', 'click', testSyncConnection);
                safeAddEventListener('save-sync-settings-btn', 'click', saveSyncSettings);
                
                // Version History Modal
                safeAddEventListener('close-version-history-btn', 'click', () => versionHistoryModal.style.display = 'none');
                safeAddEventListener('quick-load-latest-btn', 'click', quickLoadLatestVersion);
                safeAddEventListener('refresh-versions-btn', 'click', refreshVersionHistory);
                safeAddEventListener('create-backup-btn', 'click', createBackup);
                
                // Sidebar controls
                if (sidebarToggle) sidebarToggle.addEventListener('click', toggleSidebar);
                if (viewModeToggle) viewModeToggle.addEventListener('click', toggleViewMode);
                if (mobileViewToggle) mobileViewToggle.addEventListener('click', toggleMobileView);
                if (closeFilePanelBtn) closeFilePanelBtn.addEventListener('click', closeSidebar);
                if (tocListEl) tocListEl.addEventListener('click', (e) => { if (e.target.tagName === 'LI') navigateToTocLine(e.target.dataset.line); });
                if (newFileBtn) newFileBtn.addEventListener('click', async () => await createNewFile());
                if (exportWorkspaceBtn) exportWorkspaceBtn.addEventListener('click', exportWorkspace);
                if (importWorkspaceBtn) importWorkspaceBtn.addEventListener('click', () => workspaceInput.click());
                if (workspaceInput) workspaceInput.addEventListener('change', handleWorkspaceImport);
                
                // Editor toolbar event listeners  
                if (editorNewFileBtn) editorNewFileBtn.addEventListener('click', async () => await createNewFile());
                if (editorOpenFilesBtn) editorOpenFilesBtn.addEventListener('click', () => fileInput.click());
                
                // Sidebar dropdown event listeners
                safeAddEventListener('sidebar-sync-to-cloud', 'click', handleSyncToCloud);
                safeAddEventListener('sidebar-load-from-cloud', 'click', handleLoadFromCloud);
                safeAddEventListener('sidebar-publish-share', 'click', handlePublishShared);
                safeAddEventListener('sidebar-sync-settings', 'click', () => {
                    const syncSettingsModal = document.getElementById('sync-settings-modal');
                    if (syncSettingsModal) syncSettingsModal.style.display = 'block';
                });
                safeAddEventListener('sidebar-export-workspace', 'click', exportWorkspace);
                safeAddEventListener('sidebar-import-workspace', 'click', () => workspaceInput.click());
                
                // Dropdown functionality
                document.addEventListener('click', (e) => {
                    const dropdownBtn = e.target.closest('.dropdown-btn');
                    const dropdownContainer = e.target.closest('.dropdown-container');
                    
                    if (dropdownBtn) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const menu = dropdownContainer.querySelector('.dropdown-menu');
                        const isOpen = menu.classList.contains('show');
                        
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('show'));
                        
                        // Toggle current dropdown
                        if (!isOpen) {
                            menu.classList.add('show');
                        }
                    } else if (!dropdownContainer) {
                        // Close all dropdowns when clicking outside
                        document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('show'));
                    }
                });
                
                // Sort files button
                const sortBtn = document.getElementById('sort-files-btn');
                if (sortBtn) sortBtn.addEventListener('click', cycleSortMode);
                
                // View mode controls
                safeAddEventListener('split-view-btn', 'click', () => setViewMode('split'));
                safeAddEventListener('edit-only-btn', 'click', () => setViewMode('edit-only'));
                safeAddEventListener('preview-only-btn', 'click', () => setViewMode('preview-only'));
                safeAddEventListener('drawing-mode-btn', 'click', () => setViewMode('drawing'));
                
                // Fold all button
                safeAddEventListener('fold-all-btn', 'click', foldAllContent);
                
                // Share file button
                safeAddEventListener('share-file-btn', 'click', async () => {
                    if (!currentFile) {
                        showNotification('請先選擇要分享的檔案', 'error');
                        return;
                    }
                    
                    // 檢查當前檔案是否有 #SHARE 標籤
                    if (!syncManager.hasShareTag(currentFile)) {
                        const confirm = window.confirm(
                            '此檔案未包含 #SHARE 標籤，無法分享。\n\n要添加 #SHARE 標籤並分享嗎？\n\n（#SHARE 標籤會被加到檔案開頭）'
                        );
                        
                        if (confirm) {
                            // 添加 #SHARE 標籤到檔案開頭
                            const newContent = '#SHARE\n\n' + currentFile.content;
                            currentFile.content = newContent;
                            editor.setValue(newContent);
                            await saveCurrentFile();
                            showNotification('已添加 #SHARE 標籤到檔案');
                        } else {
                            return;
                        }
                    }
                    
                    // 創建僅包含當前檔案的分享
                    try {
                        showNotification('正在創建分享連結...', 'info');
                        
                        // 檢查 GitHub Token
                        if (!syncSettings.github.token) {
                            showNotification('請先設定 GitHub Token');
                            openSyncSettings();
                            return;
                        }
                        
                        // 創建只包含當前檔案的公開 Gist
                        const gistData = {
                            description: `PowerNote 分享 - ${currentFile.name} - ${new Date().toLocaleString('zh-TW')}`,
                            public: true,
                            files: {
                                [currentFile.name]: {
                                    content: currentFile.content
                                }
                            }
                        };
                        
                        const headers = {
                            'Authorization': `token ${syncSettings.github.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        };
                        
                        const response = await fetch('https://api.github.com/gists', {
                            method: 'POST',
                            headers,
                            body: JSON.stringify(gistData)
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`建立分享失敗: ${error.message}`);
                        }
                        
                        const gist = await response.json();
                        
                        // 生成分享連結
                        const baseUrl = window.location.origin + window.location.pathname.replace('index.html', '') + 'shared.html';
                        const shareUrl = `${baseUrl}?gist=${gist.id}&file=${encodeURIComponent(currentFile.name)}`;
                        
                        // 複製到剪貼簿
                        await navigator.clipboard.writeText(shareUrl);
                        
                        showNotification(`✅ 分享連結已複製到剪貼簿！\n\n${syncManager.extractTitle(currentFile.content)}`);
                        console.log('Share URL:', shareUrl);
                        
                    } catch (error) {
                        console.error('Share file error:', error);
                        showNotification('分享失敗: ' + error.message, 'error');
                    }
                });
                
                // Sync scroll toggle button
                safeAddEventListener('sync-scroll-toggle', 'click', toggleSyncScroll);

                // Delegation for dynamic elements
                if (fileListEl) {
                    fileListEl.addEventListener('click', async (e) => {
                        if (e.target.classList.contains('file-item') || e.target.classList.contains('file-item-name')) {
                            const fileId = e.target.dataset.fileId || e.target.closest('.file-item').dataset.fileId;
                            if (fileId) loadFile(fileId);
                        } else if (e.target.closest('.delete-btn')) {
                            e.stopPropagation();
                            const fileId = e.target.closest('.delete-btn').dataset.fileId;
                            if (fileId) await deleteFile(fileId);
                        } else if (e.target.closest('.rename-btn')) {
                            e.stopPropagation();
                            const fileId = e.target.closest('.rename-btn').dataset.fileId;
                            if (fileId) startRenameFile(fileId);
                        } else if (e.target.closest('.pin-button')) {
                            e.stopPropagation();
                            const fileId = e.target.closest('.pin-button').dataset.fileId;
                            if (fileId) await togglePinFile(fileId);
                        }
                    });
                }

                // Scroll sync - bind to the actual scrollable container
                const previewContainer = document.querySelector('.preview-container');
                if (previewContainer) {
                    previewContainer.addEventListener('scroll', syncEditorScroll, { passive: true });
                }
                
                // Modal close on outside click
                window.addEventListener('click', (e) => {
                    if (e.target === timerModal) timerModal.style.display = 'none';
                    if (e.target === fontSettingsModal) fontSettingsModal.style.display = 'none';
                    const shortcutsModal = document.getElementById('shortcuts-help-modal');
                    if (e.target === shortcutsModal) shortcutsModal.style.display = 'none';
                    
                    // Close autocomplete if clicking outside
                    if (autocompleteDropdown && !autocompleteDropdown.contains(e.target)) {
                        removeAutocompleteDropdown();
                    }
                });
                
                // Search Bar Listeners
                if (searchPrevBtn) searchPrevBtn.addEventListener('click', jumpToPrevSearchMatch);
                if (searchNextBtn) searchNextBtn.addEventListener('click', jumpToNextSearchMatch);
                if (searchScopeToggle) searchScopeToggle.addEventListener('click', toggleSearchScope);
                if (searchTagFilterBtn) searchTagFilterBtn.addEventListener('click', openTagFilterModal);
                if (searchCloseBtn) searchCloseBtn.addEventListener('click', closeSearch);
                if (searchInput) {
                    searchInput.addEventListener('input', performSearch);
                    searchInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            jumpToNextSearchMatch();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            closeSearch();
                        }
                    });
                }

                // Keyboard shortcuts for presentation mode
                document.addEventListener('keydown', async (e) => {
                    if (e.ctrlKey && e.key === 'f') {
						e.preventDefault();
						toggleSearchBar();
					}
					if (isPresentationMode) {
						if (e.key === 'Escape') {
                            exitPresentationMode();
                        }
                    } else {
                        // F5 to enter presentation mode
                        if (e.key === 'F5') {
                            e.preventDefault();
                            enterPresentationMode();
                        }
                        // Ctrl+N to create new file
                        if (e.ctrlKey && e.key === 'n') {
                            e.preventDefault();
                            await createNewFile();
                        }
                        // Ctrl+O to toggle sidebar
                        if (e.ctrlKey && e.key === 'o') {
                            e.preventDefault();
                            toggleSidebar();
                        }
                        
                        // Markdown formatting shortcuts
                        if (e.ctrlKey && e.key === 'b') {
                            e.preventDefault();
                            toggleMarkdownFormat('**', '**', '粗體文字');
                        }
                        if (e.ctrlKey && e.key === 'i') {
                            e.preventDefault();
                            toggleMarkdownFormat('*', '*', '斜體文字');
                        }
                        if (e.ctrlKey && e.key === 'u') {
                            e.preventDefault();
                            toggleMarkdownFormat('<u>', '</u>', '下劃線文字');
                        }
                        if (e.ctrlKey && e.key === 'k') {
                            e.preventDefault();
                            toggleMarkdownFormat('[', '](https://)', '連結文字');
                        }
                        if (e.ctrlKey && e.key === '`') {
                            e.preventDefault();
                            toggleMarkdownFormat('`', '`', '程式碼');
                        }
                        if (e.ctrlKey && e.shiftKey && e.key === '`') {
                            e.preventDefault();
                            toggleMarkdownFormat('```\n', '\n```', '程式碼區塊');
                        }
                        if (e.ctrlKey && e.key === 'd') {
                            e.preventDefault();
                            toggleMarkdownFormat('~~', '~~', '刪除線文字');
                        }
                        
                        // Header shortcuts
                        if (e.ctrlKey && e.key === '1') {
                            e.preventDefault();
                            toggleLinePrefix('# ', '標題 1');
                        }
                        if (e.ctrlKey && e.key === '2') {
                            e.preventDefault();
                            toggleLinePrefix('## ', '標題 2');
                        }
                        if (e.ctrlKey && e.key === '3') {
                            e.preventDefault();
                            toggleLinePrefix('### ', '標題 3');
                        }
                        if (e.ctrlKey && e.key === '4') {
                            e.preventDefault();
                            toggleLinePrefix('#### ', '標題 4');
                        }
                        if (e.ctrlKey && e.key === '5') {
                            e.preventDefault();
                            toggleLinePrefix('##### ', '標題 5');
                        }
                        if (e.ctrlKey && e.key === '6') {
                            e.preventDefault();
                            toggleLinePrefix('###### ', '標題 6');
                        }
                        
                        // List shortcuts
                        if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                            e.preventDefault();
                            toggleLinePrefix('- ', '列表項目');
                        }
                        if (e.ctrlKey && e.shiftKey && e.key === 'O') {
                            e.preventDefault();
                            toggleLinePrefix('1. ', '有序列表項目');
                        }
                        if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                            e.preventDefault();
                            toggleLinePrefix('- [ ] ', '待辦事項');
                        }
                        
                        // Quote shortcut
                        if (e.ctrlKey && e.shiftKey && e.key === 'Q') {
                            e.preventDefault();
                            toggleLinePrefix('> ', '引用文字');
                        }
                        
                    }
                });
                
                // 確保預覽容器初始化後可以滾動
                setTimeout(() => {
                    if (previewContainer) {
                        console.log('Preview container height:', previewContainer.scrollHeight, 'Client height:', previewContainer.clientHeight);
                    }
                }, 1000);

                // 搜尋切換按鈕的事件監聽器
                if (searchToggleButton) searchToggleButton.addEventListener('click', toggleSearchBar);
                
                // Tag Filter Modal Event Listeners
                if (closeTagFilterBtn) closeTagFilterBtn.addEventListener('click', cancelTagFilter);
                if (selectAllTagsBtn) selectAllTagsBtn.addEventListener('click', selectAllTags);
                if (deselectAllTagsBtn) deselectAllTagsBtn.addEventListener('click', deselectAllTags);
                if (applyTagFilterBtn) applyTagFilterBtn.addEventListener('click', applyTagFilter);
                if (cancelTagFilterBtn) cancelTagFilterBtn.addEventListener('click', cancelTagFilter);
                
                // Click outside modal to close
                if (tagFilterModal) {
                    tagFilterModal.addEventListener('click', (e) => {
                        if (e.target === tagFilterModal) {
                            cancelTagFilter();
                        }
                    });
                }
            }

            // 移除失去焦點時的計時觸發，改用文字編輯觸發
            // window.addEventListener('blur', () => { handleCursorTimerTracking(); });
            // if (editor) editor.on('blur', handleCursorTimerTracking);

			// --- Search Functions ---
            function toggleSearchBar() {
                if (searchBar.classList.contains('active')) {
                    closeSearch();
                } else {
                    searchBar.classList.add('active');
                    searchInput.focus();
                    if (searchInput.value) {
                        performSearch(); // Re-run search if there's already a query
                    }
                }
            }

            // Utility for escaping regex special characters
            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            function performSearch() {
                clearAllSearchHighlights();
                allSearchResults = [];
                currentSearchMatchIndex = -1;
                if (currentMatchMarker) { currentMatchMarker.clear(); currentMatchMarker = null; }

                const queryText = searchInput.value.trim();
                if (!queryText) {
                    updateSearchMatchCounter(0, 0);
                    return;
                }

                // Treat space-separated keywords as AND logic for matching lines,
                // but highlight all occurrences of any keyword within those lines.
                searchKeywords = queryText.split(/\s+/).filter(k => k.length > 0);
                if (searchKeywords.length === 0) {
                    updateSearchMatchCounter(0, 0);
                    return;
                }
                
                // Regex to highlight any of the keywords
                const highlightPattern = new RegExp(`(${searchKeywords.map(k => escapeRegExp(k)).join('|')})`, 'gi');

                let filesToSearch = [];
                if (currentSearchScope === 'current' && currentFile) {
                    filesToSearch = [currentFile];
                } else if (currentSearchScope === 'all') {
                    filesToSearch = files;
                    
                    // Apply tag filtering if in 'all' scope and tags are selected
                    if (selectedTags.size > 0) {
                        filesToSearch = filesToSearch.filter(file => shouldIncludeFileByTags(file));
                    }
                } else {
                    updateSearchMatchCounter(0, 0);
                    return;
                }

                filesToSearch.forEach(file => {
                    const content = file.content;
                    const lines = content.split('\n');
                    
                    lines.forEach((line, lineIndex) => {
                        // AND logic: Check if all keywords are present in the line (case-insensitive)
                        const allKeywordsPresent = searchKeywords.every(keyword => 
                            line.toLowerCase().includes(keyword.toLowerCase())
                        );

                        if (allKeywordsPresent) {
                            // If all keywords are present, find all occurrences of *any* keyword for highlighting
                            let match;
                            // Reset the regex lastIndex for each line to ensure correct matching
                            highlightPattern.lastIndex = 0; 
                            while ((match = highlightPattern.exec(line)) !== null) {
                                const from = { line: lineIndex, ch: match.index };
                                const to = { line: lineIndex, ch: match.index + match[0].length };
                                allSearchResults.push({ fileId: file.id, from, to });
                            }
                        }
                    });
                });

                highlightAllSearchResults();
                updateSearchMatchCounter(0, allSearchResults.length);
                if (allSearchResults.length > 0) {
                    jumpToSearchMatch(0);
                } else {
                    editor.setSelection(editor.getCursor()); // Clear previous selection
                }
            }

            function highlightAllSearchResults() {
                clearAllSearchHighlights();
                allSearchResults.forEach(result => {
                    if (currentFile && result.fileId === currentFile.id) {
                        const marker = editor.markText(result.from, result.to, { className: 'highlighted-search' });
                        currentHighlightedMarkers.push(marker);
                    }
                });
            }

            function clearAllSearchHighlights() {
                currentHighlightedMarkers.forEach(marker => marker.clear());
                currentHighlightedMarkers = [];
                if (currentMatchMarker) { currentMatchMarker.clear(); currentMatchMarker = null; }
            }

            function jumpToSearchMatch(index) {
                if (allSearchResults.length === 0) return;

                const clampedIndex = Math.max(0, Math.min(index, allSearchResults.length - 1));
                currentSearchMatchIndex = clampedIndex;

                const match = allSearchResults[currentSearchMatchIndex];
                
                if (currentFile && match.fileId === currentFile.id) {
                    // Match in current open file, just jump
                    editor.setSelection(match.from, match.to);
                    editor.scrollIntoView(match.from, 20); // scrollIntoView with padding
                    highlightCurrentMatch();
                } else {
                    // Match in another file, load it first
                    loadFile(match.fileId); 
                    // Need a slight delay for editor to update its content before setting cursor/highlighting
                    setTimeout(() => {
                        editor.setSelection(match.from, match.to);
                        editor.scrollIntoView(match.from, 20);
                        highlightAllSearchResults(); // Re-highlight all matches for the new file
                        highlightCurrentMatch();
                    }, 100);
                }
                updateSearchMatchCounter(currentSearchMatchIndex + 1, allSearchResults.length);
            }

            function jumpToNextSearchMatch() {
                if (allSearchResults.length === 0) return;
                let nextIndex = currentSearchMatchIndex + 1;
                if (nextIndex >= allSearchResults.length) {
                    nextIndex = 0; // Wrap around
                }
                jumpToSearchMatch(nextIndex);
            }

            function jumpToPrevSearchMatch() {
                if (allSearchResults.length === 0) return;
                let prevIndex = currentSearchMatchIndex - 1;
                if (prevIndex < 0) {
                    prevIndex = allSearchResults.length - 1; // Wrap around
                }
                jumpToSearchMatch(prevIndex);
            }

            function highlightCurrentMatch() {
                if (currentMatchMarker) {
                    currentMatchMarker.clear();
                    currentMatchMarker = null;
                }

                if (allSearchResults.length > 0) {
                    const currentMatch = allSearchResults[currentSearchMatchIndex];
                    if (currentFile && currentMatch.fileId === currentFile.id) {
                        currentMatchMarker = editor.markText(currentMatch.from, currentMatch.to, { className: 'current-highlighted-search' });
                    }
                }
            }

            function updateSearchMatchCounter(current, total) {
                searchMatchCount.textContent = total > 0 ? `${current} / ${total}` : '0 / 0';
            }

            function toggleSearchScope() {
                currentSearchScope = currentSearchScope === 'current' ? 'all' : 'current';
                searchScopeToggle.innerHTML = `<i class="fas fa-folder"></i> ${currentSearchScope === 'current' ? '當前檔案' : '所有檔案'}`;
                
                // Show/hide tag filter button based on scope
                if (currentSearchScope === 'all') {
                    searchTagFilterBtn.style.display = 'block';
                } else {
                    searchTagFilterBtn.style.display = 'none';
                }
                
                performSearch(); // Re-run search with new scope
            }

            // Tag filtering functions
            function getAvailableTagsFromNoteTag() {
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) return [];
                
                const tags = [];
                const hashtagRegex = /^### (.+)$/gm;
                let match;
                
                while ((match = hashtagRegex.exec(noteTagFile.content)) !== null) {
                    tags.push(match[1]);
                }
                
                return tags;
            }

            function openTagFilterModal() {
                availableTags = getAvailableTagsFromNoteTag();
                
                if (availableTags.length === 0) {
                    showNotification('找不到可用的標籤。請先在 NoteTag.md 中定義標籤。');
                    return;
                }
                
                populateTagFilterList();
                tagFilterModal.style.display = 'block';
            }

            function populateTagFilterList() {
                tagFilterList.innerHTML = '';
                
                availableTags.forEach(tag => {
                    const tagItem = document.createElement('div');
                    tagItem.className = 'tag-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `tag-${tag}`;
                    checkbox.value = tag;
                    checkbox.checked = selectedTags.has(tag);
                    
                    const label = document.createElement('label');
                    label.htmlFor = `tag-${tag}`;
                    label.textContent = tag;
                    
                    tagItem.appendChild(checkbox);
                    tagItem.appendChild(label);
                    tagFilterList.appendChild(tagItem);
                });
            }

            function selectAllTags() {
                const checkboxes = tagFilterList.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = true);
            }

            function deselectAllTags() {
                const checkboxes = tagFilterList.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = false);
            }

            function applyTagFilter() {
                const checkboxes = tagFilterList.querySelectorAll('input[type="checkbox"]');
                selectedTags.clear();
                
                checkboxes.forEach(cb => {
                    if (cb.checked) {
                        selectedTags.add(cb.value);
                    }
                });
                
                tagFilterModal.style.display = 'none';
                performSearch(); // Re-run search with tag filter
                
                // Update button text to show filter status
                const filterText = selectedTags.size === 0 ? '標籤' : `標籤(${selectedTags.size})`;
                searchTagFilterBtn.textContent = filterText;
            }

            function cancelTagFilter() {
                tagFilterModal.style.display = 'none';
            }

            // Check if a file should be included based on tag filtering
            function shouldIncludeFileByTags(file) {
                // If no tags are selected, include all files
                if (selectedTags.size === 0) {
                    return true;
                }
                
                // Check if the file content contains any of the selected tags as hashtags
                const content = file.content;
                if (!content) return false;
                
                // Look for #tagname patterns in the file content
                for (const tag of selectedTags) {
                    const tagPattern = new RegExp(`^#${escapeRegExp(tag)}(?=\\s|$)`, 'gm');
                    if (tagPattern.test(content)) {
                        return true;
                    }
                }
                
                return false;
            }

            function closeSearch() {
                searchBar.classList.remove('active');
                clearAllSearchHighlights();
                allSearchResults = [];
                currentSearchMatchIndex = -1;
                searchInput.value = '';
                editor.focus();
            }
			// --- Search Functions End ---

            // 切換自動計時功能
            function toggleAutoTimer() {
                autoTimerEnabled = !autoTimerEnabled;
                updateAutoTimerUI();
                console.log(`自動計時功能${autoTimerEnabled ? '已開啟' : '已關閉'} (Enter按鍵觸發)`);
                showNotification(`自動計時功能${autoTimerEnabled ? '已開啟' : '已關閉'}\n觸發方式：Enter按鍵`);
            }
            
            function updateAutoTimerUI() {
                if (modalAutoTimerToggle) {
                    if (autoTimerEnabled) {
                        modalAutoTimerToggle.classList.add('active');
                        modalAutoTimerToggle.innerHTML = '<i class="fas fa-magic"></i> 自動計時';
                    } else {
                        modalAutoTimerToggle.classList.remove('active');
                        modalAutoTimerToggle.innerHTML = '<i class="fas fa-magic"></i> 自動計時';
                    }
                }
            }

            // --- View Mode Functions ---
            function setViewMode(mode) {
                currentViewMode = mode;
                const editorPanel = document.getElementById('editor-panel');
                const previewPanel = document.getElementById('preview-panel');
                const drawingPanel = document.getElementById('drawing-panel');
                const splitBtn = document.getElementById('split-view-btn');
                const editBtn = document.getElementById('edit-only-btn');
                const previewBtn = document.getElementById('preview-only-btn');
                const drawingBtn = document.getElementById('drawing-mode-btn');
                const syncScrollToggle = document.getElementById('sync-scroll-toggle');
                
                // Reset button states
                [splitBtn, editBtn, previewBtn, drawingBtn].forEach(btn => {
                    if (btn) btn.classList.remove('active');
                });
                
                // Hide divider and remove drawing mode class for non-drawing modes
                const divider = document.getElementById('panel-divider');
                const mainContent = document.querySelector('.main-editor-content');
                
                // Reset panel flex styles for non-drawing modes
                if (mode !== 'drawing') {
                    editorPanel.style.flex = '';
                    editorPanel.style.width = '';
                    previewPanel.style.flex = '';
                    previewPanel.style.width = '';
                    if (drawingPanel) drawingPanel.style.flex = '';
                }
                
                switch(mode) {
                    case 'split':
                        editorPanel.style.display = 'flex';
                        previewPanel.style.display = 'flex';
                        drawingPanel.style.display = 'none';
                        if (divider) divider.style.display = 'none';
                        if (mainContent) mainContent.classList.remove('drawing-mode');
                        if (syncScrollToggle) syncScrollToggle.style.display = 'block';
                        splitBtn.classList.add('active');
                        break;
                    case 'edit-only':
                        editorPanel.style.display = 'flex';
                        editorPanel.style.width = '100%';
                        previewPanel.style.display = 'none';
                        drawingPanel.style.display = 'none';
                        if (divider) divider.style.display = 'none';
                        if (mainContent) mainContent.classList.remove('drawing-mode');
                        if (syncScrollToggle) syncScrollToggle.style.display = 'none';
                        editBtn.classList.add('active');
                        break;
                    case 'preview-only':
                        editorPanel.style.display = 'none';
                        previewPanel.style.display = 'flex';
                        previewPanel.style.width = '100%';
                        drawingPanel.style.display = 'none';
                        if (divider) divider.style.display = 'none';
                        if (mainContent) mainContent.classList.remove('drawing-mode');
                        if (syncScrollToggle) syncScrollToggle.style.display = 'none';
                        previewBtn.classList.add('active');
                        break;
                    case 'drawing':
                        editorPanel.style.display = 'flex';
                        previewPanel.style.display = 'none';
                        drawingPanel.style.display = 'flex';
                        if (divider) divider.style.display = 'flex';
                        
                        // Add drawing mode class for special layout
                        if (mainContent) mainContent.classList.add('drawing-mode');
                        if (syncScrollToggle) syncScrollToggle.style.display = 'none';
                        
                        drawingBtn.classList.add('active');
                        initDrawingCanvas();
                        setupPanelResizer();
                        break;
                }
                
                // Refresh editor if switching back to edit mode
                if (mode !== 'preview-only') {
                    setTimeout(() => editor.refresh(), 100);
                }
                
                // Only save configuration if not currently loading configuration
                if (!isLoadingConfiguration) {
                    saveConfiguration(); // Auto-save configuration
                }
            }
            
            // --- Section Navigation ---
            function navigateToSection(sectionName) {
                if (!editor || !sectionName) return;
                
                const lines = editor.getValue().split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const match = line.match(/^#+\s+(.+)$/);
                    if (match && match[1].toLowerCase().includes(sectionName.toLowerCase())) {
                        editor.setCursor({ line: i, ch: 0 });
                        editor.focus();
                        showNotification(`已跳轉到段落：${sectionName}`);
                        break;
                    }
                }
            }

            // --- Editor Link Click Handling ---
            function handleEditorLinkClick(cm, pos, line, token) {
                const text = line;
                const ch = pos.ch;
                
                // 檢查hashtag (#tag)
                const hashtagMatch = findLinkAtPosition(text, ch, /(?:^|\s)(#([^\s#]+))(?=\s|$)/g);
                if (hashtagMatch) {
                    const hashtag = hashtagMatch.match[2]; // 提取標籤名（不包含#）
                    navigateToHashtag(hashtag);
                    return true;
                }
                
                // 檢查wiki連結 ([[link]])
                const wikiMatch = findLinkAtPosition(text, ch, /\[\[([^\]]+)\]\]/g);
                if (wikiMatch) {
                    const linkContent = wikiMatch.match[1];
                    const [noteName, sectionName] = linkContent.split('#');
                    
                    // 查找對應的檔案
                    const targetFile = files.find(f => 
                        f.name.replace(/\.[^/.]+$/, "").toLowerCase() === noteName.toLowerCase()
                    );
                    
                    if (targetFile) {
                        loadFile(targetFile.id);
                        if (sectionName) {
                            setTimeout(() => {
                                navigateToSection(sectionName);
                            }, 100);
                        }
                        showNotification(`已跳轉到：${noteName}${sectionName ? '#' + sectionName : ''}`);
                    } else {
                        showNotification(`找不到筆記：${noteName}`);
                    }
                    return true;
                }
                
                // 檢查URL連結
                const urlMatch = findLinkAtPosition(text, ch, /(https?:\/\/[^\s\)]+)/g);
                if (urlMatch) {
                    const url = urlMatch.match[1];
                    window.open(url, '_blank');
                    showNotification(`已開啟連結：${url}`);
                    return true;
                }
                
                return false;
            }

            // 輔助函數：在指定位置查找連結
            function findLinkAtPosition(text, ch, regex) {
                let match;
                while ((match = regex.exec(text)) !== null) {
                    const start = match.index;
                    const end = start + match[0].length;
                    
                    if (ch >= start && ch <= end) {
                        return { match: match, start: start, end: end };
                    }
                }
                return null;
            }

            // --- Mobile Jump Button ---
            let currentMobileLink = null;
            
            function updateMobileJumpButton(cm) {
                const cursor = cm.getCursor();
                const line = cm.getLine(cursor.line);
                const token = cm.getTokenAt(cursor);
                
                const linkInfo = detectLinkAtCursor(line, cursor.ch);
                const jumpBtn = document.getElementById('mobile-jump-btn');
                
                if (linkInfo) {
                    currentMobileLink = linkInfo;
                    if (!jumpBtn) {
                        createMobileJumpButton();
                    } else {
                        jumpBtn.style.display = 'block';
                        jumpBtn.title = `跳轉到：${linkInfo.display}`;
                    }
                } else {
                    currentMobileLink = null;
                    if (jumpBtn) {
                        jumpBtn.style.display = 'none';
                    }
                }
            }

            function detectLinkAtCursor(line, ch) {
                // 檢查hashtag
                const hashtagMatch = findLinkAtPosition(line, ch, /(?:^|\s)(#([^\s#]+))(?=\s|$)/g);
                if (hashtagMatch) {
                    return {
                        type: 'hashtag',
                        content: hashtagMatch.match[2],
                        display: `#${hashtagMatch.match[2]}`
                    };
                }
                
                // 檢查wiki連結
                const wikiMatch = findLinkAtPosition(line, ch, /\[\[([^\]]+)\]\]/g);
                if (wikiMatch) {
                    return {
                        type: 'wiki',
                        content: wikiMatch.match[1],
                        display: wikiMatch.match[1]
                    };
                }
                
                // 檢查URL
                const urlMatch = findLinkAtPosition(line, ch, /(https?:\/\/[^\s\)]+)/g);
                if (urlMatch) {
                    return {
                        type: 'url',
                        content: urlMatch.match[1],
                        display: urlMatch.match[1]
                    };
                }
                
                return null;
            }

            function createMobileJumpButton() {
                const toolbar = document.querySelector('.toolbar');
                if (!toolbar) return;
                
                const jumpBtn = document.createElement('button');
                jumpBtn.id = 'mobile-jump-btn';
                jumpBtn.innerHTML = '<i class="fas fa-external-link-alt"></i>';
                jumpBtn.title = '跳轉連結';
                jumpBtn.style.display = 'none';
                jumpBtn.addEventListener('click', handleMobileJumpClick);
                
                // 插入到工具列適當位置（在搜尋按鈕之前）
                const searchBtn = document.getElementById('search-toggle-btn');
                if (searchBtn) {
                    toolbar.insertBefore(jumpBtn, searchBtn);
                } else {
                    toolbar.appendChild(jumpBtn);
                }
            }

            function handleMobileJumpClick() {
                if (!currentMobileLink) return;
                
                switch (currentMobileLink.type) {
                    case 'hashtag':
                        navigateToHashtag(currentMobileLink.content);
                        break;
                    case 'wiki':
                        const [noteName, sectionName] = currentMobileLink.content.split('#');
                        const targetFile = files.find(f => 
                            f.name.replace(/\.[^/.]+$/, "").toLowerCase() === noteName.toLowerCase()
                        );
                        
                        if (targetFile) {
                            loadFile(targetFile.id);
                            if (sectionName) {
                                setTimeout(() => {
                                    navigateToSection(sectionName);
                                }, 100);
                            }
                            showNotification(`已跳轉到：${noteName}${sectionName ? '#' + sectionName : ''}`);
                        } else {
                            showNotification(`找不到筆記：${noteName}`);
                        }
                        break;
                    case 'url':
                        window.open(currentMobileLink.content, '_blank');
                        showNotification(`已開啟連結：${currentMobileLink.content}`);
                        break;
                }
            }
            
            // --- Wiki Link Autocomplete ---
            function createAutocompleteDropdown(items, cursorPos) {
                removeAutocompleteDropdown();
                
                if (items.length === 0) return;
                
                autocompleteDropdown = document.createElement('div');
                autocompleteDropdown.className = 'autocomplete-dropdown';
                autocompleteSelectedIndex = -1;
                
                items.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-item';
                    div.dataset.index = index;
                    
                    if (item.section) {
                        div.innerHTML = `
                            <div class="autocomplete-note-name">${item.fileName}</div>
                            <div class="autocomplete-section"># ${item.section}</div>
                        `;
                        div.dataset.insertText = `${item.fileName}#${item.section}`;
                    } else {
                        div.innerHTML = `<div class="autocomplete-note-name">${item.fileName}</div>`;
                        div.dataset.insertText = item.fileName;
                    }
                    
                    div.addEventListener('click', () => {
                        insertAutocompleteItem(div.dataset.insertText);
                    });
                    
                    autocompleteDropdown.appendChild(div);
                });
                
                // Position the dropdown
                const coords = editor.cursorCoords(cursorPos, 'page');
                autocompleteDropdown.style.left = coords.left + 'px';
                autocompleteDropdown.style.top = (coords.bottom + 5) + 'px';
                
                document.body.appendChild(autocompleteDropdown);
            }
            
            function removeAutocompleteDropdown() {
                if (autocompleteDropdown && autocompleteDropdown.parentNode) {
                    autocompleteDropdown.parentNode.removeChild(autocompleteDropdown);
                    autocompleteDropdown = null;
                    autocompleteSelectedIndex = -1;
                }
            }
            
            function insertAutocompleteItem(text) {
                const cursor = editor.getCursor();
                const line = editor.getLine(cursor.line);
                const start = line.lastIndexOf('[[', cursor.ch);
                
                if (start !== -1) {
                    editor.replaceRange(
                        `[[${text}]]`,
                        { line: cursor.line, ch: start },
                        { line: cursor.line, ch: cursor.ch }
                    );
                }
                
                removeAutocompleteDropdown();
                editor.focus();
            }
            
            function getAutocompleteItems(query) {
                const items = [];
                
                files.forEach(file => {
                    const fileName = file.name.replace(/\.[^/.]+$/, "");
                    
                    // Add file name match
                    if (fileName.toLowerCase().includes(query.toLowerCase())) {
                        items.push({ fileName, file });
                    }
                    
                    // Add section matches
                    const lines = file.content.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/^#+\s+(.+)$/);
                        if (match) {
                            const sectionTitle = match[1];
                            if (sectionTitle.toLowerCase().includes(query.toLowerCase())) {
                                items.push({ 
                                    fileName, 
                                    section: sectionTitle, 
                                    file 
                                });
                            }
                        }
                    });
                });
                
                return items.slice(0, 10); // Limit to 10 items
            }
            
            function handleAutocompleteNavigation(e) {
                if (!autocompleteDropdown) return false;
                
                const items = autocompleteDropdown.querySelectorAll('.autocomplete-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, items.length - 1);
                    updateAutocompleteSelection();
                    return true;
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                    updateAutocompleteSelection();
                    return true;
                } else if (e.key === 'Enter' && autocompleteSelectedIndex >= 0) {
                    e.preventDefault();
                    const selectedItem = items[autocompleteSelectedIndex];
                    
                    // Check if this is a hashtag dropdown
                    if (autocompleteDropdown.classList.contains('hashtag-dropdown')) {
                        // Handle hashtag selection
                        const cursor = autocompleteDropdown.cursorPosition;
                        const line = editor.getLine(cursor.line);
                        const beforeCursor = line.substring(0, cursor.ch);
                        const hashtagMatch = beforeCursor.match(/#([^#\s]*)$/);
                        
                        if (hashtagMatch) {
                            const startPos = cursor.ch - hashtagMatch[0].length;
                            const endPos = cursor.ch;
                            const value = selectedItem.dataset.insertText;
                            
                            editor.replaceRange(`#${value} `, 
                                { line: cursor.line, ch: startPos },
                                { line: cursor.line, ch: endPos }
                            );
                            
                            // Handle hashtag creation for both new and existing hashtags
                            handleHashtagCreation(value, getCurrentFileName());
                            
                            removeAutocompleteDropdown();
                        }
                    } else {
                        // Handle regular autocomplete
                        insertAutocompleteItem(selectedItem.dataset.insertText);
                    }
                    return true;
                } else if (e.key === 'Escape') {
                    removeAutocompleteDropdown();
                    return true;
                }
                
                return false;
            }
            
            function updateAutocompleteSelection() {
                if (!autocompleteDropdown) return;
                
                const items = autocompleteDropdown.querySelectorAll('.autocomplete-item');
                items.forEach((item, index) => {
                    if (index === autocompleteSelectedIndex) {
                        item.classList.add('selected');
                        // Scroll into view if needed
                        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }

            // --- Helper Functions ---
            function getWelcomeMessage() {
                return `# 歡迎使用 PowerNote Pro 2.4!\n\n**最新功能：**\n- Wiki連結自動補全功能\n- 支援段落跳轉 [[筆記名#段落名]]\n- 編輯模式切換（編輯/渲染、純編輯、純渲染）\n- 支援HTML內容渲染\n\n## Wiki連結使用方法\n\n1. 輸入 [[ 會自動顯示筆記建議\n2. 支援 [[筆記名]] 和 [[筆記名#段落名]] 語法\n3. 點擊連結可快速跳轉到對應筆記和段落\n\n## 編輯模式\n\n- **編輯/渲染**：同時顯示編輯器和預覽\n- **純編輯**：只顯示編輯器\n- **純渲染**：只顯示預覽\n\n*祝您有充滿生產力的一天！*`;
            }
            
            // --- Global Insert Functions ---

            // --- Font and Theme Settings Functions ---
            function updateFontSize(size) {
                currentFontSize = size;
                
                // Update editor font size
                const codeMirrorElement = document.querySelector('.CodeMirror');
                if (codeMirrorElement) {
                    codeMirrorElement.style.fontSize = size + 'px';
                }
                
                // Update preview font size
                const previewElement = document.getElementById('preview');
                if (previewElement) {
                    previewElement.style.fontSize = size + 'px';
                }
                
                // Update UI elements
                const currentFontSizeSpan = document.getElementById('current-font-size');
                const fontSizeDisplay = document.getElementById('font-size-display');
                const fontSizeSlider = document.getElementById('font-size-slider');
                
                if (currentFontSizeSpan) currentFontSizeSpan.textContent = size + 'px';
                if (fontSizeDisplay) fontSizeDisplay.textContent = size + 'px';
                if (fontSizeSlider) fontSizeSlider.value = size;
                
                // Save to IndexedDB (don't await to avoid blocking UI)
                saveToIndexedDB('powernote-font-size', size);
                // Only save configuration if not currently loading configuration
                if (!isLoadingConfiguration) {
                    saveConfiguration(); // Auto-save configuration
                }
            }
            
            function increaseFontSize() {
                if (currentFontSize < 32) {
                    updateFontSize(currentFontSize + 1);
                }
            }
            
            function decreaseFontSize() {
                if (currentFontSize > 12) {
                    updateFontSize(currentFontSize - 1);
                }
            }
            
            function handleFontSizeSlider(event) {
                const size = parseInt(event.target.value);
                updateFontSize(size);
            }
            
            function selectTheme(theme) {
                currentEditorTheme = theme;
                
                // Update editor theme
                if (editor) {
                    editor.setOption('theme', theme);
                }
                
                // Apply theme to preview area
                const previewContainer = document.querySelector('.preview-container');
                const mainPanel = document.querySelector('.main-panel');
                const presentationMode = document.getElementById('presentation-mode');
                
                // Remove all theme classes
                const themeClasses = ['theme-default', 'theme-monokai', 'theme-solarized', 'theme-material', 'theme-dracula', 'theme-github'];
                
                if (previewContainer) {
                    themeClasses.forEach(cls => previewContainer.classList.remove(cls));
                    // Handle solarized dark special case
                    previewContainer.classList.remove('dark');
                }
                
                if (presentationMode) {
                    themeClasses.forEach(cls => presentationMode.classList.remove(cls));
                    presentationMode.classList.remove('dark');
                }
                
                // Apply new theme class
                let themeClass = 'theme-' + theme.replace(' ', '-');
                let darkClass = '';
                
                if (theme === 'solarized dark') {
                    themeClass = 'theme-solarized';
                    darkClass = 'dark';
                }
                
                if (previewContainer) {
                    previewContainer.classList.add(themeClass);
                    if (darkClass) previewContainer.classList.add(darkClass);
                }
                
                if (presentationMode) {
                    presentationMode.classList.add(themeClass);
                    if (darkClass) presentationMode.classList.add(darkClass);
                }
                
                // Update theme button states
                const themeButtons = document.querySelectorAll('.theme-btn');
                themeButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.theme === theme) {
                        btn.classList.add('active');
                    }
                });
                
                // Save to IndexedDB
                saveToIndexedDB('powernote-editor-theme', theme);
                // Only save configuration if not currently loading configuration
                if (!isLoadingConfiguration) {
                    saveConfiguration(); // Auto-save configuration
                }
            }
            
            function updateEditorTheme(theme) {
                selectTheme(theme);
            }
            
            function resetSettings() {
                updateFontSize(22);
                selectTheme('default');
                showNotification('設定已重置為預設值');
            }
            
            function applySettings() {
                fontSettingsModal.style.display = 'none';
                showNotification('設定已套用');
            }
            
            async function loadSettingsFromStorage() {
                // Load font size
                try {
                    const savedFontSize = await loadFromIndexedDB('powernote-font-size');
                    if (savedFontSize) {
                        const size = parseInt(savedFontSize);
                        if (size >= 12 && size <= 32) {
                            // Update font size without triggering save during initialization
                            currentFontSize = size;
                            
                            // Update editor font size
                            const codeMirrorElement = document.querySelector('.CodeMirror');
                            if (codeMirrorElement) {
                                codeMirrorElement.style.fontSize = size + 'px';
                            }
                            
                            // Update preview font size
                            const previewElement = document.getElementById('preview');
                            if (previewElement) {
                                previewElement.style.fontSize = size + 'px';
                            }
                            
                            // Update UI elements
                            const currentFontSizeSpan = document.getElementById('current-font-size');
                            const fontSizeDisplay = document.getElementById('font-size-display');
                            const fontSizeSlider = document.getElementById('font-size-slider');
                            
                            if (currentFontSizeSpan) currentFontSizeSpan.textContent = size + 'px';
                            if (fontSizeDisplay) fontSizeDisplay.textContent = size + 'px';
                            if (fontSizeSlider) fontSizeSlider.value = size;
                            
                            console.log(`✅ Font size loaded: ${size}px`);
                        }
                    }
                } catch (e) {
                    console.warn('❌ Failed to load font size setting:', e);
                }
                
                // Load editor theme
                try {
                    const savedTheme = await loadFromIndexedDB('powernote-editor-theme');
                    if (savedTheme) {
                        // Set theme without triggering save during initialization
                        currentEditorTheme = savedTheme;
                        if (editor) {
                            editor.setOption('theme', savedTheme);
                        }
                        
                        // Update theme buttons
                        document.querySelectorAll('.theme-btn').forEach(btn => {
                            btn.classList.remove('active');
                            if (btn.dataset.theme === savedTheme) {
                                btn.classList.add('active');
                            }
                        });
                        
                        console.log(`✅ Theme loaded: ${savedTheme}`);
                    }
                } catch (e) {
                    console.warn('❌ Failed to load theme setting:', e);
                }
            }

            // --- Workspace Import/Export Functions ---
            function exportWorkspace() {
                try {
                    // Ensure NoteTask.md is up to date before export
                    updateNoteTaskFile();
                    
                    const workspace = {
                        version: '2.5.0',
                        exportDate: new Date().toISOString(),
                        files: files,
                        settings: {
                            currentFontSize: currentFontSize,
                            currentEditorTheme: currentEditorTheme,
                            autoTimerEnabled: autoTimerEnabled,
                            currentViewMode: currentViewMode
                        },
                        metadata: {
                            storageType: 'IndexedDB',
                            dbVersion: DB_VERSION,
                            exportedAt: new Date().getTime()
                        }
                    };

                    const dataStr = JSON.stringify(workspace, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
                    const filename = `PowerNote-Workspace-${timestamp}.json`;
                    
                    downloadBlob(dataBlob, filename);
                    showNotification(`工作區已成功匯出為 ${filename}`);
                } catch (error) {
                    console.error('Workspace export error:', error);
                    showNotification('匯出工作區時發生錯誤：' + error.message);
                }
            }

            // 顯示匯入模式選擇對話框
            function showImportModeDialog(workspace, timerDays, event) {
                const message = 
                    `匯入工作區資訊：\n\n` +
                    `版本：${workspace.version}\n` +
                    `匯出日期：${workspace.exportDate ? new Date(workspace.exportDate).toLocaleString() : '未知'}\n` +
                    `檔案數量：${workspace.files.length}\n` +
                    `時間記錄：${timerDays} 天\n\n` +
                    `請選擇匯入模式：\n\n` +
                    `[確定] - 合併模式：更新相同ID的筆記，新增不存在的筆記，保留UNSYNC筆記\n` +
                    `[取消] - 取消匯入\n\n` +
                    `⚠️ 要使用覆蓋模式（完全替換所有資料），請按住 Shift 鍵再點選確定`;
                
                // 檢查是否按住 Shift 鍵
                const isShiftPressed = event && event.shiftKey;
                
                if (isShiftPressed) {
                    const overwriteConfirm = confirm(
                        `⚠️ 覆蓋模式警告 ⚠️\n\n` +
                        `這將完全覆蓋現有的所有資料，包括UNSYNC筆記！\n\n` +
                        `確定要繼續嗎？`
                    );
                    return overwriteConfirm ? 'overwrite' : null;
                } else {
                    const confirmed = confirm(message);
                    return confirmed ? 'merge' : null;
                }
            }

            function handleWorkspaceImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.name.endsWith('.json')) {
                    showNotification('請選擇 JSON 格式的工作區檔案');
                    return;
                }

                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const workspace = JSON.parse(e.target.result);
                        
                        // Validate workspace structure
                        if (!workspace.version || !workspace.files) {
                            throw new Error('無效的工作區檔案格式');
                        }

                        // Count timer records from NoteTask.md if available
                        const noteTaskFile = workspace.files.find(f => f.name === 'NoteTask.md');
                        let timerDays = 0;
                        if (noteTaskFile && noteTaskFile.content) {
                            const matches = noteTaskFile.content.match(/^## \d{4}-\d{2}-\d{2}/gm);
                            timerDays = matches ? matches.length : 0;
                        } else if (workspace.timerHistory) {
                            timerDays = Object.keys(workspace.timerHistory).length;
                        }

                        // Show mode selection dialog
                        const dialogResult = showImportModeDialog(workspace, timerDays, event);
                        
                        if (dialogResult === null) {
                            workspaceInput.value = ''; // Clear file input
                            return;
                        }
                        
                        const mergeMode = dialogResult === 'merge';

                        // Import files using syncManager's importWorkspace method
                        if (dialogResult === 'overwrite') {
                            // 覆蓋模式：使用原有邏輯
                            if (workspace.files && Array.isArray(workspace.files)) {
                                files = workspace.files.map(file => ({
                                    ...file,
                                    lastModified: file.lastModified || Date.now()
                                }));
                            }
                        } else {
                            // 合併模式：使用syncManager的新邏輯
                            await syncManager.importWorkspace(workspace, mergeMode);
                        }

                        // Import timer history (for backward compatibility and migration)
                        if (workspace.timerHistory) {
                            timerHistory = workspace.timerHistory;
                            // Update NoteTask.md with imported timer history
                            updateNoteTaskFile();
                        } else {
                            // Load timer history from NoteTask.md if present
                            loadTimerHistoryFromNoteTask();
                        }

                        // Import settings
                        if (workspace.settings) {
                            const settings = workspace.settings;
                            
                            if (settings.currentFontSize) {
                                updateFontSize(settings.currentFontSize);
                            }
                            
                            if (settings.currentEditorTheme) {
                                selectTheme(settings.currentEditorTheme);
                            }
                            
                            if (typeof settings.autoTimerEnabled === 'boolean') {
                                autoTimerEnabled = settings.autoTimerEnabled;
                            }
                            
                            if (settings.currentViewMode) {
                                setViewMode(settings.currentViewMode);
                            }
                        }

                        // For backward compatibility, handle old localStorage-based exports
                        if (workspace.localStorage) {
                            console.log('Importing legacy localStorage-based workspace');
                            // Migrate legacy data to IndexedDB format
                            const legacyMigrations = [
                                { old: 'powernote_files', new: 'powernote_files' },
                                { old: 'powernote_tasks', new: 'powernote_tasks' },
                                { old: 'powernote-font-size', new: 'powernote-font-size' },
                                { old: 'powernote-editor-theme', new: 'powernote-editor-theme' }
                            ];
                            
                            for (const migration of legacyMigrations) {
                                const value = workspace.localStorage[migration.old];
                                if (value !== null && value !== undefined) {
                                    try {
                                        const parsedValue = JSON.parse(value);
                                        await saveToIndexedDB(migration.new, parsedValue);
                                    } catch (e) {
                                        console.warn(`Failed to migrate ${migration.old}:`, e);
                                    }
                                }
                            }
                        }

                        // Save imported data to storage
                        await saveDataToStorage();
                        
                        // Refresh UI
                        renderFileList();
                        
                        // Load first file if available
                        if (files.length > 0) {
                            loadFile(files[0].id);
                        } else {
                            editor.setValue(getWelcomeMessage());
                            currentFile = null;
                            currentFileNameEl.textContent = '新筆記';
                        }

                        showNotification(`工作區匯入成功！共匯入 ${files.length} 個檔案和相關設定。`);
                        
                    } catch (error) {
                        console.error('Workspace import error:', error);
                        showNotification('匯入工作區時發生錯誤：' + error.message);
                    }
                    
                    // Clear file input
                    workspaceInput.value = '';
                };
                
                reader.onerror = function() {
                    showNotification('讀取檔案時發生錯誤');
                    workspaceInput.value = '';
                };
                
                reader.readAsText(file);
            }
            
            // Markdown formatting toggle function
            function toggleMarkdownFormat(startMarker, endMarker, defaultText) {
                if (!editor) return;
                
                const selections = editor.listSelections();
                const doc = editor.getDoc();
                
                // Process each selection
                selections.forEach(selection => {
                    const { anchor, head } = selection;
                    const start = anchor.line < head.line || (anchor.line === head.line && anchor.ch <= head.ch) ? anchor : head;
                    const end = anchor.line > head.line || (anchor.line === head.line && anchor.ch > head.ch) ? anchor : head;
                    
                    const selectedText = doc.getRange(start, end);
                    
                    // Check if text is already formatted
                    const isFormatted = selectedText.startsWith(startMarker) && selectedText.endsWith(endMarker);
                    
                    let newText;
                    let newCursorPos;
                    
                    if (isFormatted) {
                        // Remove formatting
                        newText = selectedText.slice(startMarker.length, -endMarker.length);
                        newCursorPos = {
                            anchor: start,
                            head: { line: end.line, ch: end.ch - startMarker.length - endMarker.length }
                        };
                    } else {
                        // Add formatting
                        if (selectedText.length === 0) {
                            // No selection, insert default text with markers
                            newText = startMarker + defaultText + endMarker;
                            // Select the default text
                            newCursorPos = {
                                anchor: { line: start.line, ch: start.ch + startMarker.length },
                                head: { line: start.line, ch: start.ch + startMarker.length + defaultText.length }
                            };
                        } else {
                            // Wrap selected text
                            newText = startMarker + selectedText + endMarker;
                            newCursorPos = {
                                anchor: start,
                                head: { line: end.line, ch: end.ch + startMarker.length + endMarker.length }
                            };
                        }
                    }
                    
                    // Replace text
                    doc.replaceRange(newText, start, end);
                    
                    // Update cursor position
                    if (selections.length === 1) {
                        doc.setSelection(newCursorPos.anchor, newCursorPos.head);
                    }
                });
                
                // Trigger update
                updatePreview();
            }
            
            // Toggle line prefix for headers, lists, quotes, etc.
            function toggleLinePrefix(prefix, defaultText) {
                if (!editor) return;
                
                const cursor = editor.getCursor();
                const line = cursor.line;
                const currentLine = editor.getLine(line);
                
                // Check if line already has this prefix
                if (currentLine.startsWith(prefix)) {
                    // Remove prefix
                    const newText = currentLine.substring(prefix.length);
                    editor.replaceRange(newText, { line: line, ch: 0 }, { line: line, ch: currentLine.length });
                    editor.setCursor({ line: line, ch: Math.max(0, cursor.ch - prefix.length) });
                } else {
                    // Check if line has any other header prefix and remove it
                    const headerMatch = currentLine.match(/^#+\s*/);
                    let baseText = currentLine;
                    let prefixOffset = 0;
                    
                    if (headerMatch) {
                        baseText = currentLine.substring(headerMatch[0].length);
                        prefixOffset = headerMatch[0].length;
                    }
                    
                    // Add new prefix
                    let newText;
                    if (baseText.trim() === '') {
                        newText = prefix + defaultText;
                    } else {
                        newText = prefix + baseText;
                    }
                    
                    editor.replaceRange(newText, { line: line, ch: 0 }, { line: line, ch: currentLine.length });
                    
                    // Position cursor appropriately
                    if (baseText.trim() === '') {
                        // Select the default text
                        editor.setSelection(
                            { line: line, ch: prefix.length },
                            { line: line, ch: prefix.length + defaultText.length }
                        );
                    } else {
                        // Maintain relative cursor position
                        const newCursorPos = Math.max(prefix.length, cursor.ch - prefixOffset + prefix.length);
                        editor.setCursor({ line: line, ch: newCursorPos });
                    }
                }
                
                updatePreview();
            }
            
            // Auto list continuation functionality
            function handleAutoListContinuation(editor, e) {
                const cursor = editor.getCursor();
                const currentLine = editor.getLine(cursor.line);
                
                // Check for different list patterns, more specific ones first
                const patterns = [
                    { regex: /^(\s*)(-\s*\[\s*\])(\s+)(.*)$/, type: 'todo_empty' },
                    { regex: /^(\s*)(-\s*\[x\])(\s+)(.*)$/, type: 'todo_checked' },
                    { regex: /^(\s*)([-*+])(\s+)(.*)$/, type: 'bullet' },
                    { regex: /^(\s*)(\d+)(\.\s+)(.*)$/, type: 'number' },
                    { regex: /^(\s*)(>)(\s+)(.*)$/, type: 'quote' }
                ];
                
                for (const pattern of patterns) {
                    const match = currentLine.match(pattern.regex);
                    if (match) {
                        const [, indent, marker, separator, content] = match;
                        
                        // If the line has no content (just marker), remove the marker
                        if (!content || content.trim() === '') {
                            e.preventDefault();
                            // Remove the current list marker and create a plain new line
                            editor.replaceRange('\n', 
                                { line: cursor.line, ch: 0 }, 
                                { line: cursor.line, ch: currentLine.length }
                            );
                            editor.setCursor({ line: cursor.line, ch: 0 });
                            return true;
                        }
                        
                        // Continue the list pattern on the next line
                        e.preventDefault();
                        let newMarker = '';
                        
                        switch (pattern.type) {
                            case 'todo_empty':
                            case 'todo_checked':
                                newMarker = `${indent}- [ ] `;
                                break;
                            case 'bullet':
                                newMarker = `${indent}${marker}${separator}`;
                                break;
                            case 'number':
                                const num = parseInt(marker) + 1;
                                newMarker = `${indent}${num}${separator}`;
                                break;
                            case 'quote':
                                newMarker = `${indent}${marker}${separator}`;
                                break;
                        }
                        
                        editor.replaceRange(`\n${newMarker}`, cursor);
                        editor.setCursor({ 
                            line: cursor.line + 1, 
                            ch: newMarker.length 
                        });
                        return true;
                    }
                }
                
                return false;
            }

            // --- Excalidraw Integration ---
            let excalidrawAPI = null;
            let excalidrawContainer = null;

            function initDrawingCanvas() {
                if (!excalidrawContainer) {
                    excalidrawContainer = document.getElementById('excalidraw-container');
                    
                    // Initialize Excalidraw with proper callback handling
                    const excalidrawElement = React.createElement(
                        ExcalidrawLib.Excalidraw,
                        {
                            onChange: (elements, appState, files) => {
                                // Store current state for access by buttons
                                window.currentExcalidrawElements = elements;
                                window.currentExcalidrawAppState = appState;
                                window.currentExcalidrawFiles = files;
                            },
                            initialData: {
                                elements: [],
                                appState: {
                                    viewBackgroundColor: '#ffffff'
                                }
                            }
                        }
                    );
                    
                    ReactDOM.render(excalidrawElement, excalidrawContainer);
                    
                    // Initialize global state
                    window.currentExcalidrawElements = [];
                    window.currentExcalidrawAppState = { viewBackgroundColor: '#ffffff' };
                    window.currentExcalidrawFiles = {};
                    
                    // Setup event listeners after a small delay to ensure Excalidraw is initialized
                    setTimeout(() => {
                        setupDrawingEventListeners();
                    }, 100);
                }
            }

            function setupDrawingEventListeners() {
                // Remove existing listeners to prevent duplicates
                const saveBtn = document.getElementById('save-drawing-btn');
                const exportBtn = document.getElementById('export-drawing-btn');
                const mermaidBtn = document.getElementById('generate-mermaid-btn');
                
                if (saveBtn) {
                    saveBtn.replaceWith(saveBtn.cloneNode(true));
                    document.getElementById('save-drawing-btn').addEventListener('click', saveDrawingToEditor);
                }
                if (exportBtn) {
                    exportBtn.replaceWith(exportBtn.cloneNode(true));
                    document.getElementById('export-drawing-btn').addEventListener('click', exportDrawingAsPNG);
                }
                if (mermaidBtn) {
                    mermaidBtn.replaceWith(mermaidBtn.cloneNode(true));
                    document.getElementById('generate-mermaid-btn').addEventListener('click', generateMermaidFromDrawing);
                }
            }

            // Excalidraw Integration Functions
            function saveDrawingToEditor() {
                console.log('saveDrawingToEditor called');
                
                try {
                    const elements = window.currentExcalidrawElements || [];
                    const appState = window.currentExcalidrawAppState || { viewBackgroundColor: '#ffffff' };
                    const files = window.currentExcalidrawFiles || {};
                    
                    if (elements.length === 0) {
                        return;
                    }
                    
                    console.log('Exporting with elements:', elements.length);
                    
                    // Export as image using ExcalidrawLib
                    ExcalidrawLib.exportToBlob({
                        elements: elements,
                        appState: appState,
                        files: files,
                        mimeType: 'image/png',
                        quality: 1.0
                    }).then(blob => {
                        console.log('Blob created:', blob);
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const base64Data = e.target.result;
                            const imageMarkdown = `![Excalidraw繪圖](${base64Data})\n\n`;
                            
                            // Insert at cursor position
                            const cursor = editor.getCursor();
                            editor.replaceRange(imageMarkdown, cursor);
                            
                            // 繪圖已保存到編輯器
                        };
                        reader.readAsDataURL(blob);
                    }).catch(error => {
                        console.error('Export error:', error);
                        console.error('保存失敗:', error.message);
                    });
                } catch (error) {
                    console.error('saveDrawingToEditor error:', error);
                    showNotification('保存失敗: ' + error.message);
                }
            }

            function exportDrawingAsPNG() {
                console.log('exportDrawingAsPNG called');
                
                try {
                    const elements = window.currentExcalidrawElements || [];
                    const appState = window.currentExcalidrawAppState || { viewBackgroundColor: '#ffffff' };
                    const files = window.currentExcalidrawFiles || {};
                    
                    if (elements.length === 0) {
                        showNotification('沒有內容可以匯出');
                        return;
                    }
                    
                    ExcalidrawLib.exportToBlob({
                        elements: elements,
                        appState: appState,
                        files: files,
                        mimeType: 'image/png',
                        quality: 1.0
                    }).then(blob => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = 'excalidraw-drawing.png';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        showNotification('圖片已下載');
                    }).catch(error => {
                        console.error('Export error:', error);
                        showNotification('匯出失敗: ' + error.message);
                    });
                } catch (error) {
                    console.error('exportDrawingAsPNG error:', error);
                    showNotification('匯出失敗: ' + error.message);
                }
            }


            function generateMermaidFromDrawing() {
                console.log('generateMermaidFromDrawing called');
                
                try {
                    const elements = window.currentExcalidrawElements || [];
                    
                    if (elements.length === 0) {
                        return;
                    }
                    
                    console.log('Analyzing elements:', elements);
                    
                    let mermaidCode = '';
                    
                    // Analyze elements to generate appropriate Mermaid diagram
                    const textElements = elements.filter(el => el.type === 'text');
                    const rectangles = elements.filter(el => el.type === 'rectangle');
                    const arrows = elements.filter(el => el.type === 'arrow');
                    const ellipses = elements.filter(el => el.type === 'ellipse');
                    
                    console.log('Found elements:', {
                        text: textElements.length,
                        rectangles: rectangles.length,
                        arrows: arrows.length,
                        ellipses: ellipses.length
                    });
                    
                    if (textElements.length > 0 && (rectangles.length > 0 || ellipses.length > 0)) {
                        // Generate flowchart
                        mermaidCode = 'flowchart TD\n';
                        
                        textElements.forEach((textEl, index) => {
                            const nodeId = `node${index}`;
                            const text = (textEl.text || `節點${index}`).replace(/[^\w\s\u4e00-\u9fff]/g, '');
                            
                            // Find associated shape
                            const associatedRect = rectangles.find(rect => 
                                Math.abs(rect.x - textEl.x) < 100 && Math.abs(rect.y - textEl.y) < 100
                            );
                            const associatedEllipse = ellipses.find(ellipse => 
                                Math.abs(ellipse.x - textEl.x) < 100 && Math.abs(ellipse.y - textEl.y) < 100
                            );
                            
                            if (associatedEllipse) {
                                mermaidCode += `    ${nodeId}((${text}))\n`;
                            } else {
                                mermaidCode += `    ${nodeId}[${text}]\n`;
                            }
                        });
                        
                        // Add simple connections
                        for (let i = 0; i < textElements.length - 1; i++) {
                            mermaidCode += `    node${i} --> node${i + 1}\n`;
                        }
                    } else if (textElements.length > 0) {
                        // Generate simple mind map
                        mermaidCode = 'mindmap\n  root((主題))\n';
                        textElements.forEach((textEl, index) => {
                            const text = (textEl.text || `節點${index}`).replace(/[^\w\s\u4e00-\u9fff]/g, '');
                            mermaidCode += `    ${text}\n`;
                        });
                    } else {
                        // Generate simple diagram based on shapes
                        mermaidCode = 'flowchart TD\n';
                        
                        rectangles.forEach((rect, index) => {
                            mermaidCode += `    rect${index}[矩形${index}]\n`;
                        });
                        
                        ellipses.forEach((ellipse, index) => {
                            mermaidCode += `    ellipse${index}((圓形${index}))\n`;
                        });
                        
                        // Add simple connections
                        const totalShapes = rectangles.length + ellipses.length;
                        for (let i = 0; i < totalShapes - 1; i++) {
                            const from = i < rectangles.length ? `rect${i}` : `ellipse${i - rectangles.length}`;
                            const to = (i + 1) < rectangles.length ? `rect${i + 1}` : `ellipse${(i + 1) - rectangles.length}`;
                            mermaidCode += `    ${from} --> ${to}\n`;
                        }
                    }
                    
                    if (mermaidCode) {
                        const cursor = editor.getCursor();
                        editor.replaceRange(`\`\`\`mermaid\n${mermaidCode}\`\`\`\n\n`, cursor);
                        // Mermaid 代碼已生成到編輯器
                    } else {
                        // 無法生成 Mermaid 代碼
                    }
                } catch (error) {
                    console.error('generateMermaidFromDrawing error:', error);
                    showNotification('生成失敗: ' + error.message);
                }
            }

            // --- Panel Resizing Functions ---
            let isResizing = false;
            let startX = 0;
            let startEditorWidth = 0;
            let containerWidth = 0;

            function setupPanelResizer() {
                const divider = document.getElementById('panel-divider');
                const editorPanel = document.getElementById('editor-panel');
                const drawingPanel = document.getElementById('drawing-panel');
                const mainContent = document.querySelector('.main-editor-content');
                
                if (!divider || !editorPanel || !drawingPanel || !mainContent) return;
                
                // Load saved panel ratio
                const savedRatio = localStorage.getItem('powernote-panel-ratio');
                if (savedRatio) {
                    const ratio = parseFloat(savedRatio);
                    if (ratio > 0.1 && ratio < 0.9) {
                        editorPanel.style.flex = `0 0 ${ratio * 100}%`;
                        drawingPanel.style.flex = '1';
                    }
                }
                
                divider.addEventListener('mousedown', startResizing);
            }

            function startResizing(e) {
                isResizing = true;
                startX = e.clientX;
                
                const editorPanel = document.getElementById('editor-panel');
                const mainContent = document.querySelector('.main-editor-content');
                const divider = document.getElementById('panel-divider');
                
                if (!editorPanel || !mainContent || !divider) return;
                
                startEditorWidth = editorPanel.offsetWidth;
                containerWidth = mainContent.offsetWidth - divider.offsetWidth;
                
                divider.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                
                document.addEventListener('mousemove', handleResizing);
                document.addEventListener('mouseup', stopResizing);
                
                e.preventDefault();
            }

            function handleResizing(e) {
                if (!isResizing) return;
                
                const deltaX = e.clientX - startX;
                const newEditorWidth = startEditorWidth + deltaX;
                const minWidth = 200;
                const maxWidth = containerWidth - minWidth;
                
                // Constrain the width
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newEditorWidth));
                const ratio = constrainedWidth / containerWidth;
                
                const editorPanel = document.getElementById('editor-panel');
                const drawingPanel = document.getElementById('drawing-panel');
                
                if (editorPanel && drawingPanel) {
                    editorPanel.style.flex = `0 0 ${ratio * 100}%`;
                    drawingPanel.style.flex = '1';
                    
                    // Refresh editor layout
                    setTimeout(() => {
                        if (editor) editor.refresh();
                    }, 10);
                }
            }

            function stopResizing() {
                if (!isResizing) return;
                
                isResizing = false;
                
                const divider = document.getElementById('panel-divider');
                const editorPanel = document.getElementById('editor-panel');
                
                if (divider) divider.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                
                // Save the panel ratio
                if (editorPanel) {
                    const ratio = editorPanel.offsetWidth / containerWidth;
                    localStorage.setItem('powernote-panel-ratio', ratio.toString());
                }
                
                document.removeEventListener('mousemove', handleResizing);
                document.removeEventListener('mouseup', stopResizing);
                
                // Final editor refresh
                setTimeout(() => {
                    if (editor) editor.refresh();
                }, 100);
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                if (currentViewMode === 'drawing') {
                    setTimeout(() => {
                        if (editor) editor.refresh();
                    }, 100);
                }
            });

            // Cloud Sync Functions
            async function handleSyncToCloud() {
                try {
                    // Check if settings are configured
                    if (!syncSettings.github.token) {
                        showNotification('請先設定 GitHub Token');
                        openSyncSettings();
                        return;
                    }
                    
                    // Calculate how many files will be synced
                    const unsyncFiles = files.filter(file => 
                        syncManager.hasUnsyncTag(file, files)
                    );
                    const syncFiles = files.filter(file => 
                        !syncManager.hasUnsyncTag(file, files)
                    );
                    const totalFiles = files.length;
                    
                    // 統計檔案類型
                    const systemFiles = files.filter(file => syncManager.isSystemFile(file));
                    const normalFiles = files.filter(file => 
                        !syncManager.isSystemFile(file) && !syncManager.hasUnsyncTag(file, files)
                    );
                    
                    showNotification(`正在同步到雲端...\n• 系統檔案: ${systemFiles.length} 個\n• 一般檔案: ${normalFiles.length} 個\n• 跳過檔案: ${unsyncFiles.length} 個 (#UNSYNC)`, 'info');
                    const result = await syncManager.syncToGist();
                    showNotification(`同步成功！已同步 ${syncFiles.length} 個檔案到 Gist ID: ${result.id}`);
                    console.log('Sync successful:', result);
                } catch (error) {
                    console.error('Sync to cloud error:', error);
                    showNotification('同步失敗: ' + error.message);
                }
            }

            async function handleLoadFromCloud() {
                try {
                    // Check if settings are configured
                    if (!syncSettings.github.token) {
                        showNotification('請先設定 GitHub Token');
                        openSyncSettings();
                        return;
                    }
                    
                    // 直接顯示版本歷史，讓用戶選擇
                    showVersionHistoryModal();
                } catch (error) {
                    console.error('Load from cloud error:', error);
                    showNotification('載入失敗: ' + error.message);
                }
            }

            // 處理發布分享頁面
            async function handlePublishShared() {
                try {
                    // 檢查是否設定了 GitHub Token
                    if (!syncSettings.github.token) {
                        showNotification('請先設定 GitHub Token');
                        openSyncSettings();
                        return;
                    }
                    
                    const shareableFiles = syncManager.getShareableFiles();
                    
                    if (shareableFiles.length === 0) {
                        showNotification('沒有找到含有 #SHARE 標籤的檔案', 'error');
                        return;
                    }
                    
                    showNotification(`正在創建公開分享 Gist... (${shareableFiles.length} 個檔案)`, 'info');
                    
                    // 創建公開 Gist
                    const gist = await syncManager.createPublicShareGist();
                    
                    // 生成分享連結
                    const shareLinks = syncManager.generateShareLinks(gist.id, shareableFiles);
                    
                    // 顯示分享連結
                    displayShareLinks(shareLinks, gist.id);
                    
                    showNotification(`✅ 成功創建分享 Gist！已生成 ${shareLinks.length} 個分享連結`);
                    console.log('Share links generated:', shareLinks);
                    
                } catch (error) {
                    console.error('Publish shared error:', error);
                    showNotification('發布失敗: ' + error.message, 'error');
                }
            }
            
            // 顯示分享連結的彈出視窗
            function displayShareLinks(shareLinks, gistId) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.style.zIndex = '10000';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.style.maxWidth = '600px';
                modalContent.style.maxHeight = '80vh';
                modalContent.style.overflow = 'auto';
                
                let linksHtml = shareLinks.map(link => `
                    <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db;">
                        <h4 style="margin: 0 0 10px 0; color: #2c3e50;">${link.title}</h4>
                        <p style="margin: 5px 0; color: #666; font-size: 14px;">檔案: ${link.fileName}</p>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <input type="text" value="${link.url}" readonly 
                                   style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                            <button onclick="copyToClipboard('${link.url}')" 
                                    style="padding: 8px 15px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                複製
                            </button>
                        </div>
                    </div>
                `).join('');
                
                modalContent.innerHTML = `
                    <span class="close-btn" onclick="this.closest('.modal').remove()" style="float: right; font-size: 28px; cursor: pointer;">&times;</span>
                    <h2 style="color: #2c3e50; margin-bottom: 20px;">🎉 分享連結已生成</h2>
                    
                    <div style="background: #e8f6f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <p style="margin: 0; color: #27ae60;"><strong>公開 Gist ID:</strong> ${gistId}</p>
                        <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">
                            朋友點擊連結即可直接閱讀文章，無需 PowerNote 帳號
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #2c3e50;">分享連結:</h3>
                        ${linksHtml}
                    </div>
                    
                    <div style="text-align: center; padding-top: 20px; border-top: 1px solid #eee;">
                        <button onclick="copyAllLinks()" style="padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                            複製所有連結
                        </button>
                        <button onclick="this.closest('.modal').remove()" style="padding: 10px 20px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            關閉
                        </button>
                    </div>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // 添加全域函數
                window.copyToClipboard = async function(text) {
                    try {
                        await navigator.clipboard.writeText(text);
                        showNotification('連結已複製到剪貼簿');
                    } catch (error) {
                        console.error('複製失敗:', error);
                        showNotification('複製失敗，請手動複製');
                    }
                };
                
                window.copyAllLinks = async function() {
                    const allLinks = shareLinks.map(link => `${link.title}: ${link.url}`).join('\n\n');
                    try {
                        await navigator.clipboard.writeText(allLinks);
                        showNotification('所有連結已複製到剪貼簿');
                    } catch (error) {
                        console.error('複製失敗:', error);
                        showNotification('複製失敗，請手動複製');
                    }
                };
            }
            
            // 下載檔案的輔助函數
            function downloadFile(content, filename, mimeType = 'text/plain') {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function openSyncSettings() {
                syncSettingsModal.style.display = 'block';
                populateSyncSettings();
            }

            function switchSyncTab(provider) {
                // Update tab buttons
                document.getElementById('github-tab-btn').classList.remove('active');
                document.getElementById('webdav-tab-btn').classList.remove('active');
                document.getElementById(`${provider}-tab-btn`).classList.add('active');
                
                // Show/hide settings panels
                document.getElementById('github-settings').style.display = provider === 'github' ? 'block' : 'none';
                document.getElementById('webdav-settings').style.display = provider === 'webdav' ? 'block' : 'none';
                
                syncSettings.provider = provider;
            }

            function populateSyncSettings() {
                // GitHub settings
                document.getElementById('github-token').value = syncSettings.github.token || '';
                document.getElementById('gist-id').value = syncSettings.github.gistId || '';
                document.getElementById('auto-sync').checked = syncSettings.github.autoSync || false;
                
                // WebDAV settings
                document.getElementById('webdav-url').value = syncSettings.webdav.url || '';
                document.getElementById('webdav-username').value = syncSettings.webdav.username || '';
                document.getElementById('webdav-password').value = syncSettings.webdav.password || '';
                
                // Set active tab
                switchSyncTab(syncSettings.provider);
            }

            async function testSyncConnection() {
                try {
                    showSyncStatus('正在測試連接...', 'info');
                    
                    if (syncSettings.provider === 'github') {
                        syncSettings.github.token = document.getElementById('github-token').value;
                        const user = await syncManager.testConnection();
                        showSyncStatus(`連接成功！歡迎 ${user.login}`, 'success');
                    } else {
                        showSyncStatus('WebDAV 測試功能開發中...', 'info');
                    }
                } catch (error) {
                    console.error('Test connection error:', error);
                    showSyncStatus(`連接失敗: ${error.message}`, 'error');
                }
            }

            async function saveSyncSettings() {
                try {
                    // Save GitHub settings
                    syncSettings.github.token = document.getElementById('github-token').value;
                    syncSettings.github.gistId = document.getElementById('gist-id').value;
                    syncSettings.github.autoSync = document.getElementById('auto-sync').checked;
                    
                    // Save WebDAV settings
                    syncSettings.webdav.url = document.getElementById('webdav-url').value;
                    syncSettings.webdav.username = document.getElementById('webdav-username').value;
                    syncSettings.webdav.password = document.getElementById('webdav-password').value;
                    
                    await syncManager.saveSyncSettings();
                    showSyncStatus('設定已儲存', 'success');
                    setTimeout(() => {
                        syncSettingsModal.style.display = 'none';
                    }, 1500);
                } catch (error) {
                    console.error('Save sync settings error:', error);
                    showSyncStatus(`儲存失敗: ${error.message}`, 'error');
                }
            }

            function showSyncStatus(message, type) {
                const statusEl = document.getElementById('sync-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.className = `sync-status ${type}`;
                    statusEl.style.display = 'block';
                }
            }

            async function showVersionHistoryModal() {
                try {
                    versionHistoryModal.style.display = 'block';
                    await refreshVersionHistory();
                } catch (error) {
                    console.error('Show version history error:', error);
                    showNotification('無法載入版本歷史: ' + error.message);
                }
            }

            async function quickLoadLatestVersion() {
                try {
                    // 詢問是否要合併模式載入最新版本
                    const useMergeMode = confirm(
                        '選擇載入模式：\n\n' +
                        '[確定] - 合併模式：保留UNSYNC筆記，更新其他筆記\n' +
                        '[取消] - 覆蓋模式：完全替換所有筆記\n\n' +
                        '推薦使用合併模式以保護本地未同步的筆記。'
                    );
                    
                    showNotification('正在從雲端載入最新版本...');
                    const result = await syncManager.loadFromGist(null, null, useMergeMode);
                    showNotification(`最新版本載入成功（${useMergeMode ? '合併' : '覆蓋'}模式）`);
                    versionHistoryModal.style.display = 'none';
                    
                    // 刷新UI
                    renderFileList();
                    if (files.length > 0 && !currentFile) {
                        loadFile(files[0].id);
                    }
                } catch (error) {
                    console.error('Quick load latest version error:', error);
                    showNotification('載入最新版本失敗: ' + error.message);
                }
            }

            async function refreshVersionHistory() {
                const versionList = document.getElementById('version-list');
                
                try {
                    versionList.innerHTML = '<div style="text-align: center; padding: 20px;">載入中...</div>';
                    
                    // Check if we have the necessary settings
                    if (!syncSettings.github.token) {
                        versionList.innerHTML = '<div style="text-align: center; padding: 20px;">請先設定 GitHub Token</div>';
                        return;
                    }
                    
                    if (!syncSettings.github.gistId) {
                        versionList.innerHTML = '<div style="text-align: center; padding: 20px;">尚未同步到雲端，請先進行同步</div>';
                        return;
                    }
                    
                    const history = await syncManager.getVersionHistory();
                    
                    if (history.length === 0) {
                        versionList.innerHTML = '<div style="text-align: center; padding: 20px;">沒有版本歷史</div>';
                        return;
                    }
                    
                    versionList.innerHTML = '';
                    history.forEach((version, index) => {
                        const versionEl = document.createElement('div');
                        versionEl.className = 'version-item';
                        versionEl.innerHTML = `
                            <div class="version-header">
                                <span class="version-date">${new Date(version.committed_at).toLocaleString()}</span>
                                <span class="version-size">SHA: ${version.version.substring(0, 7)}</span>
                            </div>
                            <div class="version-description">${version.change_status ? `變更: ${Object.keys(version.change_status).join(', ')}` : '版本 ' + (index + 1)}</div>
                            <div class="version-actions-inline">
                                <button class="version-btn" onclick="loadVersion('${version.version}')">載入此版本</button>
                                <button class="version-btn" onclick="downloadVersion('${version.version}')">下載</button>
                            </div>
                        `;
                        versionList.appendChild(versionEl);
                    });
                } catch (error) {
                    versionList.innerHTML = `<div style="text-align: center; padding: 20px; color: red;">載入失敗: ${error.message}</div>`;
                    console.error('Refresh version history error:', error);
                }
            }

            // Make functions global for onclick handlers
            window.loadVersion = async function(version) {
                try {
                    // 詢問是否要合併模式載入版本
                    const useMergeMode = confirm(
                        '選擇版本載入模式：\n\n' +
                        '[確定] - 合併模式：保留UNSYNC筆記，更新其他筆記\n' +
                        '[取消] - 覆蓋模式：完全替換所有筆記\n\n' +
                        '推薦使用合併模式以保護本地未同步的筆記。'
                    );
                    
                    const result = await syncManager.loadFromGist(null, version, useMergeMode);
                    showNotification(`版本載入成功（${useMergeMode ? '合併' : '覆蓋'}模式）`);
                    versionHistoryModal.style.display = 'none';
                    
                    // 刷新UI
                    renderFileList();
                    if (files.length > 0 && !currentFile) {
                        loadFile(files[0].id);
                    }
                } catch (error) {
                    console.error('Load version error:', error);
                    showNotification('載入版本失敗: ' + error.message);
                }
            }

            window.downloadVersion = async function(version) {
                try {
                    // This would download the specific version
                    showNotification('下載功能開發中...');
                } catch (error) {
                    console.error('Download version error:', error);
                    showNotification('下載失敗: ' + error.message);
                }
            }

            async function createBackup() {
                try {
                    const result = await syncManager.syncToGist();
                    showNotification('備份建立成功');
                    await refreshVersionHistory();
                } catch (error) {
                    console.error('Create backup error:', error);
                    showNotification('建立備份失敗: ' + error.message);
                }
            }

            // URL Parameter Sharing Functions
            function checkUrlParameters() {
                const urlParams = new URLSearchParams(window.location.search);
                const fileName = urlParams.get('file');
                const viewMode = urlParams.get('view');
                
                if (fileName) {
                    console.log('URL parameter detected - file:', fileName);
                    setTimeout(() => {
                        loadFileFromUrl(fileName, viewMode);
                    }, 1000); // Delay to ensure files are loaded
                }
            }
            
            function loadFileFromUrl(fileName, viewMode = 'preview') {
                // Try to find file by exact name first
                let targetFile = files.find(f => f.name === fileName);
                
                // If not found, try partial match
                if (!targetFile) {
                    targetFile = files.find(f => f.name.includes(fileName) || fileName.includes(f.name.replace('.md', '')));
                }
                
                if (targetFile) {
                    currentFile = targetFile;
                    loadFile(targetFile);
                    
                    // Set view mode based on parameter
                    if (viewMode === 'preview') {
                        setViewMode('preview-only');
                    } else if (viewMode === 'edit') {
                        setViewMode('edit-only');
                    } else {
                        setViewMode('split');
                    }
                    
                    showNotification(`已載入分享檔案: ${targetFile.name}`);
                    console.log('File loaded from URL:', targetFile.name);
                } else {
                    showNotification(`找不到檔案: ${fileName}`, 'error');
                    console.log('File not found:', fileName);
                }
            }
            
            // Smart hashtag extraction (only from regular paragraphs)
            function extractValidHashtags(content) {
                if (!content) return new Set();
                
                const lines = content.split('\n');
                const validHashtags = new Set();
                let inCodeBlock = false;
                
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    
                    // Handle code blocks
                    if (trimmedLine.startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        continue;
                    }
                    if (inCodeBlock) continue;
                    
                    // Skip headers, lists, blockquotes, and other special syntax
                    if (trimmedLine.match(/^#{1,6}\s/) ||           // Headers
                        trimmedLine.match(/^\s*[-*+]\s/) ||        // Unordered lists
                        trimmedLine.match(/^\s*\d+\.\s/) ||        // Ordered lists
                        trimmedLine.match(/^\s*>\s/) ||            // Blockquotes
                        trimmedLine.match(/^\|.*\|/) ||            // Tables
                        trimmedLine.match(/^---+$/) ||             // Horizontal rules
                        trimmedLine.startsWith('    ') ||          // Code indentation
                        trimmedLine.startsWith('\t')) {            // Code tabs
                        continue;
                    }
                    
                    // Extract hashtags from regular paragraphs only
                    // Hashtag must be preceded by start of line or space, and followed by space, newline, or end of line
                    const hashtagPattern = /(?:^|\s)(#[^\s#]+)(?=\s|$)/g;
                    let match;
                    
                    while ((match = hashtagPattern.exec(line)) !== null) {
                        const fullHashtag = match[1]; // includes the #
                        const cleanTag = fullHashtag.substring(1); // remove the #
                        
                        if (cleanTag.length > 0) {
                            validHashtags.add(cleanTag);
                        }
                    }
                }
                
                return validHashtags;
            }

            // Test hashtag extraction with sample text (for debugging)
            function testHashtagExtraction() {
                const testCases = [
                    "#hash1 #hash2",           // ✅ Valid: at start and after space
                    "   #hash001   #hash002",  // ✅ Valid: with extra spaces
                    "text#invalid",            // ❌ Invalid: no space before
                    "#valid followed by text", // ❌ Invalid: no space after
                    "#valid #also_valid",      // ✅ Valid: both valid
                    "Check this #demo test",   // ✅ Valid: space before and after
                    "- #invalid_in_list",      // ❌ Invalid: in list
                    "# #invalid_in_header",    // ❌ Invalid: in header
                ];
                
                console.log("🧪 Testing hashtag extraction:");
                testCases.forEach((testCase, i) => {
                    const result = extractValidHashtags(testCase);
                    console.log(`${i + 1}. "${testCase}" → [${Array.from(result).join(', ')}]`);
                });
            }

            // Get hashtags that exist in NoteTag.md
            function getExistingNoteTagHashtags() {
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) return new Set();
                
                const existingHashtags = new Set();
                const headerRegex = /^### (.+)$/gm;
                let match;
                
                while ((match = headerRegex.exec(noteTagFile.content)) !== null) {
                    existingHashtags.add(match[1].trim());
                }
                
                return existingHashtags;
            }

            // Initialize hashtag snapshot for a file
            function initializeHashtagSnapshot(fileId) {
                const file = files.find(f => f.id === fileId);
                if (!file) {
                    console.warn(`File not found for ID: ${fileId}`);
                    return;
                }
                
                const hashtags = extractValidHashtags(file.content);
                fileHashtagSnapshots.set(fileId, hashtags);
                console.log(`✅ Initialized hashtag snapshot for ${file.name}:`, Array.from(hashtags));
            }

            // Compare and sync hashtag changes
            function syncHashtagChanges(fileId, newContent) {
                console.log(`🔄 syncHashtagChanges called for fileId: ${fileId}`);
                
                const file = files.find(f => f.id === fileId);
                if (!file) {
                    console.warn(`❌ File not found for ID: ${fileId}`);
                    return;
                }
                
                if (file.name === 'NoteTag.md') {
                    console.log(`⏭️ Skipping NoteTag.md`);
                    return; // Skip NoteTag.md itself
                }
                
                const oldHashtags = fileHashtagSnapshots.get(fileId) || new Set();
                const newHashtags = extractValidHashtags(newContent);
                
                console.log(`📊 Hashtag comparison for ${file.name}:`);
                console.log(`   Old hashtags:`, Array.from(oldHashtags));
                console.log(`   New hashtags:`, Array.from(newHashtags));
                
                // Find removed hashtags
                const removedHashtags = new Set([...oldHashtags].filter(tag => !newHashtags.has(tag)));
                
                if (removedHashtags.size > 0) {
                    console.log(`❌ Hashtags removed from ${file.name}:`, Array.from(removedHashtags));
                    removeFileLinksFromNoteTag(file.name, removedHashtags);
                } else {
                    console.log(`✅ No hashtags removed from ${file.name}`);
                }
                
                // Update snapshot
                fileHashtagSnapshots.set(fileId, newHashtags);
                console.log(`📝 Updated snapshot for ${file.name}`);
            }

            // Apply hashtag highlighting in editor
            function applyHashtagHighlighting() {
                if (!editor || !currentFile) return;
                
                // Clear existing markers
                const existingMarkers = editor.getAllMarks();
                existingMarkers.forEach(marker => {
                    if (marker.className === 'cm-hashtag-existing') {
                        marker.clear();
                    }
                });
                
                // Get hashtags that exist in NoteTag.md
                const existingHashtags = getExistingNoteTagHashtags();
                if (existingHashtags.size === 0) return;
                
                // Find and mark hashtags in current file
                const content = editor.getValue();
                const lines = content.split('\n');
                let inCodeBlock = false;
                
                for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                    const line = lines[lineNum];
                    const trimmedLine = line.trim();
                    
                    // Handle code blocks
                    if (trimmedLine.startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        continue;
                    }
                    if (inCodeBlock) continue;
                    
                    // Skip headers, lists, blockquotes, etc.
                    if (trimmedLine.match(/^#{1,6}\s/) ||
                        trimmedLine.match(/^\s*[-*+]\s/) ||
                        trimmedLine.match(/^\s*\d+\.\s/) ||
                        trimmedLine.match(/^\s*>\s/) ||
                        trimmedLine.match(/^\|.*\|/) ||
                        trimmedLine.match(/^---+$/) ||
                        trimmedLine.startsWith('    ') ||
                        trimmedLine.startsWith('\t')) {
                        continue;
                    }
                    
                    // Find hashtags in regular paragraphs
                    // Hashtag must be preceded by start of line or space, and followed by space, newline, or end of line
                    const hashtagPattern = /(?:^|\s)(#[^\s#]+)(?=\s|$)/g;
                    let match;
                    
                    while ((match = hashtagPattern.exec(line)) !== null) {
                        const fullHashtag = match[1]; // includes the #
                        const hashtag = fullHashtag.substring(1); // remove the # for comparison
                        const matchStart = match.index;
                        const hashtagStart = matchStart + (match[0].indexOf('#')); // find actual # position
                        const hashtagEnd = hashtagStart + fullHashtag.length;
                        
                        // Check if this hashtag exists in NoteTag.md
                        if (existingHashtags.has(hashtag)) {
                            const from = { line: lineNum, ch: hashtagStart };
                            const to = { line: lineNum, ch: hashtagEnd };
                            
                            editor.markText(from, to, {
                                className: 'cm-hashtag-existing'
                            });
                        }
                    }
                }
            }

            // Remove file links from NoteTag.md for deleted hashtags
            function removeFileLinksFromNoteTag(fileName, removedHashtags) {
                const noteTagFile = files.find(f => f.name === 'NoteTag.md');
                if (!noteTagFile) return;
                
                let content = noteTagFile.content;
                let modified = false;
                
                for (const hashtag of removedHashtags) {
                    // Create pattern to match the file link exactly
                    const linkPattern = new RegExp(`\\[\\[${fileName.replace(/\.md$/, '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\]\\]`, 'g');
                    
                    // Check if the link exists in the content
                    if (content.match(linkPattern)) {
                        // Simply replace the link with empty string, preserving all whitespace and newlines
                        content = content.replace(linkPattern, '');
                        modified = true;
                        console.log(`✅ Removed [[${fileName.replace(/\.md$/, '')}]] from hashtag: ${hashtag}`);
                    }
                }
                
                if (modified) {
                    noteTagFile.content = content;
                    saveFilesToStorage();
                    
                    // Update preview if NoteTag.md is currently open
                    if (currentFile && currentFile.name === 'NoteTag.md') {
                        editor.setValue(content);
                        updatePreview();
                    }
                    
                    console.log('📝 NoteTag.md updated after hashtag removal');
                }
            }

            // Generate sharing URL for current file
            function generateSharingUrl(file, viewMode = 'preview') {
                if (!file) return '';
                
                const baseUrl = window.location.origin + window.location.pathname;
                const fileName = encodeURIComponent(file.name);
                const mode = encodeURIComponent(viewMode);
                
                return `${baseUrl}?file=${fileName}&view=${mode}`;
            }
            
            // Copy sharing URL to clipboard
            async function copyFileUrl(file, viewMode = 'preview') {
                const url = generateSharingUrl(file, viewMode);
                
                try {
                    await navigator.clipboard.writeText(url);
                    showNotification('分享連結已複製到剪貼簿');
                    return url;
                } catch (error) {
                    console.error('Failed to copy URL:', error);
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = url;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showNotification('分享連結已複製到剪貼簿');
                    return url;
                }
            }

            // Start the application
            initialize();
        });
    </script>
</body>
</html>