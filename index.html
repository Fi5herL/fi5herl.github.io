<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A3Note</title>
    <link rel="stylesheet" href="lib/font-awesome/all.min.css">
    <link rel="stylesheet" href="lib/excalidraw/excalidraw.min.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><defs><linearGradient id='grad' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%23ff6b35'/><stop offset='100%' style='stop-color:%23f7931e'/></linearGradient></defs><g fill='url(%23grad)' stroke='url(%23grad)' stroke-width='4' stroke-linecap='round'><circle cx='32' cy='12' r='6' fill='url(%23grad)'/><line x1='32' y1='18' x2='32' y2='40'/><line x1='32' y1='28' x2='20' y2='22'/><line x1='32' y1='28' x2='44' y2='34'/><line x1='32' y1='40' x2='22' y2='56'/><line x1='32' y1='40' x2='42' y2='56'/></g></svg>" type="image/svg+xml">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
            background: #000;
        }

        /* Instagram-style Sidebar */
        .sidebar {
            width: 350px;
            background: #000;
            border-right: 1px solid #262626;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease, width 0.3s ease;
            position: relative;
            z-index: 10;
        }

        .sidebar.collapsed {
            width: 80px;
            overflow: hidden;
        }

        .sidebar.collapsed .sidebar-header .logo span,
        .sidebar.collapsed .search-container,
        .sidebar.collapsed .note-info,
        .sidebar.collapsed .note-actions,
        .sidebar.collapsed .storage-info .storage-text,
        .sidebar.collapsed .storage-bar {
            display: none;
        }

        .sidebar.collapsed .add-note-btn span {
            display: none;
        }

        .sidebar.collapsed .add-note-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            justify-content: center;
            margin: 0 auto;
        }

        .sidebar.collapsed .sidebar-header {
            padding: 20px 10px;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar.collapsed .logo {
            justify-content: center;
        }

        .sidebar.collapsed .note-thumbnail {
            margin: 0 auto;
        }

        .sidebar.collapsed .note-preview {
            justify-content: center;
        }

        .sidebar.collapsed .note-item {
            padding: 8px;
        }

        .sidebar-toggle {
            position: fixed;
            top: 15px;
            left: 335px;
            width: 30px;
            height: 30px;
            background: #262626;
            border: 1px solid #404040;
            color: #fff;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 1000;
            transition: all 0.2s ease;
        }

        .sidebar-toggle:hover {
            background: #404040;
            transform: scale(1.1);
        }

        .sidebar.collapsed .sidebar-toggle {
            left: 65px;
            background: #404040;
            border-color: #666;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .sidebar.collapsed .sidebar-toggle:hover {
            background: #555;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #262626;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            background: linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .add-note-btn {
            background: linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            transition: transform 0.2s ease;
        }

        .add-note-btn:hover {
            transform: scale(1.05);
        }

        .search-container {
            padding: 15px 20px;
            border-bottom: 1px solid #262626;
        }

        .search-box {
            width: 100%;
            background: #262626;
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            color: #fff;
            font-size: 14px;
        }

        .search-box::placeholder {
            color: #8e8e8e;
        }

        /* æª¢è¦–åˆ‡æ›æŒ‰éˆ• */
        .view-btn {
            flex: 1;
            padding: 8px 12px;
            background: #333;
            color: #ffffff;
            border: 1px solid #444;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .view-btn:hover {
            background: #444;
            border-color: #555;
        }

        .view-btn.active {
            background: #007AFF;
            border-color: #007AFF;
            color: white;
        }

        /* åœ–ç‰‡æª¢è¦–å€åŸŸ */
        .images-grid {
            display: none;
            padding: 20px;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            overflow-x: hidden; /* éš±è—æ°´å¹³æ»¾å‹•æ¢ */
        }

        .image-card {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 12px;
            border: 1px solid #333;
            transition: all 0.2s ease;
        }

        .image-card:hover {
            border-color: #007AFF;
            transform: translateY(-2px);
        }

        .image-thumbnail {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 6px;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }

        .image-info {
            font-size: 12px;
            color: #ccc;
        }

        .image-id {
            font-family: monospace;
            word-break: break-all;
            margin: 4px 0;
            color: #007AFF;
        }

        .image-refs {
            margin-top: 8px;
        }

        .ref-tag {
            display: inline-block;
            background: #007AFF;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 2px;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-top: 8px;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        /* å´é‚Šæ¬„æ”¶ç¸®æ™‚çš„æ¨£å¼ */
        .sidebar.collapsed .btn-text {
            display: none;
        }

        .sidebar.collapsed .view-btn {
            padding: 8px;
            min-width: 36px;
            justify-content: center;
        }

        /* æ”¶ç¸®æ™‚çš„åˆ‡æ›æŒ‰éˆ• */
        .sidebar.collapsed .view-toggle {
            justify-content: center;
        }

        .sidebar.collapsed .view-toggle .view-btn:not(.single-toggle) {
            display: none;
        }

        .sidebar.collapsed .view-toggle .single-toggle {
            display: flex !important;
        }

        .single-toggle {
            display: none;
        }

        .sidebar.collapsed .upload-header {
            display: none;
        }

        .sidebar.collapsed .upload-controls {
            flex-direction: column;
            gap: 6px; /* æ›´å°çš„é–“è· */
            align-items: center !important; /* å¼·åˆ¶ç½®ä¸­ */
            justify-content: center !important; /* å¼·åˆ¶ç½®ä¸­ */
            width: 100%; /* ä½”æ»¿å¯¬åº¦ */
            padding: 0 !important; /* ç§»é™¤æ‰€æœ‰å…§é‚Šè· */
            margin: 0 !important; /* ç§»é™¤æ‰€æœ‰å¤–é‚Šè· */
            box-sizing: border-box;
            display: flex !important;
        }

        .sidebar.collapsed .upload-control-btn {
            padding: 0 !important; /* ç§»é™¤æ‰€æœ‰å…§é‚Šè· */
            margin: 0 !important; /* ç§»é™¤æ‰€æœ‰å¤–é‚Šè· */
            min-width: 36px;
            width: 36px; /* å›ºå®šå¯¬åº¦ */
            height: 36px; /* å›ºå®šé«˜åº¦ */
            justify-content: center !important;
            align-items: center !important;
            display: flex !important;
            border: none !important;
            border-radius: 6px;
            position: relative;
        }
        
        /* ç¸®å°æ¨¡å¼ä¸‹éš±è—æŒ‰éˆ•æ–‡å­— */
        .sidebar.collapsed .upload-control-btn .btn-text {
            display: none;
        }

        .sidebar.collapsed .upload-status {
            display: none;
        }

        .sidebar.collapsed .preview-title {
            display: none;
        }
        
        /* ç¸®å°æ¨¡å¼ä¸‹éš±è—é è¦½å€åŸŸ */
        .sidebar.collapsed #previewArea {
            display: none !important;
        }
        
        /* ç¸®å°å´é‚Šæ¬„æ™‚ç½®ä¸­storage info */
        .sidebar.collapsed .storage-info {
            text-align: center;
            padding: 8px;
        }

        .sidebar.collapsed .upload-area {
            padding: 8px 0 !important; /* åªä¿ç•™ä¸Šä¸‹å…§é‚Šè· */
            margin: 0 !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }

        /* æ”¶ç¸®æ™‚çš„åœ–ç‰‡ç¶²æ ¼ - å°ç¸®åœ–æ¨¡å¼ */
        .sidebar.collapsed .images-grid {
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            padding: 10px;
            /* æ›´å°çš„æ»¾å‹•æ¢æ¨£å¼ */
            scrollbar-width: thin;
            scrollbar-color: #444 transparent;
            overflow-x: hidden; /* å®Œå…¨éš±è—æ°´å¹³æ»¾å‹• */
        }
        
        /* è‡ªå®šç¾©ç¸®å°å´é‚Šæ¬„çš„æ»¾å‹•æ¢æ¨£å¼ */
        .sidebar.collapsed .images-grid::-webkit-scrollbar {
            width: 4px; /* æ›´ç´°çš„æ»¾å‹•æ¢ */
        }
        
        .sidebar.collapsed .images-grid::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .sidebar.collapsed .images-grid::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 2px;
        }
        
        .sidebar.collapsed .images-grid::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .sidebar.collapsed .image-card {
            padding: 4px;
            border-radius: 6px;
        }

        .sidebar.collapsed .image-thumbnail {
            height: 50px;
            margin-bottom: 0;
        }

        .sidebar.collapsed .image-info {
            display: none;
        }

        .notes-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .note-item {
            padding: 8px 12px;
            border-bottom: 1px solid #1a1a1a;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .note-item:hover {
            background: #1a1a1a;
        }

        .note-item.active {
            background: #262626;
            border-left: 3px solid #e91e63;
        }

        .note-preview {
            display: flex;
            align-items: center;
            gap: 8px; /* æ¸›å°‘åœ–ç¤ºèˆ‡å…§å®¹é–“çš„é–“è· */
        }

        .note-thumbnail {
            width: 45px; /* å¢å¤§åœ–ç¤º */
            height: 45px; /* å¢å¤§åœ–ç¤º */
            background: #262626;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8e8e8e;
            flex-shrink: 0;
            font-size: 14px;
            margin-right: 10px; /* æ¸›å°‘èˆ‡å…§å®¹çš„é–“è· */
        }

        .note-info {
            flex: 1;
            min-width: 0;
        }

        .note-title {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-meta {
            color: #8e8e8e;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .note-actions {
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .note-item:hover .note-actions {
            opacity: 1;
        }

        .action-btn {
            background: none;
            border: none;
            color: #8e8e8e;
            padding: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .action-btn:hover {
            color: #fff;
        }

        .action-btn.delete:hover {
            color: #ed4956;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fff;
            position: relative;
            z-index: 1;
        }

        .canvas-header {
            background: #fff;
            padding: 4px 16px;
            border-bottom: 1px solid #dbdbdb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 40px;
            min-height: 40px;
        }

        .canvas-title {
            font-size: 18px;
            font-weight: 600;
            color: #262626;
            margin-left: 12px;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .canvas-title:hover {
            color: #0095f6;
        }

        .canvas-title.editing {
            background: #f8f9fa;
            border: 1px solid #dbdbdb;
            border-radius: 4px;
            padding: 2px 8px;
            outline: none;
        }

        .canvas-tools {
            display: flex;
            align-items: center;
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1px;
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            height: 34px;
        }

        .save-status {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 6px;
            background: #f0f8f0;
            border: 1px solid #e0f0e0;
            transition: opacity 0.3s ease;
            margin-right: 6px;
            height: 32px;
            font-size: 11px;
        }

        .tool-btn {
            background: transparent;
            border: none;
            color: #262626;
            padding: 6px 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            transition: all 0.2s ease;
            position: relative;
            height: 32px;
            line-height: 1;
        }

        .tool-btn:hover {
            background: #e9ecef;
            color: #000;
        }

        .tool-btn:active {
            background: #dee2e6;
            transform: scale(0.98);
        }

        .tool-btn + .tool-btn {
            margin-left: 0;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .excalidraw-wrapper {
            width: 100%;
            height: 100%;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #8e8e8e;
            text-align: center;
        }

        .empty-state i {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #262626;
        }

        .storage-info {
            padding: 15px 20px;
            background: #1a1a1a;
            border-top: 1px solid #262626;
            text-align: center;
        }

        .storage-text {
            color: #8e8e8e;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .storage-bar {
            height: 4px;
            background: #262626;
            border-radius: 2px;
            overflow: hidden;
        }

        .storage-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.3s ease;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                z-index: 1000;
                height: 100%;
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .main-content {
                width: 100%;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #fff;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #262626;
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #dbdbdb;
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn.primary {
            background: linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%);
            color: white;
        }

        .modal-btn.secondary {
            background: #fff;
            color: #262626;
            border: 1px solid #dbdbdb;
        }

        .modal-btn:hover {
            transform: translateY(-1px);
        }

        /* ç°¡åŒ–çš„é è¦½æç¤ºæ¡† */
        .note-preview-tooltip {
            position: fixed;
            left: 90px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 12px 16px;
            color: white;
            z-index: 2000;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            transform: translateX(10px);
        }

        .note-preview-tooltip::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 6px 6px 6px 0;
            border-color: transparent rgba(0, 0, 0, 0.9) transparent transparent;
        }

        .note-preview-tooltip.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(0px);
        }

    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <button class="sidebar-toggle" onclick="toggleSidebarCollapse()" title="Toggle Sidebar">
                <i class="fas fa-chevron-left" id="toggleIcon"></i>
            </button>
            <div class="sidebar-header">
                <div class="logo">
                    <i class="fas fa-draw-polygon"></i>
                    <span>A3Note</span>
                </div>
                <button class="add-note-btn" onclick="showNewNoteModal()">
                    <i class="fas fa-plus"></i>
                    <span>New</span>
                </button>
            </div>

            <div class="search-container">
                <input type="text" class="search-box" placeholder="Search notes..." oninput="searchNotes(this.value)">
            </div>
            
            <!-- æª¢è¦–æ¨¡å¼åˆ‡æ› -->
            <div class="view-toggle" style="margin: 15px 20px; display: flex; gap: 8px;">
                <!-- å±•é–‹æ™‚çš„é›™æŒ‰éˆ• -->
                <button id="notesViewBtn" class="view-btn active" onclick="app.switchToNotesView()" title="ç­†è¨˜æª¢è¦–">
                    <i class="fas fa-sticky-note"></i> 
                    <span class="btn-text">ç­†è¨˜</span>
                </button>
                <button id="imagesViewBtn" class="view-btn" onclick="app.switchToImagesView()" title="åœ–ç‰‡æª¢è¦–åº«">
                    <i class="fas fa-images"></i> 
                    <span class="btn-text">åœ–ç‰‡åº«</span>
                </button>
                
                <!-- æ”¶ç¸®æ™‚çš„å–®ä¸€åˆ‡æ›æŒ‰éˆ• -->
                <button id="toggleViewBtn" class="view-btn single-toggle" onclick="app.toggleView()" title="åˆ‡æ›æª¢è¦–æ¨¡å¼">
                    <i id="toggleViewIcon" class="fas fa-sticky-note"></i>
                </button>
            </div>

            <div class="notes-list" id="notesList">
                <!-- Notes will be dynamically loaded here -->
            </div>
            
            <!-- åœ–ç‰‡æª¢è¦–å€åŸŸ -->
            <div class="images-grid" id="imagesGrid">
                <!-- Images will be dynamically loaded here -->
            </div>
            
            <!-- åœ–ç‰‡ä¸Šå‚³å€åŸŸ -->
            <div class="upload-area" id="uploadArea" style="display: none; padding: 20px; border-top: 1px solid #333;">
                <div class="upload-header" style="text-align: center; margin-bottom: 15px;">
                    <h3 style="color: #fff; margin: 0 0 10px 0;">ä¸Šå‚³åœ–ç‰‡åˆ°å…¨åŸŸè³‡æ–™åº«</h3>
                    <p style="color: #999; font-size: 13px; margin: 0;">ä¸Šå‚³åœ–ç‰‡å¾Œï¼Œä»»ä½•ç­†è¨˜ä¸­æœ‰å°æ‡‰ SHA1 ID çš„åœ–ç‰‡å…ƒç´ éƒ½æœƒè‡ªå‹•é¡¯ç¤º</p>
                </div>
                
                <div class="upload-controls" style="display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap;">
                    <input type="file" id="imageUpload" accept="image/*" multiple style="display: none;">
                    <button onclick="document.getElementById('imageUpload').click()" class="upload-control-btn" style="background: #007AFF; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;" title="é¸æ“‡åœ–ç‰‡">
                        <i class="fas fa-upload"></i> 
                        <span class="btn-text">é¸æ“‡åœ–ç‰‡</span>
                    </button>
                    <button onclick="app.uploadSelectedImages()" id="uploadBtn" class="upload-control-btn" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;" title="ä¸Šå‚³åˆ°è³‡æ–™åº«" disabled>
                        <i class="fas fa-cloud-upload-alt"></i> 
                        <span class="btn-text">ä¸Šå‚³åˆ°è³‡æ–™åº«</span>
                    </button>
                    <span id="uploadStatus" class="upload-status" style="color: #999; font-size: 13px;"></span>
                </div>
                
                <div id="previewArea" style="margin-top: 15px; display: none;">
                    <div class="preview-title" style="color: #fff; font-size: 14px; margin-bottom: 10px;">é è¦½ï¼š</div>
                    <div id="previewImages" style="display: flex; gap: 10px; flex-wrap: wrap;"></div>
                </div>
            </div>

            <div class="storage-info">
                <div class="storage-text" id="storageText">Storage: 0 MB / ~5000 MB</div>
                <div class="storage-bar">
                    <div class="storage-fill" id="storageFill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="canvas-header">
                <div class="canvas-title" id="canvasTitle" onclick="editNoteName()" title="Click to edit note name">Select a note to start drawing</div>
                <div class="canvas-tools">
                    <div class="save-status" id="saveStatus" style="display: none;">
                        <i class="fas fa-check-circle" style="color: #4CAF50;"></i>
                        <span style="font-size: 12px; color: #4CAF50;">Saved</span>
                    </div>
                    <button class="tool-btn" onclick="exportNote()" title="Export">
                        <i class="fas fa-download"></i>
                        Export
                    </button>
                    <button class="tool-btn" onclick="app.debugFiles()" title="Debug Files">
                        <i class="fas fa-bug"></i>
                        Debug
                    </button>
                    <button class="tool-btn" onclick="app.cleanupOrphanedImages()" title="Clean Images">
                        <i class="fas fa-broom"></i>
                        Clean
                    </button>
                    <button class="tool-btn" onclick="app.testFileId()" title="Test FileID">
                        <i class="fas fa-fingerprint"></i>
                        FileID
                    </button>
                    <button class="tool-btn" onclick="app.migrateOldFiles()" title="Migrate Old Files">
                        <i class="fas fa-database"></i>
                        Migrate
                    </button>
                    <button class="tool-btn" onclick="shareNote()" title="Share">
                        <i class="fas fa-share"></i>
                        Share
                    </button>
                    <button class="tool-btn" onclick="fullscreenCanvas()" title="Fullscreen">
                        <i class="fas fa-expand"></i>
                        Fullscreen
                    </button>
                    <button class="tool-btn" onclick="debugCurrentNote()" title="Debug">
                        <i class="fas fa-bug"></i>
                        Debug
                    </button>
                </div>
            </div>

            <div class="canvas-container" id="canvasContainer">
                <div class="empty-state">
                    <i class="fas fa-draw-polygon"></i>
                    <h3>Start Creating</h3>
                    <p>Create a new note to begin drawing your visual ideas</p>
                </div>
            </div>
        </div>
    </div>

    <!-- New Note Modal -->
    <div class="modal" id="newNoteModal">
        <div class="modal-content">
            <div class="modal-title">Create New Note</div>
            <input type="text" class="modal-input" id="noteNameInput" placeholder="Enter note name..." maxlength="50">
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="hideNewNoteModal()">Cancel</button>
                <button class="modal-btn primary" onclick="createNewNote()">Create</button>
            </div>
        </div>
    </div>

    <!-- Include React and Excalidraw -->
    <script src="lib/excalidraw/react.production.min.js"></script>
    <script src="lib/excalidraw/react-dom.production.min.js"></script>
    <script src="lib/excalidraw/excalidraw.production.min.js"></script>

    <script>
        // IndexedDB Database Management
        class NotesDB {
            constructor() {
                this.dbName = 'A3NoteDB';
                this.version = 2; // Updated version for files support
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const oldVersion = event.oldVersion;
                        
                        // Create notes store if it doesn't exist (version 1)
                        if (oldVersion < 1) {
                            const notesStore = db.createObjectStore('notes', { keyPath: 'id' });
                            notesStore.createIndex('title', 'title', { unique: false });
                            notesStore.createIndex('createdAt', 'createdAt', { unique: false });
                            notesStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                            
                            // Canvas data object store (separate for large data)
                            const canvasStore = db.createObjectStore('canvasData', { keyPath: 'noteId' });
                        }
                        
                        // Add global files store for version 2
                        if (oldVersion < 2) {
                            const filesStore = db.createObjectStore('files', { keyPath: 'id' });
                            // ç§»é™¤ noteId indexï¼Œæ”¹ç‚ºå…¨åŸŸæª”æ¡ˆå„²å­˜
                            console.log('Global files object store created for version 2');
                        }
                    };
                });
            }

            async saveNote(note) {
                const transaction = this.db.transaction(['notes'], 'readwrite');
                const store = transaction.objectStore('notes');
                return store.put(note);
            }

            async saveCanvasData(noteId, canvasData) {
                return new Promise(async (resolve, reject) => {
                    try {
                        console.log(`Saving canvas data for noteId: ${noteId}`, canvasData);
                        
                        // Compress canvas data
                        const compressedData = await this.compressData(canvasData);
                        
                        const transaction = this.db.transaction(['canvasData'], 'readwrite');
                        const store = transaction.objectStore('canvasData');
                        
                        const saveData = { 
                            noteId, 
                            data: compressedData, 
                            timestamp: Date.now() 
                        };
                        
                        const request = store.put(saveData);
                        
                        request.onsuccess = () => {
                            console.log(`Canvas data saved to IndexedDB for note ${noteId}`);
                            resolve();
                        };
                        
                        request.onerror = () => {
                            console.error(`Failed to save canvas data for note ${noteId}:`, request.error);
                            reject(request.error);
                        };
                        
                    } catch (error) {
                        console.error('Error in saveCanvasData:', error);
                        reject(error);
                    }
                });
            }

            async getAllNotes() {
                const transaction = this.db.transaction(['notes'], 'readonly');
                const store = transaction.objectStore('notes');
                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getCanvasData(noteId) {
                return new Promise(async (resolve, reject) => {
                    try {
                        console.log(`Loading canvas data for noteId: ${noteId}`);
                        
                        const transaction = this.db.transaction(['canvasData'], 'readonly');
                        const store = transaction.objectStore('canvasData');
                        const request = store.get(noteId);
                        
                        request.onsuccess = async () => {
                            if (request.result && request.result.data) {
                                console.log(`Found canvas data for note ${noteId}`);
                                try {
                                    const decompressedData = await this.decompressData(request.result.data);
                                    console.log(`Decompressed data:`, decompressedData);
                                    resolve(decompressedData);
                                } catch (decompressError) {
                                    console.error('Failed to decompress data:', decompressError);
                                    resolve({ elements: [], appState: {} });
                                }
                            } else {
                                console.log(`No canvas data found for note ${noteId}, returning empty canvas`);
                                resolve({ elements: [], appState: {} });
                            }
                        };
                        
                        request.onerror = () => {
                            console.error(`Failed to load canvas data for note ${noteId}:`, request.error);
                            reject(request.error);
                        };
                        
                    } catch (error) {
                        console.error('Error in getCanvasData:', error);
                        reject(error);
                    }
                });
            }

            async saveFile(fileId, fileData) {
                return new Promise((resolve, reject) => {
                    try {
                        console.log(`Checking global file store for: ${fileId}`);
                        
                        const transaction = this.db.transaction(['files'], 'readwrite');
                        const store = transaction.objectStore('files');
                        
                        // Validate file data before saving
                        if (!fileData) {
                            console.warn(`No file data for ${fileId}`);
                            resolve(); // Don't reject, just skip
                            return;
                        }
                        
                        console.log(`Validating file ${fileId}:`, {
                            hasDataURL: !!fileData.dataURL,
                            type: fileData.mimeType || fileData.type,
                            keys: Object.keys(fileData)
                        });
                        
                        // ğŸ¯ æ ¸å¿ƒæ”¹è®Šï¼šå…ˆæª¢æŸ¥æª”æ¡ˆæ˜¯å¦å·²å­˜åœ¨æ–¼å…¨åŸŸæª”æ¡ˆåº«
                        const checkRequest = store.get(fileId);
                        
                        checkRequest.onsuccess = () => {
                            if (checkRequest.result) {
                                // æª”æ¡ˆå·²å­˜åœ¨ï¼Œåªæ›´æ–°æœ€å¾Œä½¿ç”¨æ™‚é–“
                                console.log(`File ${fileId} already exists in global store, updating lastUsed`);
                                const existingData = checkRequest.result;
                                existingData.lastUsed = Date.now();
                                
                                const updateRequest = store.put(existingData);
                                updateRequest.onsuccess = () => resolve();
                                updateRequest.onerror = () => reject(updateRequest.error);
                            } else {
                                // æª”æ¡ˆä¸å­˜åœ¨ï¼Œæ–°å¢åˆ°å…¨åŸŸæª”æ¡ˆåº«
                                console.log(`New file ${fileId}, adding to global file store`);
                                const saveData = {
                                    id: fileId,                    // SHA1 ä½œç‚ºä¸»éµ
                                    data: fileData,               // æª”æ¡ˆè³‡æ–™
                                    createdAt: Date.now(),        // å»ºç«‹æ™‚é–“
                                    lastUsed: Date.now(),         // æœ€å¾Œä½¿ç”¨æ™‚é–“
                                    size: fileData.dataURL?.length || 0  // æª”æ¡ˆå¤§å°
                                };
                                
                                const saveRequest = store.put(saveData);
                                saveRequest.onsuccess = () => {
                                    console.log(`New file ${fileId} saved to global store, size: ${saveData.size} bytes`);
                                    resolve();
                                };
                                saveRequest.onerror = () => reject(saveRequest.error);
                            }
                        };
                        
                        checkRequest.onerror = () => reject(checkRequest.error);
                        
                    } catch (error) {
                        console.error('Error in saveFile:', error);
                        reject(error);
                    }
                });
            }

            async getFile(fileId) {
                return new Promise((resolve, reject) => {
                    try {
                        console.log(`Loading file: ${fileId}`);
                        
                        const transaction = this.db.transaction(['files'], 'readonly');
                        const store = transaction.objectStore('files');
                        const request = store.get(fileId);
                        
                        request.onsuccess = () => {
                            if (request.result && request.result.data) {
                                console.log(`File ${fileId} found`);
                                resolve(request.result.data);
                            } else {
                                console.log(`File ${fileId} not found`);
                                resolve(null);
                            }
                        };
                        
                        request.onerror = () => {
                            console.error(`Failed to load file ${fileId}:`, request.error);
                            reject(request.error);
                        };
                        
                    } catch (error) {
                        console.error('Error in getFile:', error);
                        reject(error);
                    }
                });
            }

            async getNoteFiles(noteId) {
                return new Promise(async (resolve, reject) => {
                    try {
                        console.log(`Loading files for note: ${noteId}`);
                        
                        // ğŸ¯ æ–°é‚è¼¯ï¼šå…ˆå–å¾—ç­†è¨˜çš„canvasè³‡æ–™ï¼Œæ‰¾å‡ºéœ€è¦çš„fileId
                        const canvasData = await this.getCanvasData(noteId);
                        const elements = canvasData?.elements || [];
                        
                        // æ‰¾å‡ºæ‰€æœ‰åœ–ç‰‡å…ƒç´ çš„ fileId
                        const requiredFileIds = elements
                            .filter(el => el.type === 'image' && el.fileId)
                            .map(el => el.fileId);
                        
                        console.log(`Note ${noteId} requires files:`, requiredFileIds);
                        
                        if (requiredFileIds.length === 0) {
                            resolve({});
                            return;
                        }
                        
                        // å¾å…¨åŸŸæª”æ¡ˆåº«è¼‰å…¥éœ€è¦çš„æª”æ¡ˆ
                        const transaction = this.db.transaction(['files'], 'readonly');
                        const store = transaction.objectStore('files');
                        const files = {};
                        
                        const loadPromises = requiredFileIds.map(fileId => {
                            return new Promise((resolveFile) => {
                                const request = store.get(fileId);
                                request.onsuccess = () => {
                                    if (request.result && request.result.data) {
                                        files[fileId] = request.result.data;
                                        console.log(`Loaded file ${fileId} from global store`);
                                    } else {
                                        console.warn(`File ${fileId} not found in global store`);
                                    }
                                    resolveFile();
                                };
                                request.onerror = () => {
                                    console.error(`Error loading file ${fileId}:`, request.error);
                                    resolveFile();
                                };
                            });
                        });
                        
                        Promise.all(loadPromises).then(() => {
                            console.log(`Loaded ${Object.keys(files).length}/${requiredFileIds.length} files for note ${noteId}`);
                            resolve(files);
                        });
                        
                    } catch (error) {
                        console.error('Error in getNoteFiles:', error);
                        reject(error);
                    }
                });
            }

            async deleteNote(noteId) {
                const transaction = this.db.transaction(['notes', 'canvasData', 'files'], 'readwrite');
                const notesStore = transaction.objectStore('notes');
                const canvasStore = transaction.objectStore('canvasData');
                const filesStore = transaction.objectStore('files');
                
                // Delete note
                await notesStore.delete(noteId);
                
                // Delete canvas data
                await canvasStore.delete(noteId);
                
                // Delete all files for this note
                const filesIndex = filesStore.index('noteId');
                const filesRequest = filesIndex.getAllKeys(noteId);
                filesRequest.onsuccess = () => {
                    filesRequest.result.forEach(fileId => {
                        filesStore.delete(fileId);
                    });
                };
            }

            async getStorageUsage() {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    return {
                        used: estimate.usage || 0,
                        quota: estimate.quota || 5000000000 // 5GB default
                    };
                }
                return { used: 0, quota: 5000000000 };
            }

            // Simple compression using built-in methods
            async compressData(data) {
                try {
                    const jsonString = JSON.stringify(data);
                    const compressed = new TextEncoder().encode(jsonString);
                    console.log(`Compressed data size: ${compressed.length} bytes`);
                    return compressed;
                } catch (error) {
                    console.error('Compression failed:', error);
                    return new TextEncoder().encode(JSON.stringify({ elements: [], appState: {} }));
                }
            }

            async decompressData(compressedData) {
                try {
                    const jsonString = new TextDecoder().decode(compressedData);
                    const data = JSON.parse(jsonString);
                    console.log(`Decompressed data with ${data.elements?.length || 0} elements`);
                    return data;
                } catch (error) {
                    console.error('Decompression failed:', error);
                    return { elements: [], appState: {} };
                }
            }
        }

        // App State Management
        class NotesApp {
            constructor() {
                this.db = new NotesDB();
                this.currentNote = null;
                this.excalidrawAPI = null;
                this.notes = [];
                this.searchTerm = '';
                this.renderTimeout = null;
                this.autoSaveTimeout = null;
                this.isInitializing = false;
                this.lastSaveTime = 0;
                this.fileCache = new Map(); // æª”æ¡ˆå¿«å–
                this.currentView = 'notes'; // 'notes' or 'images'
                
            }

            async init() {
                try {
                    console.log('Initializing NotesApp...');
                    await this.db.init();
                    console.log('Database initialized');
                    
                    await this.loadNotes();
                    console.log('Notes loaded');
                    
                    this.updateStorageInfo();
                    console.log('Storage info updated');
                    
                    // Don't auto-setup Excalidraw - wait for first note selection
                    console.log('NotesApp initialization complete');
                    
                    // Auto-save every 30 seconds
                    setInterval(() => this.autoSave(), 30000);
                } catch (error) {
                    console.error('Failed to initialize NotesApp:', error);
                }
            }

            async loadNotes() {
                this.notes = await this.db.getAllNotes();
                this.notes.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                this.renderNotesList();
            }

            // è¨ˆç®—ç­†è¨˜ä¸­çš„ç¸½å­—å…ƒæ•¸é‡
            async getTextCharacterCount(noteId) {
                try {
                    const canvasData = await this.db.getCanvasData(noteId);
                    if (!canvasData || !canvasData.elements) return 0;
                    
                    let totalCharacters = 0;
                    
                    canvasData.elements.forEach(element => {
                        if (element.type === 'text' && element.text) {
                            totalCharacters += element.text.length;
                        }
                    });
                    
                    return totalCharacters;
                } catch (error) {
                    console.warn(`Failed to get character count for note ${noteId}:`, error);
                    return 0;
                }
            }

            // Generate 4096-level Instagram-style gradient based on character count
            getNoteGradient(noteId) {
                // å°‡ç­†è¨˜IDæ‹†æˆå…©æ®µä¾†ç”Ÿæˆå…©å€‹ç¨ç«‹é¡è‰²
                const midPoint = Math.floor(noteId.length / 2);
                const firstHalf = noteId.substring(0, midPoint);
                const secondHalf = noteId.substring(midPoint);
                
                // å‰åŠæ®µç®—å·¦ä¸‹è§’é¡è‰²
                const hash1 = this.stringToHash(firstHalf);
                const color1 = this.hashToColor(hash1);
                
                // å¾ŒåŠæ®µç®—å³ä¸Šè§’é¡è‰²
                const hash2 = this.stringToHash(secondHalf);
                const color2 = this.hashToColor(hash2);
                
                // å¾‘å‘æ¼¸å±¤ï¼šcolor1å¾å·¦ä¸‹è§’æ“´æ•£ï¼Œcolor2å¾å³ä¸Šè§’æ“´æ•£ï¼Œä¸­é–“è¶Šä¾†è¶Šäº®
                return `
                    radial-gradient(circle at 20% 80%, ${color1} 0%, rgba(255,255,255,0.3) 70%, transparent 100%), 
                    radial-gradient(circle at 80% 20%, ${color2} 0%, rgba(255,255,255,0.3) 70%, transparent 100%),
                    radial-gradient(circle at 50% 50%, rgba(255,255,255,0.4) 0%, transparent 60%)
                `;
            }
            
            stringToHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // è½‰æ›ç‚º32ä½æ•´æ•¸
                }
                return Math.abs(hash);
            }
            
            hashToColor(hash) {
                // å°‡hashè½‰æ›ç‚ºRGBé¡è‰² (0x000000 åˆ° 0xFFFFFF)
                const r = (hash & 0xFF0000) >> 16;
                const g = (hash & 0x00FF00) >> 8;
                const b = hash & 0x0000FF;
                
                // ç¢ºä¿é¡è‰²ä¸æœƒå¤ªæš—ï¼Œè‡³å°‘ä¿æŒä¸€å®šäº®åº¦
                const minBrightness = 60;
                const adjustedR = Math.max(r, minBrightness);
                const adjustedG = Math.max(g, minBrightness);
                const adjustedB = Math.max(b, minBrightness);
                
                return `rgb(${adjustedR}, ${adjustedG}, ${adjustedB})`;
            }

            clearExcalidrawHistory() {
                if (!this.excalidrawAPI) {
                    console.log('âš ï¸ Cannot clear history - Excalidraw API not available');
                    return;
                }
                
                try {
                    console.log('ğŸ§¹ Clearing Excalidraw history using official API...');
                    
                    // âœ… ä½¿ç”¨å®˜æ–¹APIæ¸…é™¤æ­·å²è¨˜éŒ„
                    if (this.excalidrawAPI.history && typeof this.excalidrawAPI.history.clear === 'function') {
                        this.excalidrawAPI.history.clear();
                        console.log('âœ… History cleared successfully using excalidrawAPI.history.clear()');
                    } else {
                        console.warn('âš ï¸ history.clear() method not available, trying alternative...');
                        
                        // å‚™ç”¨æ–¹æ³•ï¼šå˜—è©¦ç›´æ¥æ›´æ–°appState
                        const currentAppState = this.excalidrawAPI.getAppState();
                        this.excalidrawAPI.updateScene({
                            appState: {
                                ...currentAppState,
                                history: {
                                    undoStack: [],
                                    redoStack: []
                                }
                            }
                        });
                        console.log('âœ… History cleared using updateScene fallback');
                    }
                    
                } catch (error) {
                    console.error('âŒ Failed to clear history:', error);
                }
            }

            scrollToContentCenter() {
                if (!this.excalidrawAPI) {
                    console.log('Excalidraw API not available for scrollToContent');
                    return;
                }
                
                try {
                    const elements = this.excalidrawAPI.getSceneElements();
                    if (elements.length === 0) {
                        console.log('No elements to center');
                        return;
                    }
                    
                    // è¨ˆç®—æ‰€æœ‰å…ƒç´ çš„é‚Šç•Œæ¡†
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    
                    elements.forEach(element => {
                        if (element.x < minX) minX = element.x;
                        if (element.y < minY) minY = element.y;
                        if (element.x + element.width > maxX) maxX = element.x + element.width;
                        if (element.y + element.height > maxY) maxY = element.y + element.height;
                    });
                    
                    // è¨ˆç®—å…§å®¹ä¸­å¿ƒé»
                    const contentCenterX = (minX + maxX) / 2;
                    const contentCenterY = (minY + maxY) / 2;
                    
                    // ç²å–ç•«å¸ƒå°ºå¯¸
                    const canvasElement = document.querySelector('.excalidraw__canvas');
                    if (!canvasElement) return;
                    
                    const canvasWidth = canvasElement.clientWidth;
                    const canvasHeight = canvasElement.clientHeight;
                    
                    // è¨ˆç®—éœ€è¦çš„æ»¾å‹•ä½ç½®è®“å…§å®¹å±…ä¸­
                    const scrollX = -(contentCenterX - canvasWidth / 2);
                    const scrollY = -(contentCenterY - canvasHeight / 2);
                    
                    // æ›´æ–°æ‡‰ç”¨ç‹€æ…‹ä¾†å±…ä¸­å…§å®¹
                    this.excalidrawAPI.updateScene({
                        appState: {
                            scrollX: scrollX,
                            scrollY: scrollY,
                            activeTool: { type: "selection" } // ç¢ºä¿ä½¿ç”¨handæ¨¡å¼
                        }
                    });
                    
                    console.log(`Content centered at: scrollX=${scrollX}, scrollY=${scrollY}`);
                    
                } catch (error) {
                    console.error('Error centering content:', error);
                }
            }

            // ç·Šæ€¥debugåŠŸèƒ½ï¼šæª¢æŸ¥æ‰€æœ‰ç­†è¨˜å…§å®¹
            async debugCheckAllNotesContent() {
                console.log('ğŸš¨ EMERGENCY DEBUG: Checking all notes content...');
                
                for (const note of this.notes) {
                    try {
                        const canvasData = await this.db.getCanvasData(note.id);
                        const elementCount = canvasData?.elements?.length || 0;
                        
                        console.log(`ğŸ“ Note: ${note.title} (${note.id})`);
                        console.log(`   - Elements: ${elementCount}`);
                        console.log(`   - First element:`, canvasData?.elements?.[0]);
                        console.log('---');
                        
                    } catch (error) {
                        console.error(`âŒ Failed to load note ${note.id}:`, error);
                    }
                }
                
                console.log('ğŸš¨ DEBUG COMPLETE');
            }

            // è¨ˆç®—ISO 8601é€±æ•¸çš„å‡½æ•¸ (æ­£ç¢ºè™•ç†é–å¹´)
            getWeekNumber(date) {
                const d = new Date(date);
                
                // è¨­å®šç‚ºè©²é€±çš„é€±å›› (ISO 8601æ¨™æº–)
                d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
                
                // è¨ˆç®—å¹´åˆ
                const yearStart = new Date(d.getUTCFullYear(), 0, 1);
                
                // è¨ˆç®—é€±æ•¸
                const weekNumber = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                
                // ISO 8601: ä¸€å¹´å¯èƒ½æœ‰52æˆ–53é€±
                return Math.min(Math.max(weekNumber, 1), 53);
            }
            
            // ç²å–å¹´ä»½ã€æœˆä»½å’Œé€±æ•¸é¡¯ç¤ºæ–‡å­—
            getDateDisplay(createdAt) {
                const date = new Date(createdAt);
                const year = date.getFullYear().toString().slice(-2); // å¾Œå…©ä½å¹´ä»½
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getMonth()]; // æœˆä»½è‹±æ–‡ç¸®å¯«
                const week = this.getWeekNumber(date);
                const weekStr = `W${week.toString().padStart(2, '0')}`; // W01, W02...
                
                return {
                    yearMonth: `${year}${month}`, // 25Jan, 25Dec...
                    week: weekStr
                };
            }

            renderNotesList() {
                const container = document.getElementById('notesList');
                const filteredNotes = this.notes.filter(note => 
                    note.title.toLowerCase().includes(this.searchTerm.toLowerCase())
                );

                if (filteredNotes.length === 0) {
                    container.innerHTML = `
                        <div style="padding: 40px 20px; text-align: center; color: #8e8e8e;">
                            <i class="fas fa-sticky-note" style="font-size: 48px; margin-bottom: 15px; opacity: 0.3;"></i>
                            <p>No notes found</p>
                            <p style="font-size: 12px;">Create your first visual note!</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = filteredNotes.map(note => {
                    const characterCount = note.characterCount || 0;
                    const iconGradient = this.getNoteGradient(note.id);
                    const isCurrentNote = note.id === this.currentNote?.id;
                    const dateDisplay = this.getDateDisplay(note.createdAt);
                    
                    return `
                    <div class="note-item ${isCurrentNote ? 'active' : ''}" 
                         onclick="app.selectNote('${note.id}')">
                        <div class="note-preview">
                            <div class="note-thumbnail" style="background: ${iconGradient}; color: white; box-shadow: 0 2px 8px rgba(0,0,0,0.15); display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Segoe UI', sans-serif; font-weight: bold;">
                                <div style="font-size: 14px; line-height: 1; margin-bottom: 1px; text-shadow: 0 1px 3px rgba(0,0,0,0.4);">${dateDisplay.yearMonth}</div>
                                <div style="font-size: 12px; line-height: 1; text-shadow: 0 1px 3px rgba(0,0,0,0.4);">${dateDisplay.week}</div>
                            </div>
                            <div class="note-info">
                                <div class="note-title">${this.escapeHtml(note.title)}</div>
                                <div class="note-meta">
                                    <span><i class="fas fa-clock"></i> ${this.formatDate(note.updatedAt)}</span>
                                    <span><i class="fas fa-edit"></i> ${characterCount} å­—å…ƒ</span>
                                </div>
                            </div>
                        </div>
                        <div class="note-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); app.duplicateNote('${note.id}')" title="Duplicate">
                                <i class="fas fa-copy"></i>
                            </button>
                            <button class="action-btn delete" onclick="event.stopPropagation(); app.deleteNote('${note.id}')" title="Delete">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                        ${isCurrentNote ? '' : `<div class="note-preview-tooltip" id="tooltip-${note.id}"></div>`}
                    </div>
                `;}).join('');
            }

            async createNote(title) {
                const note = {
                    id: this.generateId(),
                    title: title || 'Untitled Note',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    elementCount: 0
                };

                await this.db.saveNote(note);
                await this.db.saveCanvasData(note.id, { 
                    elements: [], 
                    appState: { 
                        viewBackgroundColor: "#ffffff", 
                        zenModeEnabled: false,
                        gridSize: null,
                        activeTool: {
                            type: "selection"
                        }
                    } 
                });
                
                this.notes.unshift(note);
                this.renderNotesList();
                this.selectNote(note.id);
                this.updateStorageInfo();
            }

            async selectNote(noteId) {
                console.log(`=== Selecting note: ${noteId} ===`);
                
                // Prevent selecting the same note
                if (this.currentNote?.id === noteId) {
                    console.log('Same note selected, just hiding sidebar');
                    this.hideSidebar();
                    return;
                }

                // ğŸ”¥ CRITICAL: å–æ¶ˆæ‰€æœ‰å»¶æ™‚å„²å­˜ï¼Œé˜²æ­¢å„²å­˜åˆ°éŒ¯èª¤çš„ç­†è¨˜
                if (this.autoSaveTimeout) {
                    clearTimeout(this.autoSaveTimeout);
                    this.autoSaveTimeout = null;
                    console.log('âš ï¸ Cancelled pending auto-save to prevent cross-note contamination');
                }
                if (this.renderTimeout) {
                    clearTimeout(this.renderTimeout);
                    this.renderTimeout = null;
                    console.log('âš ï¸ Cancelled pending render updates');
                }

                // Save current note before switching
                if (this.currentNote && this.excalidrawAPI) {
                    console.log('Saving current note before switching...');
                    await this.autoSave();
                }
                
                // âœ… ä½¿ç”¨å®˜æ–¹APIæ¸…é™¤æ­·å²è¨˜éŒ„
                if (this.excalidrawAPI) {
                    console.log('ğŸ§¹ Clearing undo/redo history before note switch...');
                    this.clearExcalidrawHistory();
                }

                const note = this.notes.find(n => n.id === noteId);
                if (!note) {
                    console.error('Note not found');
                    return;
                }

                console.log(`Switching to note: ${note.title}`);
                this.currentNote = note;
                document.getElementById('canvasTitle').textContent = note.title;
                
                // Setup Excalidraw if not initialized
                if (!document.getElementById('excalidrawWrapper')) {
                    console.log('Setting up Excalidraw for first time...');
                    this.setupExcalidraw();
                    
                    // Wait a bit for initialization
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Load and display canvas data (with fallback method)
                try {
                    console.log(`Loading canvas data for note: ${noteId}`);
                    const canvasData = await this.db.getCanvasData(noteId);
                    const files = await this.db.getNoteFiles(noteId);
                    
                    const elements = canvasData?.elements || [];
                    const savedAppState = canvasData?.appState || {};
                    const appState = {
                        viewBackgroundColor: "#ffffff",
                        zenModeEnabled: false,
                        collaborators: new Map(),
                        gridSize: null,
                        activeTool: {
                            type: "selection"
                        },
                        // Preserve zoom but reset scroll if it might cause offset issues
                        zoom: savedAppState.zoom || { value: 1 },
                        scrollX: elements.length > 0 ? (savedAppState.scrollX || 0) : 0,
                        scrollY: elements.length > 0 ? (savedAppState.scrollY || 0) : 0,
                        ...savedAppState
                    };
                    
                    // Ensure collaborators is always a Map
                    if (!appState.collaborators || typeof appState.collaborators.forEach !== 'function') {
                        appState.collaborators = new Map();
                    }
                    
                    // Always ensure selection tool is active (Hand tool)
                    if (!appState.activeTool || appState.activeTool.type !== "selection") {
                        appState.activeTool = { type: "selection" };
                    }
                    
                    // Force reset scroll coordinates to prevent offset issues
                    appState.scrollX = 0;
                    appState.scrollY = 0;

                    console.log(`Attempting to update scene with ${elements.length} elements and ${Object.keys(files).length} files`);
                    
                    // Try to update via API
                    if (this.excalidrawAPI) {
                        console.log('Using Excalidraw API to update scene');
                        
                        // Update scene with all data at once
                        try {
                            console.log('ğŸ¯ Updating Excalidraw scene with data:', {
                                elements: elements?.length || 0,
                                files: Object.keys(files || {}).length,
                                fileIds: Object.keys(files || {})
                            });
                            
                            // è©³ç´°æª¢æŸ¥æ¯å€‹æª”æ¡ˆ
                            if (files && Object.keys(files).length > 0) {
                                Object.entries(files).forEach(([fileId, fileData]) => {
                                    console.log(`ğŸ“ File ${fileId}:`, {
                                        hasDataURL: !!fileData?.dataURL,
                                        dataURLStart: fileData?.dataURL?.substring(0, 50),
                                        fileSize: fileData?.dataURL?.length,
                                        mimeType: fileData?.mimeType
                                    });
                                });
                            }
                            
                            // æª¢æŸ¥åœ–ç‰‡å…ƒç´ èˆ‡æª”æ¡ˆçš„å°æ‡‰é—œä¿‚
                            const imageElements = elements?.filter(el => el.type === 'image') || [];
                            console.log(`ğŸ–¼ï¸  Found ${imageElements.length} image elements:`);
                            imageElements.forEach(img => {
                                const hasFile = files && files[img.fileId];
                                console.log(`  - Image ${img.id} â†’ File ${img.fileId}: ${hasFile ? 'âœ… æœ‰æª”æ¡ˆ' : 'âŒ ç¼ºå°‘æª”æ¡ˆ'}`);
                            });
                            
                            // æ›´æ–°æª”æ¡ˆå¿«å–
                            this.fileCache.clear();
                            Object.entries(files || {}).forEach(([fileId, fileData]) => {
                                this.fileCache.set(fileId, fileData);
                                console.log(`ğŸ’¾ Cached file: ${fileId}, size: ${fileData?.dataURL?.length || 0}`);
                            });
                            
                            console.log('ğŸš€ Calling updateScene...');
                            this.excalidrawAPI.updateScene({
                                elements: elements || [],
                                appState: appState || {},
                                files: files || {}
                            });
                            
                            // ğŸš« æš«æ™‚åœç”¨é¡å¤–æ­·å²æ¸…é™¤
                            // setTimeout(() => {
                            //     this.forceResetExcalidrawHistory();
                            // }, 50);
                            
                            // è¼‰å…¥å®Œæˆå¾Œè‡ªå‹•å±…ä¸­å…§å®¹ä¸¦æ¸…é™¤æ­·å²
                            setTimeout(() => {
                                this.scrollToContentCenter();
                                this.clearExcalidrawHistory();
                                console.log('ğŸ§¹ Final history cleanup after note load');
                            }, 100);
                            
                            // æª¢æŸ¥æ›´æ–°å¾Œçš„ç‹€æ…‹
                            setTimeout(() => {
                                if (this.excalidrawAPI) {
                                    const currentFiles = this.excalidrawAPI.getFiles();
                                    console.log('ğŸ” Post-update files in Excalidraw:', {
                                        count: Object.keys(currentFiles).length,
                                        ids: Object.keys(currentFiles)
                                    });
                                    
                                    this.excalidrawAPI.refresh();
                                    console.log('ğŸ”„ Excalidraw refreshed');
                                }
                            }, 200);
                            
                        } catch (updateError) {
                            console.error('âŒ Failed to update Excalidraw scene:', updateError);
                        }
                    } else {
                        console.log('Excalidraw API not available, using fallback method');
                        // Fallback: Store data globally and let Excalidraw pick it up
                        window.pendingExcalidrawData = { elements, appState, files };
                        
                        // Try to trigger a re-render by recreating the component
                        this.setupExcalidraw();
                    }
                    
                    console.log('Scene update attempted');
                    
                } catch (error) {
                    console.error('Failed to load and display canvas data:', error);
                }

                this.renderNotesList();
                this.hideSidebar();
                console.log(`=== Note selection complete ===`);
            }

            async ensureExcalidrawReady() {
                console.log('Ensuring Excalidraw is ready...');
                
                if (this.excalidrawAPI) {
                    console.log('Excalidraw API already available');
                    return true;
                }

                // Prevent multiple initialization attempts
                if (this.isInitializing) {
                    console.log('Already initializing, waiting...');
                    let attempts = 0;
                    const maxAttempts = 30;
                    
                    while (this.isInitializing && attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    return this.excalidrawAPI !== null;
                }

                this.isInitializing = true;

                try {
                    console.log('Starting Excalidraw initialization...');
                    
                    // Check if container exists
                    const container = document.getElementById('canvasContainer');
                    if (!container) {
                        console.error('Canvas container not found');
                        return false;
                    }

                    // Setup Excalidraw if not exists
                    if (!document.getElementById('excalidrawWrapper') || !this.excalidrawAPI) {
                        const success = this.setupExcalidraw();
                        if (!success) {
                            console.error('Failed to setup Excalidraw');
                            return false;
                        }
                    }

                    // Wait for API to be ready with timeout
                    let attempts = 0;
                    const maxAttempts = 50; // Increase attempts
                    
                    console.log('Waiting for Excalidraw API...');
                    while (!this.excalidrawAPI && attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, 100)); // Shorter intervals
                        attempts++;
                        
                        // Try to find Excalidraw instance in DOM
                        const excalidrawElement = wrapper.querySelector('.excalidraw');
                        if (excalidrawElement && !this.excalidrawAPI) {
                            console.log('Excalidraw DOM found but API not set, checking again...');
                            // Sometimes the API takes longer to be available
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        if (attempts % 5 === 0) {
                            console.log(`API wait attempt ${attempts}/${maxAttempts}`);
                        }
                    }

                    const isReady = this.excalidrawAPI !== null;
                    console.log(`Excalidraw ready: ${isReady}`, this.excalidrawAPI);
                    return isReady;
                } finally {
                    this.isInitializing = false;
                }
            }

            async deleteNote(noteId) {
                if (!confirm('Are you sure you want to delete this note?')) return;

                await this.db.deleteNote(noteId);
                this.notes = this.notes.filter(n => n.id !== noteId);
                
                if (this.currentNote?.id === noteId) {
                    this.currentNote = null;
                    document.getElementById('canvasTitle').textContent = 'Select a note to start drawing';
                    this.showEmptyState();
                }
                
                this.renderNotesList();
                this.updateStorageInfo();
            }

            async duplicateNote(noteId) {
                const originalNote = this.notes.find(n => n.id === noteId);
                const canvasData = await this.db.getCanvasData(noteId);
                
                const newNote = {
                    id: this.generateId(),
                    title: `${originalNote.title} (Copy)`,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    elementCount: originalNote.elementCount
                };

                await this.db.saveNote(newNote);
                await this.db.saveCanvasData(newNote.id, canvasData || { elements: [], appState: {} });
                
                this.notes.unshift(newNote);
                this.renderNotesList();
                this.updateStorageInfo();
            }

            async saveCurrentCanvas(elements, appState, files) {
                if (!this.currentNote) {
                    console.warn('No current note to save to');
                    return;
                }
                
                // ğŸ”¥ CRITICAL: å–å¾—ç•¶å‰ç­†è¨˜IDçš„å¿«ç…§ï¼Œé˜²æ­¢åœ¨asyncæ“ä½œä¸­è¢«æ”¹è®Š
                const targetNoteId = this.currentNote.id;
                const targetNoteTitle = this.currentNote.title;


                try {
                    console.log(`ğŸ”„ Saving canvas for note: ${targetNoteTitle} (ID: ${targetNoteId}) with ${elements.length} elements`);
                    console.log(`ğŸ” Current note when saving: ${this.currentNote?.title} (${this.currentNote?.id})`);
                    
                    // Clean appState for serialization (remove Map objects and problematic properties)
                    const cleanAppState = { ...appState };
                    if (cleanAppState.collaborators) {
                        delete cleanAppState.collaborators;
                    }
                    // Remove potentially problematic scroll coordinates
                    delete cleanAppState.offsetLeft;
                    delete cleanAppState.offsetTop;
                    delete cleanAppState.width;
                    delete cleanAppState.height;
                    
                    // Save files if provided (åˆ°å…¨åŸŸæª”æ¡ˆåº«ï¼Œä¸é‡è¤‡å„²å­˜)
                    if (files) {
                        console.log(`Checking ${Object.keys(files).length} files for global storage`);
                        for (const [fileId, fileData] of Object.entries(files)) {
                            await this.db.saveFile(fileId, fileData);
                        }
                    }
                    
                    // Prepare canvas data
                    const canvasData = {
                        elements: elements || [],
                        appState: cleanAppState || {}
                    };
                    
                    // Save canvas data to IndexedDB using snapshot ID
                    await this.db.saveCanvasData(targetNoteId, canvasData);
                    console.log(`Canvas data saved successfully for note ${targetNoteId}`);
                    
                    // Calculate character count from text elements
                    let characterCount = 0;
                    elements.forEach(element => {
                        if (element.type === 'text' && element.text) {
                            characterCount += element.text.length;
                        }
                    });
                    
                    // ğŸ”¥ CRITICAL: åªæœ‰ç•¶ç›®æ¨™ç­†è¨˜ä»æ˜¯ç•¶å‰ç­†è¨˜æ™‚æ‰æ›´æ–°
                    if (this.currentNote && this.currentNote.id === targetNoteId) {
                        this.currentNote.elementCount = elements.length;
                        this.currentNote.characterCount = Math.min(characterCount, 4095); // é™åˆ¶åœ¨4095ä»¥å…§
                        this.currentNote.updatedAt = new Date().toISOString();
                        await this.db.saveNote(this.currentNote);
                        console.log(`âœ… Note metadata updated - Characters: ${this.currentNote.characterCount}, Elements: ${this.currentNote.elementCount}`);
                    } else {
                        console.warn(`âš ï¸ Skipped metadata update - current note changed during save operation (target: ${targetNoteId}, current: ${this.currentNote?.id})`);
                    }
                    
                    // Show save status
                    this.showSaveStatus();
                    
                } catch (error) {
                    console.error('Failed to save canvas:', error);
                } finally {
                    // Saving complete
                }
            }

            showSaveStatus() {
                const saveStatus = document.getElementById('saveStatus');
                if (saveStatus && this.currentNote) {
                    saveStatus.style.display = 'flex';
                    saveStatus.style.opacity = '1';
                    
                    // Hide after 2 seconds
                    setTimeout(() => {
                        saveStatus.style.opacity = '0';
                        setTimeout(() => {
                            saveStatus.style.display = 'none';
                        }, 300);
                    }, 2000);
                }
            }

            async autoSave() {
                if (!this.currentNote || !this.excalidrawAPI) return;
                
                // ğŸ”¥ CRITICAL: å–å¾—ç•¶å‰ç­†è¨˜IDå¿«ç…§ï¼Œé˜²æ­¢asyncæ“ä½œä¸­è¢«æ”¹è®Š
                const targetNoteId = this.currentNote.id;
                const targetNoteTitle = this.currentNote.title;
                console.log(`ğŸ”„ AutoSave started for note: ${targetNoteTitle} (${targetNoteId})`);

                const elements = this.excalidrawAPI.getSceneElements();
                const appState = this.excalidrawAPI.getAppState();
                let files = this.excalidrawAPI.getFiles();
                
                // åˆä½µå¿«å–ä¸­çš„æª”æ¡ˆ
                const cachedFiles = {};
                this.fileCache.forEach((fileData, fileId) => {
                    cachedFiles[fileId] = fileData;
                });
                
                // å„ªå…ˆä½¿ç”¨å¿«å–ï¼Œç„¶å¾Œä½¿ç”¨APIè¿”å›çš„æª”æ¡ˆ
                files = { ...files, ...cachedFiles };
                
                console.log('Auto-save files check:', {
                    apiFiles: Object.keys(this.excalidrawAPI.getFiles()).length,
                    cachedFiles: this.fileCache.size,
                    finalFiles: Object.keys(files).length,
                    fileIds: Object.keys(files)
                });
                
                // ğŸ”¥ CRITICAL: åœ¨åŸ·è¡ŒsaveCurrentCanvaså‰å†æ¬¡æª¢æŸ¥ç›®æ¨™ç­†è¨˜
                if (this.currentNote && this.currentNote.id === targetNoteId) {
                    await this.saveCurrentCanvas(elements, appState, files);
                    this.renderNotesList();
                    console.log(`âœ… AutoSave completed for note: ${targetNoteId}`);
                } else {
                    console.warn(`âš ï¸ AutoSave cancelled - note changed during save (target: ${targetNoteId}, current: ${this.currentNote?.id})`);
                }
            }

            setupExcalidraw() {
                try {
                    console.log('Setting up Excalidraw...');
                    const container = document.getElementById('canvasContainer');
                    
                    if (!container) {
                        console.error('Canvas container not found');
                        return false;
                    }
                    
                    // Don't re-initialize if already exists and working
                    if (document.getElementById('excalidrawWrapper') && this.excalidrawAPI) {
                        console.log('Excalidraw already initialized');
                        return true;
                    }
                    
                    // Clear container and create wrapper
                    container.innerHTML = '<div class="excalidraw-wrapper" id="excalidrawWrapper"></div>';
                    
                    const wrapper = document.getElementById('excalidrawWrapper');
                    if (!wrapper) {
                        console.error('Failed to create excalidraw wrapper');
                        return false;
                    }
                    
                    // Reset API reference
                    this.excalidrawAPI = null;
                    
                    // Check if React and Excalidraw are available
                    if (typeof React === 'undefined' || typeof ReactDOM === 'undefined' || typeof ExcalidrawLib === 'undefined') {
                        console.error('React or Excalidraw libraries not loaded');
                        return false;
                    }
                    
                    // Create Excalidraw component with onLoad callback
                    const ExcalidrawComponent = React.createElement(ExcalidrawLib.Excalidraw, {
                        ref: (api) => {
                            console.log('Excalidraw ref callback called');
                            if (api) {
                                this.excalidrawAPI = api;
                                console.log('Excalidraw API set via ref');
                            }
                        },
                        excalidrawAPI: (api) => {
                            console.log('Excalidraw excalidrawAPI callback called');
                            if (api) {
                                this.excalidrawAPI = api;
                                console.log('Excalidraw API set via excalidrawAPI');
                                
                                // å»¶é²åŸ·è¡Œå…§å®¹å±…ä¸­ä¸¦æ¸…é™¤æ­·å²ï¼Œç¢ºä¿å…ƒç´ å·²è¼‰å…¥
                                setTimeout(() => {
                                    this.scrollToContentCenter();
                                    this.clearExcalidrawHistory();
                                    console.log('ğŸ§¹ Initial history cleanup');
                                }, 500);
                            }
                        },
                        onChange: (elements, appState, files) => {
                            // ç›£è½æª”æ¡ˆè®Šæ›´
                            const imageElements = elements.filter(el => el.type === 'image');
                            
                            if (imageElements.length > 0) {
                                console.log(`ğŸ“¸ onChange: ${imageElements.length} image elements, ${Object.keys(files || {}).length} files available`);
                                
                                // æª¢æŸ¥æ¯å€‹åœ–ç‰‡å…ƒç´ æ˜¯å¦æœ‰å°æ‡‰çš„æª”æ¡ˆ
                                imageElements.forEach(img => {
                                    const hasFile = files && files[img.fileId];
                                    if (!hasFile) {
                                        console.warn(`âš ï¸  Image element ${img.id} missing file ${img.fileId}`);
                                        
                                        // å˜—è©¦å¾å¿«å–ä¸­æ¢å¾©
                                        if (this.fileCache.has(img.fileId)) {
                                            console.log(`ğŸ”„ Restoring file ${img.fileId} from cache`);
                                            if (!files) files = {};
                                            files[img.fileId] = this.fileCache.get(img.fileId);
                                        }
                                    }
                                });
                            }
                            
                            if (files && Object.keys(files).length > 0) {
                                console.log('Files changed in Excalidraw:', Object.keys(files));
                                // æ›´æ–°æª”æ¡ˆå¿«å–
                                Object.entries(files).forEach(([fileId, fileData]) => {
                                    this.fileCache.set(fileId, fileData);
                                    console.log(`Cached file ${fileId}, dataURL: ${fileData?.dataURL?.length} bytes`);
                                });
                            }
                            
                            // Original onChange logic
                            // Set API on first onChange if not already set
                            if (!this.excalidrawAPI) {
                                // Try to get API from the event
                                const excalidrawWrapper = document.getElementById('excalidrawWrapper');
                                if (excalidrawWrapper && excalidrawWrapper._reactInternalFiber) {
                                    console.log('Trying to get API from DOM...');
                                }
                            }
                            
                            // Update current note's element count in real-time
                            if (this.currentNote) {
                                this.currentNote.elementCount = elements.length;
                                this.currentNote.updatedAt = new Date().toISOString();
                                
                                // Debounce the render update to avoid performance issues
                                clearTimeout(this.renderTimeout);
                                this.renderTimeout = setTimeout(() => {
                                    this.renderNotesList();
                                }, 300);
                                
                                // Debounce auto-save for real-time saving (including files)
                                clearTimeout(this.autoSaveTimeout);
                                this.autoSaveTimeout = setTimeout(() => {
                                    // ğŸ”¥ CRITICAL: æª¢æŸ¥ç•¶å‰ç­†è¨˜æ˜¯å¦ä»ç„¶å­˜åœ¨ï¼Œé˜²æ­¢åˆ‡æ›å¾Œèª¤å­˜
                                    if (this.currentNote) {
                                        console.log(`â° Auto-saving to note: ${this.currentNote.title} (${this.currentNote.id})`);
                                        this.saveCurrentCanvas(elements, appState, files);
                                    } else {
                                        console.warn('âš ï¸ Auto-save cancelled - no current note');
                                    }
                                }, 1000); // Save after 1 second of inactivity
                            }
                        },
                        initialData: {
                            elements: window.pendingExcalidrawData?.elements || [],
                            appState: { 
                                zenModeEnabled: false,
                                viewBackgroundColor: "#ffffff",
                                collaborators: new Map(),
                                gridSize: null,
                                activeTool: {
                                    type: "selection"
                                },
                                scrollX: 0,
                                scrollY: 0,
                                zoom: { value: 1 },
                                // ç§»é™¤æ‰‹å‹•æ­·å²è¨­å®šï¼Œæ”¹ç”¨å®˜æ–¹API
                                ...window.pendingExcalidrawData?.appState,
                                // Force override these to prevent offset issues
                                scrollX: 0,
                                scrollY: 0,
                                activeTool: { type: "selection" }
                            },
                            files: window.pendingExcalidrawData?.files || {}
                        }
                    });

                    ReactDOM.render(ExcalidrawComponent, wrapper);
                    
                    // Clean up pending data after use
                    if (window.pendingExcalidrawData) {
                        console.log('Used pending Excalidraw data:', window.pendingExcalidrawData);
                        setTimeout(() => {
                            delete window.pendingExcalidrawData;
                        }, 1000);
                    }
                    
                    // Additional check after render
                    setTimeout(() => {
                        console.log('Post-render API check:', this.excalidrawAPI);
                    }, 100);
                    
                    console.log('Excalidraw setup completed');
                    return true;
                } catch (error) {
                    console.error('Failed to setup Excalidraw:', error);
                    return false;
                }
            }

            showEmptyState() {
                const container = document.getElementById('canvasContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-draw-polygon"></i>
                        <h3>Start Creating</h3>
                        <p>Create a new note to begin drawing your visual ideas</p>
                    </div>
                `;
            }

            async updateStorageInfo() {
                const usage = await this.db.getStorageUsage();
                const usedMB = Math.round(usage.used / 1024 / 1024);
                const quotaMB = Math.round(usage.quota / 1024 / 1024);
                const percentage = (usage.used / usage.quota) * 100;

                document.getElementById('storageText').textContent = `Storage: ${usedMB} MB / ~${quotaMB} MB`;
                document.getElementById('storageFill').style.width = `${Math.min(percentage, 100)}%`;
            }

            searchNotes(term) {
                this.searchTerm = term;
                this.renderNotesList();
            }

            // Utility functions
            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatDate(dateString) {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m`;
                if (diffHours < 24) return `${diffHours}h`;
                if (diffDays < 7) return `${diffDays}d`;
                return date.toLocaleDateString();
            }



            hideSidebar() {
                // Only hide on mobile
                if (window.innerWidth <= 768) {
                    document.getElementById('sidebar').classList.remove('open');
                }
            }

            async debugFiles() {
                if (!this.currentNote) {
                    alert('No note selected');
                    return;
                }
                
                console.log('=== DEBUG FILES ===');
                console.log('Current note:', this.currentNote);
                
                // Check current scene files
                if (this.excalidrawAPI) {
                    const currentFiles = this.excalidrawAPI.getFiles();
                    console.log('Current Excalidraw files:', currentFiles);
                }
                
                // Check database files
                try {
                    const dbFiles = await this.db.getNoteFiles(this.currentNote.id);
                    console.log('Database files:', dbFiles);
                    
                    // Check if files match
                    alert(`Debug Info:
Current Note: ${this.currentNote.title}
Database Files: ${Object.keys(dbFiles).length}
Check console for detailed info`);
                } catch (error) {
                    console.error('Error loading files:', error);
                    alert('Error loading files: ' + error.message);
                }
            }

            async cleanupOrphanedImages() {
                if (!this.currentNote || !this.excalidrawAPI) {
                    alert('No note selected or Excalidraw not ready');
                    return;
                }
                
                try {
                    console.log('=== CLEANING ORPHANED IMAGES ===');
                    
                    const elements = this.excalidrawAPI.getSceneElements();
                    const files = this.excalidrawAPI.getFiles();
                    const dbFiles = await this.db.getNoteFiles(this.currentNote.id);
                    
                    // Find image elements without valid files
                    const imageElements = elements.filter(el => el.type === 'image');
                    const orphanedImages = imageElements.filter(img => {
                        const hasValidFile = img.fileId && (files[img.fileId] || dbFiles[img.fileId]);
                        return !hasValidFile;
                    });
                    
                    console.log(`Found ${orphanedImages.length} orphaned images out of ${imageElements.length} total images`);
                    
                    if (orphanedImages.length === 0) {
                        alert('No orphaned images found!');
                        return;
                    }
                    
                    // Confirm removal
                    const confirmed = confirm(`Found ${orphanedImages.length} broken image(s). Remove them?`);
                    if (!confirmed) return;
                    
                    // Remove orphaned images
                    const cleanElements = elements.filter(el => {
                        if (el.type === 'image') {
                            const hasValidFile = el.fileId && (files[el.fileId] || dbFiles[el.fileId]);
                            return hasValidFile;
                        }
                        return true;
                    });
                    
                    // Update scene without orphaned images
                    this.excalidrawAPI.updateScene({
                        elements: cleanElements
                    });
                    
                    // Save the cleaned scene
                    await this.autoSave();
                    
                    alert(`Removed ${orphanedImages.length} broken image(s). Scene cleaned!`);
                    console.log('Cleanup completed');
                    
                } catch (error) {
                    console.error('Error during cleanup:', error);
                    alert('Error during cleanup: ' + error.message);
                }
            }

            async testFileId() {
                console.log('=== TESTING FILE ID GENERATION ===');
                
                // æ¸¬è©¦ç›®å‰çš„ fileId æ ¼å¼
                if (this.excalidrawAPI) {
                    const files = this.excalidrawAPI.getFiles();
                    const elements = this.excalidrawAPI.getSceneElements();
                    
                    console.log('Current files in scene:', Object.keys(files));
                    
                    const imageElements = elements.filter(el => el.type === 'image');
                    imageElements.forEach(img => {
                        console.log(`Image element: ${img.id}, fileId: ${img.fileId}, fileId length: ${img.fileId?.length}`);
                        
                        // åˆ†æ fileId æ ¼å¼
                        if (img.fileId) {
                            const isHex = /^[0-9a-f]+$/i.test(img.fileId);
                            const isNanoid = /^[A-Za-z0-9_-]+$/.test(img.fileId);
                            
                            console.log(`FileId ${img.fileId} analysis:`, {
                                length: img.fileId.length,
                                isHexOnly: isHex,
                                isNanoidFormat: isNanoid,
                                possibleType: img.fileId.length === 40 && isHex ? 'SHA-1' : 
                                            img.fileId.length === 21 && isNanoid ? 'nanoid' : 'unknown'
                            });
                        }
                    });
                }
                
                // æ¨¡æ“¬ç”Ÿæˆä¸€äº› ID ä¾†æ¸¬è©¦
                console.log('Generating test IDs:');
                
                // æ¨¡æ“¬ nanoid (å¦‚æœæœ‰çš„è©±)
                function generateRandomId(length = 21) {
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
                    let result = '';
                    for (let i = 0; i < length; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                }
                
                // æ¨¡æ“¬åŸºæ–¼æ™‚é–“çš„ ID
                function generateTimeBasedId() {
                    return Date.now().toString(36) + Math.random().toString(36).substr(2);
                }
                
                console.log('Random ID (nanoid-like):', generateRandomId());
                console.log('Time-based ID:', generateTimeBasedId());
                
                alert('FileID analysis logged to console. Check developer tools.');
            }

            // ğŸ–¼ï¸ åœ–ç‰‡æª¢è¦–åº«åŠŸèƒ½
            switchToNotesView() {
                this.currentView = 'notes';
                document.getElementById('notesList').style.display = 'block';
                document.getElementById('imagesGrid').style.display = 'none';
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('notesViewBtn').classList.add('active');
                document.getElementById('imagesViewBtn').classList.remove('active');
                document.getElementById('toggleViewBtn').classList.remove('active');
                
                // æ›´æ–°åˆ‡æ›æŒ‰éˆ•åœ–æ¨™
                document.getElementById('toggleViewIcon').className = 'fas fa-sticky-note';
                document.getElementById('toggleViewBtn').title = 'ç­†è¨˜æª¢è¦– - é»æ“Šåˆ‡æ›åˆ°åœ–ç‰‡åº«';
            }

            switchToImagesView() {
                this.currentView = 'images';
                document.getElementById('notesList').style.display = 'none';
                document.getElementById('imagesGrid').style.display = 'grid';
                document.getElementById('uploadArea').style.display = 'block';
                document.getElementById('notesViewBtn').classList.remove('active');
                document.getElementById('imagesViewBtn').classList.add('active');
                document.getElementById('toggleViewBtn').classList.add('active');
                
                // æ›´æ–°åˆ‡æ›æŒ‰éˆ•åœ–æ¨™
                document.getElementById('toggleViewIcon').className = 'fas fa-images';
                document.getElementById('toggleViewBtn').title = 'åœ–ç‰‡æª¢è¦–åº« - é»æ“Šåˆ‡æ›åˆ°ç­†è¨˜';
                
                this.renderImagesGrid();
                this.setupImageUpload();
            }

            // æ”¶ç¸®æ¨¡å¼ä¸‹çš„åˆ‡æ›åŠŸèƒ½
            toggleView() {
                if (this.currentView === 'notes') {
                    this.switchToImagesView();
                } else {
                    this.switchToNotesView();
                }
            }

            async renderImagesGrid() {
                try {
                    console.log('=== RENDERING IMAGES GRID ===');
                    
                    // è¼‰å…¥å…¨åŸŸæª”æ¡ˆåº«ä¸­çš„æ‰€æœ‰åœ–ç‰‡
                    const allFiles = await this.getAllFilesFromGlobalStore();
                    console.log(`Found ${allFiles.length} files in global store`);
                    
                    // èª¿è©¦ï¼šæª¢æŸ¥æª”æ¡ˆæ ¼å¼
                    if (allFiles.length > 0) {
                        console.log('Sample file structure:', {
                            id: allFiles[0].id,
                            hasData: !!allFiles[0].data,
                            hasDataURL: !!allFiles[0].data?.dataURL,
                            size: allFiles[0].size,
                            createdAt: allFiles[0].createdAt,
                            dataURLLength: allFiles[0].data?.dataURL?.length
                        });
                    }
                    
                    // åˆ†ææ¯å¼µåœ–ç‰‡çš„å¼•ç”¨æƒ…æ³
                    const imageAnalysis = await this.analyzeImageReferences(allFiles);
                    console.log('Image analysis completed:', imageAnalysis);
                    
                    // æ¸²æŸ“åœ–ç‰‡ç¶²æ ¼
                    const imagesGrid = document.getElementById('imagesGrid');
                    if (allFiles.length === 0) {
                        imagesGrid.innerHTML = `
                            <div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 40px;">
                                <i class="fas fa-images" style="font-size: 48px; margin-bottom: 16px;"></i>
                                <p>åœ–ç‰‡æª¢è¦–åº«æ˜¯ç©ºçš„</p>
                                <p style="font-size: 14px;">åœ¨ç­†è¨˜ä¸­æ·»åŠ åœ–ç‰‡å¾Œï¼Œé€™è£¡å°±æœƒé¡¯ç¤ºæ‰€æœ‰åœ–ç‰‡</p>
                            </div>
                        `;
                        return;
                    }
                    
                    const imagesHtml = allFiles.map(file => {
                        const analysis = imageAnalysis[file.id] || { referencedBy: [], isOrphaned: true };
                        const thumbnail = this.createImageThumbnail(file.data.dataURL);
                        
                        return `
                            <div class="image-card" title="${file.id}${analysis.referencedBy.length > 0 ? ' - ä½¿ç”¨æ–¼: ' + analysis.referencedBy.join(', ') : ' - æœªä½¿ç”¨'}">
                                <div class="image-thumbnail">
                                    <img src="${file.data.dataURL}" alt="Image" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">
                                </div>
                                <div class="image-info">
                                    <div class="image-id" title="${file.id}">${file.id.substring(0, 8)}...</div>
                                    <div>å¤§å°: ${this.formatFileSize(file.size || file.data?.dataURL?.length || 0)}</div>
                                    <div>å»ºç«‹: ${file.createdAt ? new Date(file.createdAt).toLocaleDateString() : 'æœªçŸ¥'}</div>
                                    <div class="image-refs">
                                        ${analysis.referencedBy.length > 0 ? 
                                            analysis.referencedBy.map(noteTitle => 
                                                `<span class="ref-tag">${noteTitle}</span>`
                                            ).join('') : 
                                            '<span style="color: #dc3545;">æœªè¢«å¼•ç”¨</span>'
                                        }
                                    </div>
                                    ${analysis.isOrphaned ? 
                                        `<button class="delete-btn" onclick="app.deleteOrphanedImage('${file.id}')" title="åˆªé™¤æœªä½¿ç”¨çš„åœ–ç‰‡">
                                            <i class="fas fa-trash"></i> åˆªé™¤
                                        </button>` : ''
                                    }
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    imagesGrid.innerHTML = imagesHtml;
                    
                } catch (error) {
                    console.error('Error rendering images grid:', error);
                    document.getElementById('imagesGrid').innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; color: #dc3545; padding: 40px;">
                            è¼‰å…¥åœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š${error.message}
                        </div>
                    `;
                }
            }

            async getAllFilesFromGlobalStore() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.db.transaction(['files'], 'readonly');
                    const store = transaction.objectStore('files');
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };
                    
                    request.onerror = () => {
                        reject(request.error);
                    };
                });
            }

            async analyzeImageReferences(allFiles) {
                const analysis = {};
                
                // åˆå§‹åŒ–æ‰€æœ‰æª”æ¡ˆç‚ºå­¤ç«‹ç‹€æ…‹
                allFiles.forEach(file => {
                    analysis[file.id] = {
                        referencedBy: [],
                        isOrphaned: true
                    };
                });
                
                // éæ­·æ‰€æœ‰ç­†è¨˜ï¼Œæ‰¾å‡ºåœ–ç‰‡å¼•ç”¨
                for (const note of this.notes) {
                    try {
                        const canvasData = await this.db.getCanvasData(note.id);
                        const elements = canvasData?.elements || [];
                        
                        elements.forEach(element => {
                            if (element.type === 'image' && element.fileId && analysis[element.fileId]) {
                                // é¿å…é‡è¤‡æ·»åŠ åŒä¸€å€‹ç­†è¨˜
                                if (!analysis[element.fileId].referencedBy.includes(note.title)) {
                                    analysis[element.fileId].referencedBy.push(note.title);
                                }
                                analysis[element.fileId].isOrphaned = false;
                            }
                        });
                    } catch (error) {
                        console.warn(`Failed to analyze note ${note.id}:`, error);
                    }
                }
                
                return analysis;
            }

            createImageThumbnail(dataURL) {
                // ç°¡å–®çš„ç¸®åœ–ç”Ÿæˆï¼ˆå¯¦éš›æ‡‰ç”¨ä¸­å¯èƒ½éœ€è¦æ›´è¤‡é›œçš„è™•ç†ï¼‰
                return dataURL;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }

            async deleteOrphanedImage(fileId) {
                try {
                    const confirmed = confirm(`ç¢ºå®šè¦åˆªé™¤é€™å¼µæœªä½¿ç”¨çš„åœ–ç‰‡å—ï¼Ÿ\nåœ–ç‰‡ID: ${fileId.substring(0, 16)}...`);
                    if (!confirmed) return;
                    
                    console.log(`Deleting orphaned image: ${fileId}`);
                    
                    const transaction = this.db.db.transaction(['files'], 'readwrite');
                    const store = transaction.objectStore('files');
                    const request = store.delete(fileId);
                    
                    request.onsuccess = () => {
                        console.log(`Successfully deleted image: ${fileId}`);
                        // é‡æ–°æ¸²æŸ“åœ–ç‰‡ç¶²æ ¼
                        this.renderImagesGrid();
                        alert('åœ–ç‰‡å·²åˆªé™¤');
                    };
                    
                    request.onerror = () => {
                        console.error(`Failed to delete image: ${fileId}`, request.error);
                        alert('åˆªé™¤åœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤');
                    };
                    
                } catch (error) {
                    console.error('Error deleting orphaned image:', error);
                    alert('åˆªé™¤åœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
                }
            }

            async migrateOldFiles() {
                try {
                    console.log('=== MIGRATING OLD FILES TO GLOBAL STORE ===');
                    
                    // æƒæè³‡æ–™åº«ä¸­æ‰€æœ‰èˆŠæ ¼å¼çš„æª”æ¡ˆ
                    const transaction = this.db.db.transaction(['files'], 'readwrite');
                    const store = transaction.objectStore('files');
                    const getAllRequest = store.getAll();
                    
                    getAllRequest.onsuccess = async () => {
                        const allRecords = getAllRequest.result;
                        console.log(`Found ${allRecords.length} existing file records`);
                        
                        // æª¢æŸ¥èˆŠæ ¼å¼æª”æ¡ˆ (æœ‰ noteId å±¬æ€§çš„)
                        const oldFormatFiles = allRecords.filter(record => record.noteId);
                        const newFormatFiles = allRecords.filter(record => !record.noteId);
                        
                        console.log(`Old format files: ${oldFormatFiles.length}, New format files: ${newFormatFiles.length}`);
                        
                        if (oldFormatFiles.length === 0) {
                            alert('æ²’æœ‰ç™¼ç¾éœ€è¦é·ç§»çš„èˆŠæª”æ¡ˆ');
                            return;
                        }
                        
                        let migratedCount = 0;
                        let errorCount = 0;
                        
                        // é·ç§»èˆŠæª”æ¡ˆåˆ°æ–°æ ¼å¼
                        for (const oldFile of oldFormatFiles) {
                            try {
                                console.log(`Migrating file: ${oldFile.id} from note: ${oldFile.noteId}`);
                                
                                // æª¢æŸ¥æ–°æ ¼å¼ä¸­æ˜¯å¦å·²å­˜åœ¨
                                const existingNew = newFormatFiles.find(f => f.id === oldFile.id);
                                if (existingNew) {
                                    console.log(`File ${oldFile.id} already exists in new format, skipping`);
                                    continue;
                                }
                                
                                // å‰µå»ºæ–°æ ¼å¼çš„æª”æ¡ˆè¨˜éŒ„
                                const newFileRecord = {
                                    id: oldFile.id,
                                    data: oldFile.data,
                                    createdAt: oldFile.timestamp || Date.now(),
                                    lastUsed: Date.now(),
                                    size: oldFile.data?.dataURL?.length || 0
                                };
                                
                                // å„²å­˜æ–°æ ¼å¼æª”æ¡ˆ
                                await new Promise((resolve, reject) => {
                                    const putRequest = store.put(newFileRecord);
                                    putRequest.onsuccess = () => resolve();
                                    putRequest.onerror = () => reject(putRequest.error);
                                });
                                
                                console.log(`âœ… Migrated file: ${oldFile.id}`);
                                migratedCount++;
                                
                            } catch (error) {
                                console.error(`âŒ Failed to migrate file ${oldFile.id}:`, error);
                                errorCount++;
                            }
                        }
                        
                        console.log(`Migration completed: ${migratedCount} migrated, ${errorCount} errors`);
                        alert(`æª”æ¡ˆé·ç§»å®Œæˆï¼\næˆåŠŸé·ç§»ï¼š${migratedCount} å€‹æª”æ¡ˆ\néŒ¯èª¤ï¼š${errorCount} å€‹æª”æ¡ˆ`);
                        
                        // é‡æ–°è¼‰å…¥ç•¶å‰ç­†è¨˜
                        if (this.currentNote) {
                            await this.selectNote(this.currentNote.id);
                        }
                    };
                    
                    getAllRequest.onerror = () => {
                        console.error('Failed to read existing files:', getAllRequest.error);
                        alert('è®€å–ç¾æœ‰æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤');
                    };
                    
                } catch (error) {
                    console.error('Error during migration:', error);
                    alert('é·ç§»éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
                }
            }

            // ğŸ”„ åœ–ç‰‡ä¸Šå‚³åŠŸèƒ½
            setupImageUpload() {
                const fileInput = document.getElementById('imageUpload');
                if (!fileInput) return;
                
                fileInput.onchange = (e) => {
                    const files = Array.from(e.target.files);
                    if (files.length > 0) {
                        this.previewSelectedImages(files);
                    }
                };
            }

            async previewSelectedImages(files) {
                const previewArea = document.getElementById('previewArea');
                const previewImages = document.getElementById('previewImages');
                const uploadBtn = document.getElementById('uploadBtn');
                const uploadStatus = document.getElementById('uploadStatus');
                
                if (files.length === 0) {
                    previewArea.style.display = 'none';
                    uploadBtn.disabled = true;
                    return;
                }
                
                previewArea.style.display = 'block';
                uploadBtn.disabled = false;
                uploadStatus.textContent = `å·²é¸æ“‡ ${files.length} å€‹æª”æ¡ˆ`;
                
                // æ¸…ç©ºé è¦½å€åŸŸ
                previewImages.innerHTML = '';
                
                // å„²å­˜é¸æ“‡çš„æª”æ¡ˆåˆ° app å¯¦ä¾‹
                this.selectedFiles = files;
                
                // ç”Ÿæˆé è¦½
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    try {
                        const dataURL = await this.fileToDataURL(file);
                        const fileId = await this.calculateSHA1(dataURL);
                        
                        const previewDiv = document.createElement('div');
                        previewDiv.style.cssText = `
                            width: 100px; 
                            height: 100px; 
                            border: 1px solid #444; 
                            border-radius: 6px; 
                            overflow: hidden; 
                            position: relative;
                            background: #222;
                        `;
                        
                        previewDiv.innerHTML = `
                            <img src="${dataURL}" style="width: 100%; height: 80px; object-fit: cover;">
                            <div style="padding: 2px; font-size: 10px; color: #999; text-align: center; white-space: nowrap; overflow: hidden;">
                                ${fileId.substring(0, 8)}...
                            </div>
                        `;
                        
                        previewImages.appendChild(previewDiv);
                        
                    } catch (error) {
                        console.error(`Failed to process file ${file.name}:`, error);
                    }
                }
            }

            async fileToDataURL(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            async calculateSHA1(dataURL) {
                // ç§»é™¤ data URL å‰ç¶´ï¼Œåªä¿ç•™ base64 è³‡æ–™
                const base64Data = dataURL.split(',')[1];
                
                // å°‡ base64 è½‰æ›ç‚º ArrayBuffer
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // è¨ˆç®— SHA-1 hash
                const hashBuffer = await crypto.subtle.digest('SHA-1', bytes);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                return hashHex;
            }

            async uploadSelectedImages() {
                if (!this.selectedFiles || this.selectedFiles.length === 0) {
                    alert('è«‹å…ˆé¸æ“‡è¦ä¸Šå‚³çš„åœ–ç‰‡');
                    return;
                }
                
                const uploadBtn = document.getElementById('uploadBtn');
                const uploadStatus = document.getElementById('uploadStatus');
                
                uploadBtn.disabled = true;
                uploadStatus.textContent = 'æ­£åœ¨ä¸Šå‚³...';
                
                let successCount = 0;
                let errorCount = 0;
                let duplicateCount = 0;
                
                try {
                    for (let i = 0; i < this.selectedFiles.length; i++) {
                        const file = this.selectedFiles[i];
                        
                        try {
                            uploadStatus.textContent = `æ­£åœ¨è™•ç† ${i + 1}/${this.selectedFiles.length}: ${file.name}`;
                            
                            // è½‰æ›ç‚º dataURL
                            const dataURL = await this.fileToDataURL(file);
                            const fileId = await this.calculateSHA1(dataURL);
                            
                            // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                            const existingFile = await this.checkFileExists(fileId);
                            if (existingFile) {
                                console.log(`File ${fileId} already exists, skipping`);
                                duplicateCount++;
                                continue;
                            }
                            
                            // æº–å‚™æª”æ¡ˆè³‡æ–™
                            const fileData = {
                                id: fileId,
                                dataURL: dataURL,
                                mimeType: file.type,
                                width: 0,  // å¯¦éš›æ‡‰ç”¨ä¸­å¯èƒ½éœ€è¦ç²å–åœ–ç‰‡å°ºå¯¸
                                height: 0,
                                created: Date.now(),
                                lastRetrieved: Date.now()
                            };
                            
                            // ä¸Šå‚³åˆ°å…¨åŸŸè³‡æ–™åº«
                            await this.db.saveFile(fileId, fileData);
                            
                            console.log(`âœ… Uploaded file: ${fileId} (${file.name})`);
                            successCount++;
                            
                        } catch (error) {
                            console.error(`âŒ Failed to upload ${file.name}:`, error);
                            errorCount++;
                        }
                    }
                    
                    // é¡¯ç¤ºçµæœ
                    const message = `ä¸Šå‚³å®Œæˆï¼\næˆåŠŸï¼š${successCount} å€‹\né‡è¤‡ï¼š${duplicateCount} å€‹\néŒ¯èª¤ï¼š${errorCount} å€‹`;
                    alert(message);
                    uploadStatus.textContent = `å®Œæˆ - æˆåŠŸ: ${successCount}, é‡è¤‡: ${duplicateCount}, éŒ¯èª¤: ${errorCount}`;
                    
                    // æ¸…ç©ºé¸æ“‡
                    this.selectedFiles = [];
                    document.getElementById('imageUpload').value = '';
                    document.getElementById('previewArea').style.display = 'none';
                    
                    // é‡æ–°æ¸²æŸ“åœ–ç‰‡åº«
                    this.renderImagesGrid();
                    
                } catch (error) {
                    console.error('Upload failed:', error);
                    alert('ä¸Šå‚³éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
                } finally {
                    uploadBtn.disabled = false;
                }
            }

            async checkFileExists(fileId) {
                try {
                    const transaction = this.db.db.transaction(['files'], 'readonly');
                    const store = transaction.objectStore('files');
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get(fileId);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Error checking file existence:', error);
                    return null;
                }
            }
        }

        // Global app instance
        let app;
        
        try {
            app = new NotesApp();
            console.log('NotesApp instance created successfully');
        } catch (error) {
            console.error('Failed to create NotesApp instance:', error);
        }

        // UI Event Handlers
        function toggleSidebarCollapse() {
            const sidebar = document.getElementById('sidebar');
            const icon = document.getElementById('toggleIcon');
            
            sidebar.classList.toggle('collapsed');
            
            if (sidebar.classList.contains('collapsed')) {
                icon.className = 'fas fa-chevron-right';
            } else {
                icon.className = 'fas fa-chevron-left';
            }
        }

        function showNewNoteModal() {
            document.getElementById('newNoteModal').classList.add('show');
            document.getElementById('noteNameInput').focus();
        }

        function hideNewNoteModal() {
            document.getElementById('newNoteModal').classList.remove('show');
            document.getElementById('noteNameInput').value = '';
        }

        function createNewNote() {
            const title = document.getElementById('noteNameInput').value.trim();
            if (title && app) {
                app.createNote(title);
                hideNewNoteModal();
            }
        }

        function searchNotes(term) {
            if (app) {
                app.searchNotes(term);
            }
        }

        function exportNote() {
            if (!app || !app.currentNote || !app.excalidrawAPI) return;
            
            const elements = app.excalidrawAPI.getSceneElements();
            const canvas = app.excalidrawAPI.getCanvasForExport();
            
            // Export as PNG
            const link = document.createElement('a');
            link.download = `${app.currentNote.title}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function shareNote() {
            if (!app || !app.currentNote) return;
            
            if (navigator.share) {
                navigator.share({
                    title: app.currentNote.title,
                    text: 'Check out my visual note!',
                    url: window.location.href
                });
            } else {
                // Fallback: copy to clipboard
                navigator.clipboard.writeText(window.location.href);
                alert('Link copied to clipboard!');
            }
        }

        function fullscreenCanvas() {
            const container = document.getElementById('canvasContainer');
            if (container.requestFullscreen) {
                container.requestFullscreen();
            }
        }

        function editNoteName() {
            if (!app || !app.currentNote) return;
            
            const titleElement = document.getElementById('canvasTitle');
            const currentTitle = titleElement.textContent;
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.className = 'canvas-title editing';
            input.maxLength = 50;
            
            // Replace the title with input
            titleElement.parentNode.replaceChild(input, titleElement);
            input.focus();
            input.select();
            
            // Save function
            const saveTitle = async () => {
                const newTitle = input.value.trim() || 'Untitled Note';
                
                // Update note title
                app.currentNote.title = newTitle;
                app.currentNote.updatedAt = new Date().toISOString();
                await app.db.saveNote(app.currentNote);
                
                // Update display
                const newTitleElement = document.createElement('div');
                newTitleElement.className = 'canvas-title';
                newTitleElement.id = 'canvasTitle';
                newTitleElement.textContent = newTitle;
                newTitleElement.onclick = editNoteName;
                newTitleElement.title = 'Click to edit note name';
                
                input.parentNode.replaceChild(newTitleElement, input);
                
                // Refresh notes list
                app.renderNotesList();
            };
            
            // Cancel function
            const cancelEdit = () => {
                const titleElement = document.createElement('div');
                titleElement.className = 'canvas-title';
                titleElement.id = 'canvasTitle';
                titleElement.textContent = currentTitle;
                titleElement.onclick = editNoteName;
                titleElement.title = 'Click to edit note name';
                
                input.parentNode.replaceChild(titleElement, input);
            };
            
            // Event listeners
            input.addEventListener('blur', saveTitle);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });
        }

        async function debugCurrentNote() {
            if (!app || !app.currentNote) {
                alert('No current note selected');
                return;
            }

            try {
                console.log('=== DEBUG INFO ===');
                console.log('Current note:', app.currentNote);
                
                // Get current canvas state
                if (app.excalidrawAPI) {
                    const elements = app.excalidrawAPI.getSceneElements();
                    const appState = app.excalidrawAPI.getAppState();
                    const currentFiles = app.excalidrawAPI.getFiles();
                    
                    console.log('Current canvas elements:', elements);
                    console.log('Current canvas appState:', appState);
                    console.log('Current Excalidraw files:', currentFiles);
                    
                    // Check image elements specifically
                    const imageElements = elements.filter(el => el.type === 'image');
                    console.log(`Found ${imageElements.length} image elements:`, imageElements);
                    
                    // Check file references
                    imageElements.forEach(imgEl => {
                        if (imgEl.fileId) {
                            const fileData = currentFiles[imgEl.fileId];
                            console.log(`Image element ${imgEl.id} references file ${imgEl.fileId}:`, {
                                hasFile: !!fileData,
                                fileData: fileData
                            });
                        }
                    });
                }
                
                // Check what's stored in database
                const storedData = await app.db.getCanvasData(app.currentNote.id);
                console.log('Stored canvas data:', storedData);
                
                // Check stored files
                const storedFiles = await app.db.getNoteFiles(app.currentNote.id);
                console.log('Stored files:', storedFiles);
                
                // Validate stored file data
                for (const [fileId, fileData] of Object.entries(storedFiles)) {
                    console.log(`Stored file ${fileId}:`, {
                        mimeType: fileData?.mimeType,
                        hasDataURL: !!(fileData?.dataURL),
                        dataURLLength: fileData?.dataURL?.length,
                        isValidDataURL: fileData?.dataURL?.startsWith('data:')
                    });
                }
                
                // Manual save test
                if (app.excalidrawAPI) {
                    const elements = app.excalidrawAPI.getSceneElements();
                    const appState = app.excalidrawAPI.getAppState();
                    const files = app.excalidrawAPI.getFiles();
                    console.log('Files to save:', files);
                    await app.saveCurrentCanvas(elements, appState, files);
                    console.log('Manual save completed');
                }
                
                alert('Debug info logged to console. Check developer tools.');
            } catch (error) {
                console.error('Debug failed:', error);
                alert('Debug failed: ' + error.message);
            }
        }
        

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'n':
                        e.preventDefault();
                        showNewNoteModal();
                        break;
                    case 's':
                        e.preventDefault();
                        if (app) app.autoSave();
                        break;
                    case 'f':
                        e.preventDefault();
                        document.querySelector('.search-box').focus();
                        break;
                }
            }
            
            if (e.key === 'Escape') {
                hideNewNoteModal();
            }
        });

        // Modal click outside to close
        document.getElementById('newNoteModal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                hideNewNoteModal();
            }
        });

        // Enter key in modal input
        document.getElementById('noteNameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                createNewNote();
            }
        });

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded, initializing app...');
            
            // Check if required libraries are loaded
            if (typeof React === 'undefined') {
                console.error('React not loaded');
                return;
            }
            if (typeof ReactDOM === 'undefined') {
                console.error('ReactDOM not loaded');
                return;
            }
            if (typeof ExcalidrawLib === 'undefined') {
                console.error('ExcalidrawLib not loaded');
                return;
            }
            
            if (!app) {
                console.error('App instance not created');
                return;
            }
            
            console.log('All libraries loaded, starting app initialization...');
            app.init().catch(error => {
                console.error('App initialization failed:', error);
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                document.getElementById('sidebar').classList.remove('open');
            }
        });
    </script>
</body>
</html>